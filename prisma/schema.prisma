// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL") // Pooled connection for queries
  directUrl = env("POSTGRES_URL_NON_POOLING") // Direct connection for migrations
}

// ==========================================
// CORE ENTITIES
// ==========================================

model Staff {
  id         String    @id @default(cuid())
  email      String    @unique
  username   String?   @unique
  password   String
  firstName  String
  lastName   String
  role       StaffRole @default(EMPLOYEE)
  department String?
  position   String?
  phone      String?
  rut        String? // Chilean RUT for tax purposes
  isActive   Boolean   @default(true)
  hireDate   DateTime?
  metadata   Json      @default("{}")
  tenantId   String
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Salary & Payroll fields
  salary            Decimal?   @db.Decimal(12, 2)
  salaryType        SalaryType @default(MONTHLY)
  hourlyRate        Decimal?   @db.Decimal(10, 2)
  vacationDaysTotal Int        @default(15)
  vacationDaysUsed  Int        @default(0)

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id])

  // M:M Relationships
  contactRelations  StaffContact[]    // Unified contact relations
  productsOwned     StaffProduct[]    @relation("StaffOwnsProduct")
  productReceived   ProductMovement[] @relation("ReceivedByStaff")
  productDelivered  ProductMovement[] @relation("DeliveredByStaff")
  transactions      Transaction[]     @relation("TransactionCreatedBy")
  auditLogs         AuditLog[]

  // Expense Management Relations
  expenses       Expense[]
  reimbursements EmployeeReimbursement[]

  // Staff Management & Attendance Relations
  shifts      Shift[]
  attendances Attendance[]
  payrollRuns PayrollRun[]
  ptoRequests PTORequest[]

  // Task Management Relations
  tasksCreated      Task[]               @relation("TaskCreatedBy")
  taskAssignments   TaskAssignment[]     @relation("StaffTaskAssignments")
  taskComments      TaskComment[]        @relation("StaffTaskComments")

  @@index([tenantId])
  @@map("staff")
}

model Category {
  id          String   @id @default(cuid())
  name        String
  description String?
  emoji       String   @default("üì¶")
  color       String   @default("#3B82F6")
  format      ProductFormat? // Default format for all products in this category
  isActive    Boolean  @default(true)
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([name, tenantId])
  @@index([tenantId])
  @@map("categories")
}

model Product {
  id           String      @id @default(cuid())
  sku          String
  ean          String? // Barcode
  name         String
  description  String?
  shortDescription String? // Short description for menus and quick displays
  type         ProductType @default(INPUT)
  category     String?
  brand        String?
  unitPrice    Decimal     @db.Decimal(12, 2)
  costPrice    Decimal?    @db.Decimal(12, 2)
  currentStock Int         @default(0)
  minStock     Int         @default(0)
  maxStock     Int?
  unit         String      @default("UNIT")
  format       ProductFormat? // Product format: PACKAGED, FROZEN, FRESH
  tags         String[]    @default([]) // Product tags/features: vegano, sin gluten, etc.
  hasRecipe    Boolean     @default(false)

  // Pricing fields (input only wholesalePrice, others are calculated)
  wholesalePrice Decimal? @db.Decimal(12, 2) // Base wholesale price without tax (PRECIO MAYORISTA S/IVA)
  retailPrice    Decimal? @db.Decimal(12, 2) // Retail price including tax (PRECIO VENTA IVA INCLUIDO)

  // Menu configuration
  menuSection String? // Menu section: "Comidas", "Dulces", "Bebidas Calientes", "Ice Coffee", "Frap√©s", "Mocktails", "Jugos y Limonadas"
  hoy         Boolean @default(false) // Today's special/featured item

  // Platform integration
  cafePrice      Decimal? @db.Decimal(12, 2)
  rappiPrice     Decimal? @db.Decimal(12, 2)
  pedidosyaPrice Decimal? @db.Decimal(12, 2)
  uberPrice      Decimal? @db.Decimal(12, 2)

  // Product images and source
  images    Json     @default("[]") // Array of image URLs
  sourceUrl String?  // Original product URL (for AI enrichment and reference)

  isActive  Boolean  @default(true)
  metadata  Json     @default("{}")
  tenantId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id])

  // Recipe relations
  recipesAsProduct       Recipe[]                @relation("ProductRecipes")
  recipesAsIngredient    RecipeIngredient[]      @relation("IngredientInRecipes")
  ingredientConsumptions IngredientConsumption[] @relation("ConsumedIngredients")

  // M:M Relationships
  suppliers          ProductSupplier[]
  staffOwners        StaffProduct[]       @relation("ProductOwnedByStaff")
  movements          ProductMovement[]
  transactionItems   TransactionItem[]
  purchaseOrderItems PurchaseOrderItem[]
  inventoryRecords   InventoryRecord[]

  // Variants and Modifiers
  variants       ProductVariant[]
  modifierGroups ModifierGroup[]

  @@unique([tenantId, sku])
  @@index([tenantId, type])
  @@index([tenantId, category])
  @@map("products")
}

// Product Variants (e.g., Small/Medium/Large, or Flavor variants)
model ProductVariant {
  id          String   @id @default(cuid())
  productId   String
  name        String // e.g., "Small", "Medium", "Large", "Strawberry", "Mango"
  displayName String? // Custom override name (e.g., "Fresa Deluxe" instead of "Lemonade Strawberry")
  useCustomName Boolean @default(false) // If true, use displayName instead of auto-generated name
  description String? // Variant-specific description
  sku         String? // Optional variant-specific SKU

  // Pricing
  price        Decimal? @db.Decimal(12, 2) // Absolute price for this variant (if null, uses base product price)
  costPrice    Decimal? @db.Decimal(12, 2) // Variant-specific cost

  // Channel-specific pricing
  cafePrice      Decimal? @db.Decimal(12, 2)
  rappiPrice     Decimal? @db.Decimal(12, 2)
  pedidosyaPrice Decimal? @db.Decimal(12, 2)
  uberPrice      Decimal? @db.Decimal(12, 2)

  // Inventory
  minStock    Int?
  maxStock    Int?

  // Images and source
  images      Json     @default("[]") // Variant-specific images
  sourceUrl   String?  // Original variant URL (for AI enrichment and reference)
  tags        String[] @default([]) // Variant-specific tags: vegano, sin gluten, etc.

  sortOrder   Int      @default(0)
  isDefault   Boolean  @default(false) // Mark one variant as default
  isActive    Boolean  @default(true)
  metadata    Json     @default("{}") // Store additional variant data
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  tenant  Tenant  @relation(fields: [tenantId], references: [id])

  @@index([productId])
  @@index([tenantId])
  @@map("product_variants")
}

// Modifier Groups (e.g., "Milk Options", "Ice Options", "Extras")
model ModifierGroup {
  id              String   @id @default(cuid())
  productId       String?  // If null, it's a global modifier group
  name            String // e.g., "Milk Options", "Ice Options"
  description     String?
  isRequired      Boolean  @default(false) // Must customer select at least one?
  allowMultiple   Boolean  @default(true) // Can select multiple modifiers?
  minSelections   Int      @default(0) // Minimum number of selections required
  maxSelections   Int?     // Maximum number of selections allowed
  sortOrder       Int      @default(0)
  isActive        Boolean  @default(true)
  tenantId        String
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  product   Product?          @relation(fields: [productId], references: [id], onDelete: Cascade)
  tenant    Tenant            @relation(fields: [tenantId], references: [id])
  modifiers ProductModifier[]

  @@index([productId])
  @@index([tenantId])
  @@map("modifier_groups")
}

// Product Modifiers (individual add-ons or removals)
model ProductModifier {
  id              String        @id @default(cuid())
  modifierGroupId String
  name            String // e.g., "Coconut Milk", "Remove Ice", "Extra Shot"
  type            ModifierType  @default(ADD)

  // Default price adjustment
  priceAdjustment Decimal       @default(0) @db.Decimal(12, 2) // Price change (positive for add-ons, negative for removals)

  // Channel-specific price adjustments (optional, if null uses default priceAdjustment)
  cafePriceAdjustment      Decimal? @db.Decimal(12, 2)
  rappiPriceAdjustment     Decimal? @db.Decimal(12, 2)
  pedidosyaPriceAdjustment Decimal? @db.Decimal(12, 2)
  uberPriceAdjustment      Decimal? @db.Decimal(12, 2)

  sortOrder       Int           @default(0)
  isActive        Boolean       @default(true)
  tenantId        String
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  // Relations
  modifierGroup ModifierGroup             @relation(fields: [modifierGroupId], references: [id], onDelete: Cascade)
  tenant        Tenant                    @relation(fields: [tenantId], references: [id])
  transactionItems TransactionItemModifier[]

  @@index([modifierGroupId])
  @@index([tenantId])
  @@map("product_modifiers")
}

enum ModifierType {
  ADD    // Add-on (e.g., Extra shot, Coconut milk)
  REMOVE // Removal (e.g., No ice, No sugar)
}

// Contact Type Configuration (allows custom contact types)
model ContactTypeConfig {
  id          String   @id @default(cuid())
  name        String   // e.g., "CUSTOMER", "SUPPLIER", "BRAND", or custom like "DISTRIBUTOR"
  label       String   // Display name: "Customer", "Supplier", etc.
  description String?
  icon        String?  // Emoji or icon identifier
  color       String?  // Color code for badges
  isSystem    Boolean  @default(false) // true for built-in types, false for custom
  isActive    Boolean  @default(true)
  order       Int      @default(0) // Display order
  tenantId    String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  tenant Tenant              @relation(fields: [tenantId], references: [id])
  fields ContactFieldConfig[]

  @@unique([tenantId, name])
  @@index([tenantId, isActive])
  @@map("contact_type_configs")
}

// Field Configuration for Contact Types
model ContactFieldConfig {
  id               String   @id @default(cuid())
  contactTypeId    String
  fieldName        String   // e.g., "email", "phone", "rut", "creditLimit"
  fieldLabel       String   // Display label: "Email Address", "Phone Number"
  fieldType        String   // "text", "email", "phone", "number", "select", "textarea", "date"
  isRequired       Boolean  @default(false)
  isVisible        Boolean  @default(true)
  order            Int      @default(0)
  placeholder      String?
  helpText         String?
  validation       Json?    // Validation rules: { "min": 0, "max": 100, "pattern": "..." }
  options          Json?    // For select fields: ["option1", "option2"]
  defaultValue     String?
  tenantId         String
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  contactType ContactTypeConfig @relation(fields: [contactTypeId], references: [id], onDelete: Cascade)
  tenant      Tenant            @relation(fields: [tenantId], references: [id])

  @@unique([contactTypeId, fieldName])
  @@index([contactTypeId, isVisible])
  @@map("contact_field_configs")
}

// Unified Contact model (replaces Customer and Supplier)
model Contact {
  id           String  @id @default(cuid())
  code         String
  name         String
  contactType  String  // Now stores the custom type name from ContactTypeConfig

  // Contact Information
  rut          String?
  email        String?
  phone        String?
  contactName  String? // For companies: specific contact person name

  // Address
  address String?
  city    String?
  country String?

  // Business-specific fields
  // For customers:
  creditLimit Decimal? @db.Decimal(12, 2)
  currentDebt Decimal  @default(0) @db.Decimal(12, 2)

  // For suppliers:
  paymentTerms String?
  rating       Int?

  // Common
  isActive  Boolean  @default(true)
  metadata  Json     @default("{}") // Stores custom field values
  tenantId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  tenant Tenant @relation(fields: [tenantId], references: [id])

  // M:M Relationships
  staffRelations StaffContact[]

  // Customer-specific relations
  salesTransactions Transaction[] @relation("ContactSales")

  // Supplier-specific relations
  products       ProductSupplier[]
  movements      ProductMovement[]
  purchaseOrders PurchaseOrder[]

  @@unique([tenantId, code])
  @@unique([tenantId, rut])
  @@index([tenantId])
  @@index([tenantId, contactType])
  @@map("contacts")
}

// ==========================================
// JUNCTION TABLES (M:M RELATIONSHIPS)
// ==========================================

// Unified Staff-Contact junction table (replaces StaffSupplier and StaffCustomer)
model StaffContact {
  id             String    @id @default(cuid())
  staffId        String
  contactId      String
  relationship   String // e.g., "ACCOUNT_MANAGER", "SALES_REP", "SUPPORT", "PRIMARY_CONTACT", "BUYER"
  startDate      DateTime  @default(now())
  endDate        DateTime?
  commissionRate Decimal?  @db.Decimal(5, 2) // For sales reps
  notes          String?

  staff   Staff   @relation(fields: [staffId], references: [id])
  contact Contact @relation(fields: [contactId], references: [id])

  @@unique([staffId, contactId, relationship])
  @@index([staffId])
  @@index([contactId])
  @@map("staff_contacts")
}

model StaffProduct {
  id           String    @id @default(cuid())
  staffId      String
  productId    String
  relationship String // e.g., "OWNER", "MANAGER", "PRODUCER", "RESPONSIBLE"
  startDate    DateTime  @default(now())
  endDate      DateTime?
  permissions  Json      @default("[]") // Array of permissions
  notes        String?

  staff   Staff   @relation("StaffOwnsProduct", fields: [staffId], references: [id])
  product Product @relation("ProductOwnedByStaff", fields: [productId], references: [id])

  @@unique([staffId, productId, relationship])
  @@index([staffId])
  @@index([productId])
  @@map("staff_products")
}

model ProductSupplier {
  id            String    @id @default(cuid())
  productId     String
  supplierId    String // References Contact with contactType = SUPPLIER or BOTH
  supplierSKU   String?
  supplierPrice Decimal   @db.Decimal(12, 2)
  leadTimeDays  Int?
  minOrderQty   Int       @default(1)
  isPreferred   Boolean   @default(false)
  isActive      Boolean   @default(true)
  lastPurchase  DateTime?
  notes         String?

  product  Product @relation(fields: [productId], references: [id])
  supplier Contact @relation(fields: [supplierId], references: [id])

  @@unique([productId, supplierId])
  @@index([productId])
  @@index([supplierId])
  @@map("product_suppliers")
}

// ==========================================
// MOVEMENT & TRACKING
// ==========================================

model ProductMovement {
  id            String       @id @default(cuid())
  type          MovementType
  productId     String
  quantity      Int
  fromLocation  String?
  toLocation    String?
  supplierId    String? // References Contact (supplier)
  receivedById  String?
  deliveredById String?
  referenceType String? // e.g., "PURCHASE_ORDER", "SALE", "ADJUSTMENT"
  referenceId   String?
  cost          Decimal?     @db.Decimal(12, 2)
  notes         String?
  metadata      Json         @default("{}")
  tenantId      String
  createdAt     DateTime     @default(now())

  // Relations
  product     Product  @relation(fields: [productId], references: [id])
  supplier    Contact? @relation(fields: [supplierId], references: [id])
  receivedBy  Staff?   @relation("ReceivedByStaff", fields: [receivedById], references: [id])
  deliveredBy Staff?   @relation("DeliveredByStaff", fields: [deliveredById], references: [id])
  tenant      Tenant   @relation(fields: [tenantId], references: [id])

  @@index([productId])
  @@index([supplierId])
  @@index([tenantId, createdAt])
  @@map("product_movements")
}

// ==========================================
// TRANSACTIONS & ORDERS
// ==========================================

model Transaction {
  id            String            @id @default(cuid())
  type          TransactionType
  status        TransactionStatus
  contactId     String? // References Contact (customer)
  subtotal      Decimal           @db.Decimal(12, 2)
  tax           Decimal           @db.Decimal(12, 2)
  discount      Decimal           @default(0) @db.Decimal(12, 2)
  total         Decimal           @db.Decimal(12, 2)
  paymentMethod PaymentMethod?
  paymentStatus PaymentStatus     @default(PENDING)
  notes         String?
  metadata      Json              @default("{}")
  tenantId      String
  createdById   String?
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  // Relations
  tenant                 Tenant                  @relation(fields: [tenantId], references: [id])
  contact                Contact?                @relation("ContactSales", fields: [contactId], references: [id])
  createdBy              Staff?                  @relation("TransactionCreatedBy", fields: [createdById], references: [id])
  items                  TransactionItem[]
  taxDocuments           TaxDocument[]
  ingredientConsumptions IngredientConsumption[]

  @@index([tenantId, status])
  @@index([tenantId, createdAt])
  @@index([contactId])
  @@map("transactions")
}

model TransactionItem {
  id            String  @id @default(cuid())
  transactionId String
  productId     String?
  productName   String
  variantId     String? // Selected variant (if any)
  variantName   String? // Variant name at time of purchase
  quantity      Int
  unitPrice     Decimal @db.Decimal(12, 2)
  discount      Decimal @default(0) @db.Decimal(12, 2)
  totalPrice    Decimal @db.Decimal(12, 2)

  // Relations
  transaction Transaction               @relation(fields: [transactionId], references: [id], onDelete: Cascade)
  product     Product?                  @relation(fields: [productId], references: [id])
  modifiers   TransactionItemModifier[] // Selected modifiers

  @@map("transaction_items")
}

// Track modifiers selected for each transaction item
model TransactionItemModifier {
  id                String   @id @default(cuid())
  transactionItemId String
  modifierId        String
  modifierName      String // Name at time of purchase
  modifierType      ModifierType
  priceAdjustment   Decimal  @db.Decimal(12, 2) // Price at time of purchase
  createdAt         DateTime @default(now())

  // Relations
  transactionItem TransactionItem @relation(fields: [transactionItemId], references: [id], onDelete: Cascade)
  modifier        ProductModifier @relation(fields: [modifierId], references: [id])

  @@index([transactionItemId])
  @@map("transaction_item_modifiers")
}

model PurchaseOrder {
  id           String         @id @default(cuid())
  orderNumber  String
  supplierId   String // References Contact (supplier)
  status       PurchaseStatus
  orderDate    DateTime       @default(now())
  expectedDate DateTime?
  receivedDate DateTime?
  subtotal     Decimal        @db.Decimal(12, 2)
  tax          Decimal        @db.Decimal(12, 2)
  shipping     Decimal        @default(0) @db.Decimal(12, 2)
  total        Decimal        @db.Decimal(12, 2)
  notes        String?
  metadata     Json           @default("{}")
  tenantId     String
  createdById  String?
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  // Relations
  supplier Contact             @relation(fields: [supplierId], references: [id])
  tenant   Tenant              @relation(fields: [tenantId], references: [id])
  items    PurchaseOrderItem[]

  @@unique([tenantId, orderNumber])
  @@index([supplierId])
  @@index([tenantId, status])
  @@map("purchase_orders")
}

model PurchaseOrderItem {
  id              String  @id @default(cuid())
  purchaseOrderId String
  productId       String?
  productName     String
  quantity        Int
  unitPrice       Decimal @db.Decimal(12, 2)
  totalPrice      Decimal @db.Decimal(12, 2)
  receivedQty     Int     @default(0)

  // Relations
  purchaseOrder PurchaseOrder @relation(fields: [purchaseOrderId], references: [id], onDelete: Cascade)
  product       Product?      @relation(fields: [productId], references: [id])

  @@map("purchase_order_items")
}

// ==========================================
// RECIPES & PRODUCTION
// ==========================================

// Recipe master (for MANUFACTURED & MADE_TO_ORDER products)
model Recipe {
  id          String  @id @default(cuid())
  productId   String
  name        String
  description String?

  // Recipe metadata
  servingSize  Int              @default(1)
  prepTime     Int? // minutes
  cookTime     Int? // minutes
  difficulty   RecipeDifficulty @default(EASY)
  instructions String?          @db.Text

  // Costing
  estimatedCost Decimal? @db.Decimal(12, 2)
  laborCost     Decimal? @db.Decimal(12, 2)
  overheadCost  Decimal? @db.Decimal(12, 2)
  totalCost     Decimal? @db.Decimal(12, 2)

  // Version control
  version   Int     @default(1)
  isActive  Boolean @default(true)
  isDefault Boolean @default(false)

  tenantId  String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  product           Product            @relation("ProductRecipes", fields: [productId], references: [id], onDelete: Cascade)
  tenant            Tenant             @relation(fields: [tenantId], references: [id])
  ingredients       RecipeIngredient[]
  productionBatches ProductionBatch[]

  @@index([productId])
  @@index([tenantId, isActive])
  @@map("recipes")
}

// Recipe ingredients/components (BOM)
model RecipeIngredient {
  id           String @id @default(cuid())
  recipeId     String
  ingredientId String // References Product (type = PURCHASED or MANUFACTURED)

  quantity   Decimal @db.Decimal(12, 4)
  unit       String
  isOptional Boolean @default(false)
  notes      String?

  // Costing
  unitCost  Decimal? @db.Decimal(12, 2)
  totalCost Decimal? @db.Decimal(12, 2)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  recipe     Recipe  @relation(fields: [recipeId], references: [id], onDelete: Cascade)
  ingredient Product @relation("IngredientInRecipes", fields: [ingredientId], references: [id])

  @@index([recipeId])
  @@index([ingredientId])
  @@map("recipe_ingredients")
}

// Production batches (for MANUFACTURED products)
model ProductionBatch {
  id          String @id @default(cuid())
  batchNumber String
  recipeId    String
  productId   String

  plannedQuantity Int
  actualQuantity  Int?
  status          ProductionStatus @default(PLANNED)

  startedAt   DateTime?
  completedAt DateTime?

  // Costing
  ingredientCost Decimal? @db.Decimal(12, 2)
  laborCost      Decimal? @db.Decimal(12, 2)
  overheadCost   Decimal? @db.Decimal(12, 2)
  totalCost      Decimal? @db.Decimal(12, 2)
  costPerUnit    Decimal? @db.Decimal(12, 2)

  notes       String?
  tenantId    String
  createdById String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  recipe Recipe @relation(fields: [recipeId], references: [id])
  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([tenantId, batchNumber])
  @@index([tenantId, status])
  @@map("production_batches")
}

// Ingredient consumption tracking (for MADE_TO_ORDER)
model IngredientConsumption {
  id            String  @id @default(cuid())
  transactionId String? // Links to sale transaction
  productId     String // The MADE_TO_ORDER product sold
  recipeId      String
  ingredientId  String

  quantityUsed Decimal  @db.Decimal(12, 4)
  unit         String
  cost         Decimal? @db.Decimal(12, 2)

  consumedAt DateTime @default(now())
  tenantId   String

  // Relations
  tenant      Tenant       @relation(fields: [tenantId], references: [id])
  transaction Transaction? @relation(fields: [transactionId], references: [id])
  ingredient  Product      @relation("ConsumedIngredients", fields: [ingredientId], references: [id])

  @@index([transactionId])
  @@index([productId])
  @@index([ingredientId])
  @@index([tenantId, consumedAt])
  @@map("ingredient_consumptions")
}

// ==========================================
// INVENTORY & STOCK
// ==========================================

model InventoryRecord {
  id            String    @id @default(cuid())
  productId     String
  location      String
  quantity      Int
  reservedQty   Int       @default(0)
  availableQty  Int
  lastCountDate DateTime?
  notes         String?
  tenantId      String
  updatedAt     DateTime  @updatedAt

  // Relations
  product Product @relation(fields: [productId], references: [id])
  tenant  Tenant  @relation(fields: [tenantId], references: [id])

  @@unique([productId, location, tenantId])
  @@map("inventory_records")
}

// ==========================================
// TAX & COMPLIANCE
// ==========================================

model TaxDocument {
  id            String            @id @default(cuid())
  type          TaxDocumentType
  folio         String?
  documentCode  Int?
  transactionId String?
  emitterRUT    String?
  emitterName   String?
  receiverRUT   String?
  receiverName  String?
  netAmount     Decimal?          @db.Decimal(12, 2)
  taxAmount     Decimal?          @db.Decimal(12, 2)
  totalAmount   Decimal?          @db.Decimal(12, 2)
  currency      String            @default("CLP")
  issuedAt      DateTime?
  status        TaxDocumentStatus @default(DRAFT)
  pdfUrl        String?
  xmlUrl        String?
  rawResponse   Json?
  tenantId      String
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  // Relations
  tenant      Tenant            @relation(fields: [tenantId], references: [id])
  transaction Transaction?      @relation(fields: [transactionId], references: [id])
  items       TaxDocumentItem[]
  expenses    Expense[] // Auto-generated expenses from this invoice

  @@unique([emitterRUT, folio, tenantId])
  @@index([tenantId, status])
  @@map("tax_documents")
}

model TaxDocumentItem {
  id            String  @id @default(cuid())
  taxDocumentId String
  productName   String
  quantity      Int
  unitPrice     Decimal @db.Decimal(12, 2)
  totalPrice    Decimal @db.Decimal(12, 2)

  taxDocument TaxDocument @relation(fields: [taxDocumentId], references: [id], onDelete: Cascade)

  @@map("tax_document_items")
}

// ==========================================
// EXPENSE MANAGEMENT
// ==========================================

// Company payment accounts (bank accounts, credit cards, cash)
model PaymentAccount {
  id            String      @id @default(cuid())
  name          String // "Cuenta Corriente Banco Estado", "Tarjeta Cr√©dito VISA", "Caja Chica"
  type          AccountType
  accountNumber String? // Bank account number, card last 4 digits, etc.
  bank          String? // Bank name
  currency      String      @default("CLP")
  balance       Decimal?    @db.Decimal(12, 2) // Optional current balance tracking
  isActive      Boolean     @default(true)

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  // Relations
  expenses       Expense[]
  reimbursements EmployeeReimbursement[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("payment_accounts")
}

// Employee reimbursement tracking
model EmployeeReimbursement {
  id          String              @id @default(cuid())
  staffId     String
  description String // "Reembolso gastos Septiembre 2025"
  totalAmount Decimal             @db.Decimal(12, 2)
  currency    String              @default("CLP")
  status      ReimbursementStatus @default(PENDING)

  // Payment details when reimbursed
  paidDate         DateTime?
  paidAmount       Decimal?  @db.Decimal(12, 2)
  paymentAccountId String? // Which account was used to pay
  paymentReference String? // Transfer reference, check number, etc.
  notes            String?

  tenantId String

  // Relations
  staff          Staff           @relation(fields: [staffId], references: [id])
  tenant         Tenant          @relation(fields: [tenantId], references: [id])
  paymentAccount PaymentAccount? @relation(fields: [paymentAccountId], references: [id])
  expenses       Expense[] // Expenses included in this reimbursement

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("employee_reimbursements")
}

// Enhanced expense categories
model ExpenseCategory {
  id          String  @id @default(cuid())
  name        String
  emoji       String?
  description String?
  color       String  @default("#64748B")
  format      ProductFormat? // Default format for products in this category
  isActive    Boolean @default(true)

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  expenses Expense[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("expense_categories")
}

// Expense status tracking
model ExpenseStatus {
  id        String  @id @default(cuid())
  name      String
  color     String  @default("#64748B")
  isDefault Boolean @default(false)

  tenantId String
  tenant   Tenant @relation(fields: [tenantId], references: [id])

  expenses Expense[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("expense_statuses")
}

// Main expenses table with comprehensive payment tracking
model Expense {
  id          String   @id @default(cuid())
  date        DateTime
  supplier    String
  description String
  amount      Decimal  @db.Decimal(12, 2)
  currency    String   @default("CLP")

  // Document information
  documentType        String // FACTURA, BOLETA, RECIBO, OTRO
  documentNumber      String?
  thirdPartyDocType   String? // Type from supplier
  thirdPartyDocNumber String?
  notes               String?

  // PAYMENT TRACKING - This is the key enhancement
  paymentType      ExpensePaymentType
  paymentAccountId String? // Which company account paid (if company paid)
  staffId          String? // Which employee paid (if employee paid)
  reimbursementId  String? // Link to reimbursement if applicable

  // Company expense classification
  isCompanyExpense   Boolean @default(true) // Can be set to false for personal items
  excludeFromReports Boolean @default(false) // Exclude from company reports

  // Auto-generation from invoices
  isFromInvoice Boolean @default(false)
  taxDocumentId String? // Link to TaxDocument if auto-generated

  // Receipt/Boleta image attachment (Cloudinary)
  receiptImageUrl String? // Cloudinary URL
  receiptPublicId String? // Cloudinary public ID for deletion
  hasReceipt      Boolean @default(false)

  // Categorization
  categoryId String
  statusId   String
  tenantId   String

  // Relations
  category       ExpenseCategory        @relation(fields: [categoryId], references: [id])
  status         ExpenseStatus          @relation(fields: [statusId], references: [id])
  tenant         Tenant                 @relation(fields: [tenantId], references: [id])
  taxDocument    TaxDocument?           @relation(fields: [taxDocumentId], references: [id])
  paymentAccount PaymentAccount?        @relation(fields: [paymentAccountId], references: [id])
  staff          Staff?                 @relation(fields: [staffId], references: [id])
  reimbursement  EmployeeReimbursement? @relation(fields: [reimbursementId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("expenses")
}

// ==========================================
// SYSTEM & MULTI-TENANCY
// ==========================================

model Tenant {
  id        String   @id @default(cuid())
  name      String
  slug      String   @unique
  rut       String?
  address   String?
  phone     String?
  email     String?
  domain    String?
  settings  Json     @default("{}")
  features  Json     @default("[]")
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  staff          Staff[]
  products       Product[]
  categories     Category[]
  productVariants ProductVariant[]
  modifierGroups ModifierGroup[]
  productModifiers ProductModifier[]
  contacts       Contact[] // Unified contacts (customers + suppliers)
  transactions   Transaction[]
  taxDocuments   TaxDocument[]
  movements      ProductMovement[]
  tasks          Task[]
  purchaseOrders PurchaseOrder[]
  inventory      InventoryRecord[]

  // Recipe & Production Relations
  recipes                Recipe[]
  productionBatches      ProductionBatch[]
  ingredientConsumptions IngredientConsumption[]

  // Expense Management Relations
  paymentAccounts        PaymentAccount[]
  expenses               Expense[]
  expenseCategories      ExpenseCategory[]
  expenseStatuses        ExpenseStatus[]
  employeeReimbursements EmployeeReimbursement[]

  // Contact Type Configuration Relations
  contactTypeConfigs  ContactTypeConfig[]
  contactFieldConfigs ContactFieldConfig[]

  // Staff Management & Attendance Relations
  shifts       Shift[]
  attendances  Attendance[]
  payrollRuns  PayrollRun[]
  ptoRequests  PTORequest[]

  // API Keys
  apiKeys ApiKey[]

  @@map("tenants")
}

model AuditLog {
  id        String   @id @default(cuid())
  staffId   String?
  action    String
  entity    String
  entityId  String?
  oldData   Json?
  newData   Json?
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  staff Staff? @relation(fields: [staffId], references: [id])

  @@index([entity, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

// ==========================================
// ENUMS
// ==========================================

enum StaffRole {
  SUPER_ADMIN
  ADMIN
  MANAGER
  SUPERVISOR
  EMPLOYEE
  CONTRACTOR
  INTERN
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  IN_REVIEW
  COMPLETED
  CANCELLED
}

enum Priority {
  LOW
  MEDIUM
  HIGH
  URGENT
}

enum AssignmentRole {
  ASSIGNEE
  REVIEWER
  OBSERVER
}

enum SyncStatus {
  PENDING
  SYNCED
  CONFLICT
  ERROR
}

enum SyncDirection {
  TO_GOOGLE
  FROM_GOOGLE
  BIDIRECTIONAL
}

// ContactType enum removed - now using ContactTypeConfig for flexible contact types

enum MovementType {
  PURCHASE
  SALE
  TRANSFER
  ADJUSTMENT
  RETURN
  DAMAGE
  PRODUCTION
  PRODUCTION_INPUT // Consume insumos for production
  PRODUCTION_OUTPUT // Add manufactured product to stock
  SALE_CONSUMPTION // Auto-deduct for MADE_TO_ORDER
}

enum TransactionType {
  SALE
  REFUND
  EXCHANGE
  QUOTE
}

enum TransactionStatus {
  DRAFT
  PENDING
  COMPLETED
  CANCELLED
  REFUNDED
}

enum PaymentMethod {
  CASH
  CREDIT_CARD
  DEBIT_CARD
  TRANSFER
  CHECK
  CREDIT
  OTHER
}

enum PaymentStatus {
  PENDING
  PARTIAL
  PAID
  OVERDUE
  REFUNDED
}

enum PurchaseStatus {
  DRAFT
  ORDERED
  PARTIAL_RECEIVED
  RECEIVED
  CANCELLED
}

enum TaxDocumentType {
  BOLETA
  FACTURA
  NOTA_CREDITO
  NOTA_DEBITO
  GUIA_DESPACHO
}

enum TaxDocumentStatus {
  DRAFT
  ISSUED
  CANCELLED
  REJECTED
}

enum AccountType {
  BANK_ACCOUNT // Cuenta corriente/ahorro
  CREDIT_CARD // Tarjeta de cr√©dito
  DEBIT_CARD // Tarjeta d√©bito
  CASH // Efectivo/caja chica
  DIGITAL_WALLET // Mercado Pago, PayPal, etc.
  OTHER
}

enum ReimbursementStatus {
  PENDING // Pending approval/payment
  APPROVED // Approved but not paid
  PAID // Fully paid
  PARTIALLY_PAID // Partially paid
  REJECTED // Rejected
  CANCELLED // Cancelled
}

enum ExpensePaymentType {
  COMPANY_ACCOUNT // Paid directly by company account
  EMPLOYEE_PAID // Employee paid, needs reimbursement
  PERSONAL // Personal expense, no reimbursement needed
  MIXED // Split between company and personal
}

enum ProductType {
  INPUT // Raw materials and ingredients (insumos)
  READY_PRODUCT // Bought ready to sell (productos comprados listos)
  MANUFACTURED // Made with recipe, produced in batches
  MADE_TO_ORDER // Made on-the-spot (elaborados al momento)
  SERVICE // Non-physical service
}

enum ProductFormat {
  PACKAGED // Envasado - Packaged products
  FROZEN   // Congelado - Frozen products
  FRESH    // Fresco - Fresh products
}

enum ProductionStatus {
  PLANNED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum RecipeDifficulty {
  EASY
  MEDIUM
  HARD
  EXPERT
}

enum SalaryType {
  HOURLY
  MONTHLY
}

enum AttendanceStatus {
  ON_TIME           // Checked in within 15 min grace period
  LATE              // Checked in after grace period
  ABSENT            // No check-in
  EARLY_DEPARTURE   // Left before shift end
  APPROVED_PTO      // Scheduled time off
}

enum PayrollStatus {
  PENDING
  APPROVED
  PAID
}

enum PTOStatus {
  PENDING
  APPROVED
  DENIED
}

// ==========================================
// STAFF MANAGEMENT & ATTENDANCE
// ==========================================

model Shift {
  id           String   @id @default(cuid())
  name         String   // e.g., "Morning Shift" or "Dec 25 Extra"
  startTime    DateTime // Time component used for recurring, full datetime for one-time
  endTime      DateTime
  dayOfWeek    Int?     // 0-6 (Sun-Sat) for recurring shifts, null for one-time
  isRecurring  Boolean  @default(false)
  specificDate DateTime? // For one-time shifts only
  staffId      String
  tenantId     String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  staff       Staff        @relation(fields: [staffId], references: [id], onDelete: Cascade)
  tenant      Tenant       @relation(fields: [tenantId], references: [id])
  attendances Attendance[]

  @@index([tenantId, staffId])
  @@index([specificDate])
  @@map("shifts")
}

model Attendance {
  id             String           @id @default(cuid())
  shiftId        String
  staffId        String
  date           DateTime         // Which day this attendance is for
  scheduledStart DateTime         // When shift was supposed to start
  scheduledEnd   DateTime         // When shift was supposed to end
  actualCheckIn  DateTime?        // When they actually checked in
  actualCheckOut DateTime?        // When they actually checked out
  status         AttendanceStatus // ON_TIME, LATE, ABSENT, etc.
  minutesLate    Int?             // Minutes late (beyond 15 min grace)
  totalHours     Decimal?         @db.Decimal(5, 2) // Actual hours worked
  notes          String?          // Admin notes only
  tenantId       String
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  shift  Shift  @relation(fields: [shiftId], references: [id], onDelete: Cascade)
  staff  Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@unique([shiftId, date])
  @@index([tenantId, staffId, date])
  @@index([date])
  @@map("attendances")
}

model PayrollRun {
  id          String        @id @default(cuid())
  periodStart DateTime      // Start of pay period
  periodEnd   DateTime      // End of pay period
  staffId     String
  hoursWorked Decimal       @db.Decimal(8, 2) // Total hours in period
  regularPay  Decimal       @db.Decimal(12, 2) // Base pay
  overtimePay Decimal?      @db.Decimal(12, 2) // Overtime if applicable
  deductions  Decimal?      @db.Decimal(12, 2) // Optional deductions
  totalPay    Decimal       @db.Decimal(12, 2) // Gross pay
  netPay      Decimal       @db.Decimal(12, 2) // After deductions
  status      PayrollStatus @default(PENDING)
  paidAt      DateTime?     // When payment was made
  notes       String?
  tenantId    String
  createdAt   DateTime      @default(now())
  updatedAt   DateTime      @updatedAt

  staff  Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId, staffId])
  @@index([periodStart, periodEnd])
  @@map("payroll_runs")
}

model PTORequest {
  id          String    @id @default(cuid())
  staffId     String
  startDate   DateTime  // First day of PTO
  endDate     DateTime  // Last day of PTO
  days        Int       // Number of days requested
  reason      String?   // Optional reason
  status      PTOStatus @default(PENDING)
  requestedAt DateTime  @default(now())
  reviewedAt  DateTime? // When approved/denied
  reviewedBy  String?   // Staff ID of reviewer (admin)
  tenantId    String
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  staff  Staff  @relation(fields: [staffId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id])

  @@index([tenantId, staffId])
  @@index([status])
  @@map("pto_requests")
}

// ==========================================
// PLANNING & TASK MANAGEMENT
// ==========================================

model Task {
  id          String     @id @default(cuid())
  title       String
  description String?
  status      TaskStatus @default(TODO)
  priority    Priority   @default(MEDIUM)
  dueDate     DateTime?
  completedAt DateTime?
  googleChatSpaceId String? // Google Chat space ID for this task
  googleChatMessageId String? // Google Chat message ID for this task
  
  // Google Tasks API Integration
  googleTaskId      String?   // Google Tasks API identifier
  googleTasksListId String?   // Parent task list (usually from Chat space)
  googleTasksUpdatedAt DateTime? // Track Google's last modified timestamp
  syncStatus        SyncStatus @default(PENDING) // PENDING, SYNCED, CONFLICT, ERROR
  syncDirection     SyncDirection @default(BIDIRECTIONAL) // TO_GOOGLE, FROM_GOOGLE, BIDIRECTIONAL
  lastSyncAt        DateTime? // When was the last sync performed
  
  tenantId    String
  createdById String
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Relations
  tenant      Tenant @relation(fields: [tenantId], references: [id])
  createdBy   Staff  @relation("TaskCreatedBy", fields: [createdById], references: [id])
  assignments TaskAssignment[]
  comments    TaskComment[]

  @@index([tenantId])
  @@index([status])
  @@index([dueDate])
  @@index([createdById])
  @@index([googleTaskId])
  @@index([syncStatus])
  @@map("tasks")
}

model TaskAssignment {
  id     String @id @default(cuid())
  taskId String
  staffId String
  role   AssignmentRole @default(ASSIGNEE)
  assignedAt DateTime @default(now())
  assignedBy String // Staff ID who made the assignment

  // Relations
  task   Task  @relation(fields: [taskId], references: [id], onDelete: Cascade)
  staff  Staff @relation("StaffTaskAssignments", fields: [staffId], references: [id])

  @@unique([taskId, staffId])
  @@index([staffId])
  @@map("task_assignments")
}

model TaskComment {
  id        String   @id @default(cuid())
  taskId    String
  staffId   String
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  task  Task  @relation(fields: [taskId], references: [id], onDelete: Cascade)
  staff Staff @relation("StaffTaskComments", fields: [staffId], references: [id])

  @@index([taskId])
  @@index([staffId])
  @@map("task_comments")
}

// ==========================================
// API AUTHENTICATION
// ==========================================

model ApiKey {
  id          String   @id @default(cuid())
  name        String   // Friendly name like "Mobile App", "Website", "External Integration"
  key         String   @unique // The actual API key (hashed)
  tenantId    String
  isActive    Boolean  @default(true)
  expiresAt   DateTime? // Optional expiration
  lastUsedAt  DateTime?
  createdById String?  // Staff who created it
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([key, isActive])
  @@map("api_keys")
}
