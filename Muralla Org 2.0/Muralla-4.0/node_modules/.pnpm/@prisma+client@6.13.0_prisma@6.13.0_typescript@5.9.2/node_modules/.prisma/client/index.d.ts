
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Role
 * 
 */
export type Role = $Result.DefaultSelection<Prisma.$RolePayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model Task
 * 
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model DocumentRevision
 * 
 */
export type DocumentRevision = $Result.DefaultSelection<Prisma.$DocumentRevisionPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model Sale
 * 
 */
export type Sale = $Result.DefaultSelection<Prisma.$SalePayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model TransactionCategory
 * 
 */
export type TransactionCategory = $Result.DefaultSelection<Prisma.$TransactionCategoryPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model BankBalance
 * 
 */
export type BankBalance = $Result.DefaultSelection<Prisma.$BankBalancePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model MagicToken
 * 
 */
export type MagicToken = $Result.DefaultSelection<Prisma.$MagicTokenPayload>
/**
 * Model AuditTrail
 * 
 */
export type AuditTrail = $Result.DefaultSelection<Prisma.$AuditTrailPayload>
/**
 * Model NotificationTemplate
 * 
 */
export type NotificationTemplate = $Result.DefaultSelection<Prisma.$NotificationTemplatePayload>
/**
 * Model NotificationRule
 * 
 */
export type NotificationRule = $Result.DefaultSelection<Prisma.$NotificationRulePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Payroll
 * 
 */
export type Payroll = $Result.DefaultSelection<Prisma.$PayrollPayload>
/**
 * Model PayrollEntry
 * 
 */
export type PayrollEntry = $Result.DefaultSelection<Prisma.$PayrollEntryPayload>
/**
 * Model SalaryAdjustment
 * 
 */
export type SalaryAdjustment = $Result.DefaultSelection<Prisma.$SalaryAdjustmentPayload>
/**
 * Model EmployeeExpense
 * 
 */
export type EmployeeExpense = $Result.DefaultSelection<Prisma.$EmployeeExpensePayload>
/**
 * Model PTORequest
 * 
 */
export type PTORequest = $Result.DefaultSelection<Prisma.$PTORequestPayload>
/**
 * Model PTOBalance
 * 
 */
export type PTOBalance = $Result.DefaultSelection<Prisma.$PTOBalancePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const TaskStatus: {
  PENDING: 'PENDING',
  IN_PROGRESS: 'IN_PROGRESS',
  DONE: 'DONE'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const DocumentType: {
  WIKI: 'WIKI',
  SOP: 'SOP',
  PLAYBOOK: 'PLAYBOOK',
  TEMPLATE: 'TEMPLATE'
};

export type DocumentType = (typeof DocumentType)[keyof typeof DocumentType]


export const DocumentStatus: {
  DRAFT: 'DRAFT',
  REVIEW: 'REVIEW',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type DocumentStatus = (typeof DocumentStatus)[keyof typeof DocumentStatus]


export const TransactionType: {
  INCOME: 'INCOME',
  EXPENSE: 'EXPENSE',
  TRANSFER: 'TRANSFER'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const TransactionStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const PaymentMethod: {
  MERCADO_PAGO: 'MERCADO_PAGO',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CASH: 'CASH',
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  CHECK: 'CHECK',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const AuditOperation: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  RESTORE: 'RESTORE'
};

export type AuditOperation = (typeof AuditOperation)[keyof typeof AuditOperation]


export const NotificationType: {
  EMAIL: 'EMAIL',
  PUSH: 'PUSH',
  IN_APP: 'IN_APP',
  SMS: 'SMS'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const NotificationStatus: {
  PENDING: 'PENDING',
  SENT: 'SENT',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED'
};

export type NotificationStatus = (typeof NotificationStatus)[keyof typeof NotificationStatus]


export const RuleTrigger: {
  TASK_CREATED: 'TASK_CREATED',
  TASK_UPDATED: 'TASK_UPDATED',
  TASK_COMPLETED: 'TASK_COMPLETED',
  DOCUMENT_CREATED: 'DOCUMENT_CREATED',
  DOCUMENT_UPDATED: 'DOCUMENT_UPDATED',
  USER_REGISTERED: 'USER_REGISTERED',
  PROJECT_CREATED: 'PROJECT_CREATED',
  DEADLINE_APPROACHING: 'DEADLINE_APPROACHING',
  STOCK_LOW: 'STOCK_LOW',
  CUSTOM: 'CUSTOM'
};

export type RuleTrigger = (typeof RuleTrigger)[keyof typeof RuleTrigger]


export const PTOStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  CANCELLED: 'CANCELLED'
};

export type PTOStatus = (typeof PTOStatus)[keyof typeof PTOStatus]


export const PayrollStatus: {
  DRAFT: 'DRAFT',
  PENDING_APPROVAL: 'PENDING_APPROVAL',
  APPROVED: 'APPROVED',
  PROCESSED: 'PROCESSED',
  CANCELLED: 'CANCELLED'
};

export type PayrollStatus = (typeof PayrollStatus)[keyof typeof PayrollStatus]


export const SalaryAdjustmentType: {
  SALARY_INCREASE: 'SALARY_INCREASE',
  SALARY_DECREASE: 'SALARY_DECREASE',
  BONUS: 'BONUS',
  ALLOWANCE_CHANGE: 'ALLOWANCE_CHANGE',
  PROMOTION: 'PROMOTION',
  DEMOTION: 'DEMOTION',
  ANNUAL_REVIEW: 'ANNUAL_REVIEW'
};

export type SalaryAdjustmentType = (typeof SalaryAdjustmentType)[keyof typeof SalaryAdjustmentType]


export const ExpenseStatus: {
  PENDING: 'PENDING',
  APPROVED: 'APPROVED',
  REJECTED: 'REJECTED',
  REIMBURSED: 'REIMBURSED',
  CANCELLED: 'CANCELLED'
};

export type ExpenseStatus = (typeof ExpenseStatus)[keyof typeof ExpenseStatus]

}

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type DocumentType = $Enums.DocumentType

export const DocumentType: typeof $Enums.DocumentType

export type DocumentStatus = $Enums.DocumentStatus

export const DocumentStatus: typeof $Enums.DocumentStatus

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type AuditOperation = $Enums.AuditOperation

export const AuditOperation: typeof $Enums.AuditOperation

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type NotificationStatus = $Enums.NotificationStatus

export const NotificationStatus: typeof $Enums.NotificationStatus

export type RuleTrigger = $Enums.RuleTrigger

export const RuleTrigger: typeof $Enums.RuleTrigger

export type PTOStatus = $Enums.PTOStatus

export const PTOStatus: typeof $Enums.PTOStatus

export type PayrollStatus = $Enums.PayrollStatus

export const PayrollStatus: typeof $Enums.PayrollStatus

export type SalaryAdjustmentType = $Enums.SalaryAdjustmentType

export const SalaryAdjustmentType: typeof $Enums.SalaryAdjustmentType

export type ExpenseStatus = $Enums.ExpenseStatus

export const ExpenseStatus: typeof $Enums.ExpenseStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Roles
 * const roles = await prisma.role.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Roles
   * const roles = await prisma.role.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.role`: Exposes CRUD operations for the **Role** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.role.findMany()
    * ```
    */
  get role(): Prisma.RoleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
  get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentRevision`: Exposes CRUD operations for the **DocumentRevision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentRevisions
    * const documentRevisions = await prisma.documentRevision.findMany()
    * ```
    */
  get documentRevision(): Prisma.DocumentRevisionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sale`: Exposes CRUD operations for the **Sale** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sales
    * const sales = await prisma.sale.findMany()
    * ```
    */
  get sale(): Prisma.SaleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transactionCategory`: Exposes CRUD operations for the **TransactionCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionCategories
    * const transactionCategories = await prisma.transactionCategory.findMany()
    * ```
    */
  get transactionCategory(): Prisma.TransactionCategoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankBalance`: Exposes CRUD operations for the **BankBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankBalances
    * const bankBalances = await prisma.bankBalance.findMany()
    * ```
    */
  get bankBalance(): Prisma.BankBalanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.magicToken`: Exposes CRUD operations for the **MagicToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MagicTokens
    * const magicTokens = await prisma.magicToken.findMany()
    * ```
    */
  get magicToken(): Prisma.MagicTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditTrail`: Exposes CRUD operations for the **AuditTrail** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditTrails
    * const auditTrails = await prisma.auditTrail.findMany()
    * ```
    */
  get auditTrail(): Prisma.AuditTrailDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationTemplate`: Exposes CRUD operations for the **NotificationTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationTemplates
    * const notificationTemplates = await prisma.notificationTemplate.findMany()
    * ```
    */
  get notificationTemplate(): Prisma.NotificationTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationRule`: Exposes CRUD operations for the **NotificationRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationRules
    * const notificationRules = await prisma.notificationRule.findMany()
    * ```
    */
  get notificationRule(): Prisma.NotificationRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payroll`: Exposes CRUD operations for the **Payroll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payrolls
    * const payrolls = await prisma.payroll.findMany()
    * ```
    */
  get payroll(): Prisma.PayrollDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollEntry`: Exposes CRUD operations for the **PayrollEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollEntries
    * const payrollEntries = await prisma.payrollEntry.findMany()
    * ```
    */
  get payrollEntry(): Prisma.PayrollEntryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.salaryAdjustment`: Exposes CRUD operations for the **SalaryAdjustment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SalaryAdjustments
    * const salaryAdjustments = await prisma.salaryAdjustment.findMany()
    * ```
    */
  get salaryAdjustment(): Prisma.SalaryAdjustmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employeeExpense`: Exposes CRUD operations for the **EmployeeExpense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeExpenses
    * const employeeExpenses = await prisma.employeeExpense.findMany()
    * ```
    */
  get employeeExpense(): Prisma.EmployeeExpenseDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pTORequest`: Exposes CRUD operations for the **PTORequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PTORequests
    * const pTORequests = await prisma.pTORequest.findMany()
    * ```
    */
  get pTORequest(): Prisma.PTORequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.pTOBalance`: Exposes CRUD operations for the **PTOBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PTOBalances
    * const pTOBalances = await prisma.pTOBalance.findMany()
    * ```
    */
  get pTOBalance(): Prisma.PTOBalanceDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.13.0
   * Query Engine version: 361e86d0ea4987e9f53a565309b3eed797a6bcbd
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Role: 'Role',
    Project: 'Project',
    Task: 'Task',
    Document: 'Document',
    DocumentRevision: 'DocumentRevision',
    Product: 'Product',
    Sale: 'Sale',
    BankAccount: 'BankAccount',
    TransactionCategory: 'TransactionCategory',
    Transaction: 'Transaction',
    BankBalance: 'BankBalance',
    User: 'User',
    MagicToken: 'MagicToken',
    AuditTrail: 'AuditTrail',
    NotificationTemplate: 'NotificationTemplate',
    NotificationRule: 'NotificationRule',
    Notification: 'Notification',
    Payroll: 'Payroll',
    PayrollEntry: 'PayrollEntry',
    SalaryAdjustment: 'SalaryAdjustment',
    EmployeeExpense: 'EmployeeExpense',
    PTORequest: 'PTORequest',
    PTOBalance: 'PTOBalance'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "role" | "project" | "task" | "document" | "documentRevision" | "product" | "sale" | "bankAccount" | "transactionCategory" | "transaction" | "bankBalance" | "user" | "magicToken" | "auditTrail" | "notificationTemplate" | "notificationRule" | "notification" | "payroll" | "payrollEntry" | "salaryAdjustment" | "employeeExpense" | "pTORequest" | "pTOBalance"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Role: {
        payload: Prisma.$RolePayload<ExtArgs>
        fields: Prisma.RoleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findFirst: {
            args: Prisma.RoleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          findMany: {
            args: Prisma.RoleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          create: {
            args: Prisma.RoleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          createMany: {
            args: Prisma.RoleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          delete: {
            args: Prisma.RoleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          update: {
            args: Prisma.RoleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          deleteMany: {
            args: Prisma.RoleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>[]
          }
          upsert: {
            args: Prisma.RoleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolePayload>
          }
          aggregate: {
            args: Prisma.RoleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole>
          }
          groupBy: {
            args: Prisma.RoleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoleCountArgs<ExtArgs>
            result: $Utils.Optional<RoleCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      Task: {
        payload: Prisma.$TaskPayload<ExtArgs>
        fields: Prisma.TaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findFirst: {
            args: Prisma.TaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          findMany: {
            args: Prisma.TaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          create: {
            args: Prisma.TaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          createMany: {
            args: Prisma.TaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          delete: {
            args: Prisma.TaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          update: {
            args: Prisma.TaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          deleteMany: {
            args: Prisma.TaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>[]
          }
          upsert: {
            args: Prisma.TaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TaskPayload>
          }
          aggregate: {
            args: Prisma.TaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTask>
          }
          groupBy: {
            args: Prisma.TaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<TaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.TaskCountArgs<ExtArgs>
            result: $Utils.Optional<TaskCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      DocumentRevision: {
        payload: Prisma.$DocumentRevisionPayload<ExtArgs>
        fields: Prisma.DocumentRevisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentRevisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentRevisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
          }
          findFirst: {
            args: Prisma.DocumentRevisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentRevisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
          }
          findMany: {
            args: Prisma.DocumentRevisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>[]
          }
          create: {
            args: Prisma.DocumentRevisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
          }
          createMany: {
            args: Prisma.DocumentRevisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentRevisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>[]
          }
          delete: {
            args: Prisma.DocumentRevisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
          }
          update: {
            args: Prisma.DocumentRevisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
          }
          deleteMany: {
            args: Prisma.DocumentRevisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentRevisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentRevisionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>[]
          }
          upsert: {
            args: Prisma.DocumentRevisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentRevisionPayload>
          }
          aggregate: {
            args: Prisma.DocumentRevisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentRevision>
          }
          groupBy: {
            args: Prisma.DocumentRevisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentRevisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentRevisionCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentRevisionCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      Sale: {
        payload: Prisma.$SalePayload<ExtArgs>
        fields: Prisma.SaleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SaleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SaleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findFirst: {
            args: Prisma.SaleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SaleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          findMany: {
            args: Prisma.SaleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          create: {
            args: Prisma.SaleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          createMany: {
            args: Prisma.SaleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SaleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          delete: {
            args: Prisma.SaleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          update: {
            args: Prisma.SaleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          deleteMany: {
            args: Prisma.SaleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SaleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SaleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>[]
          }
          upsert: {
            args: Prisma.SaleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalePayload>
          }
          aggregate: {
            args: Prisma.SaleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSale>
          }
          groupBy: {
            args: Prisma.SaleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SaleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SaleCountArgs<ExtArgs>
            result: $Utils.Optional<SaleCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      TransactionCategory: {
        payload: Prisma.$TransactionCategoryPayload<ExtArgs>
        fields: Prisma.TransactionCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
          }
          findFirst: {
            args: Prisma.TransactionCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
          }
          findMany: {
            args: Prisma.TransactionCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>[]
          }
          create: {
            args: Prisma.TransactionCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
          }
          createMany: {
            args: Prisma.TransactionCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCategoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>[]
          }
          delete: {
            args: Prisma.TransactionCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
          }
          update: {
            args: Prisma.TransactionCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
          }
          deleteMany: {
            args: Prisma.TransactionCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionCategoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>[]
          }
          upsert: {
            args: Prisma.TransactionCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionCategoryPayload>
          }
          aggregate: {
            args: Prisma.TransactionCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionCategory>
          }
          groupBy: {
            args: Prisma.TransactionCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCategoryCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      BankBalance: {
        payload: Prisma.$BankBalancePayload<ExtArgs>
        fields: Prisma.BankBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload>
          }
          findFirst: {
            args: Prisma.BankBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload>
          }
          findMany: {
            args: Prisma.BankBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload>[]
          }
          create: {
            args: Prisma.BankBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload>
          }
          createMany: {
            args: Prisma.BankBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload>[]
          }
          delete: {
            args: Prisma.BankBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload>
          }
          update: {
            args: Prisma.BankBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload>
          }
          deleteMany: {
            args: Prisma.BankBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankBalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload>[]
          }
          upsert: {
            args: Prisma.BankBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankBalancePayload>
          }
          aggregate: {
            args: Prisma.BankBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankBalance>
          }
          groupBy: {
            args: Prisma.BankBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<BankBalanceCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      MagicToken: {
        payload: Prisma.$MagicTokenPayload<ExtArgs>
        fields: Prisma.MagicTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MagicTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MagicTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload>
          }
          findFirst: {
            args: Prisma.MagicTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MagicTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload>
          }
          findMany: {
            args: Prisma.MagicTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload>[]
          }
          create: {
            args: Prisma.MagicTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload>
          }
          createMany: {
            args: Prisma.MagicTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MagicTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload>[]
          }
          delete: {
            args: Prisma.MagicTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload>
          }
          update: {
            args: Prisma.MagicTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload>
          }
          deleteMany: {
            args: Prisma.MagicTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MagicTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MagicTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload>[]
          }
          upsert: {
            args: Prisma.MagicTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MagicTokenPayload>
          }
          aggregate: {
            args: Prisma.MagicTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMagicToken>
          }
          groupBy: {
            args: Prisma.MagicTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<MagicTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.MagicTokenCountArgs<ExtArgs>
            result: $Utils.Optional<MagicTokenCountAggregateOutputType> | number
          }
        }
      }
      AuditTrail: {
        payload: Prisma.$AuditTrailPayload<ExtArgs>
        fields: Prisma.AuditTrailFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditTrailFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditTrailFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          findFirst: {
            args: Prisma.AuditTrailFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditTrailFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          findMany: {
            args: Prisma.AuditTrailFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>[]
          }
          create: {
            args: Prisma.AuditTrailCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          createMany: {
            args: Prisma.AuditTrailCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditTrailCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>[]
          }
          delete: {
            args: Prisma.AuditTrailDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          update: {
            args: Prisma.AuditTrailUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          deleteMany: {
            args: Prisma.AuditTrailDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditTrailUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditTrailUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>[]
          }
          upsert: {
            args: Prisma.AuditTrailUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditTrailPayload>
          }
          aggregate: {
            args: Prisma.AuditTrailAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditTrail>
          }
          groupBy: {
            args: Prisma.AuditTrailGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditTrailGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditTrailCountArgs<ExtArgs>
            result: $Utils.Optional<AuditTrailCountAggregateOutputType> | number
          }
        }
      }
      NotificationTemplate: {
        payload: Prisma.$NotificationTemplatePayload<ExtArgs>
        fields: Prisma.NotificationTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          findFirst: {
            args: Prisma.NotificationTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          findMany: {
            args: Prisma.NotificationTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          create: {
            args: Prisma.NotificationTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          createMany: {
            args: Prisma.NotificationTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          delete: {
            args: Prisma.NotificationTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          update: {
            args: Prisma.NotificationTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          deleteMany: {
            args: Prisma.NotificationTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>[]
          }
          upsert: {
            args: Prisma.NotificationTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationTemplatePayload>
          }
          aggregate: {
            args: Prisma.NotificationTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationTemplate>
          }
          groupBy: {
            args: Prisma.NotificationTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationTemplateCountAggregateOutputType> | number
          }
        }
      }
      NotificationRule: {
        payload: Prisma.$NotificationRulePayload<ExtArgs>
        fields: Prisma.NotificationRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          findFirst: {
            args: Prisma.NotificationRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          findMany: {
            args: Prisma.NotificationRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>[]
          }
          create: {
            args: Prisma.NotificationRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          createMany: {
            args: Prisma.NotificationRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>[]
          }
          delete: {
            args: Prisma.NotificationRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          update: {
            args: Prisma.NotificationRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          deleteMany: {
            args: Prisma.NotificationRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>[]
          }
          upsert: {
            args: Prisma.NotificationRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRulePayload>
          }
          aggregate: {
            args: Prisma.NotificationRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationRule>
          }
          groupBy: {
            args: Prisma.NotificationRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationRuleCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationRuleCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Payroll: {
        payload: Prisma.$PayrollPayload<ExtArgs>
        fields: Prisma.PayrollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findFirst: {
            args: Prisma.PayrollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findMany: {
            args: Prisma.PayrollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          create: {
            args: Prisma.PayrollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          createMany: {
            args: Prisma.PayrollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          delete: {
            args: Prisma.PayrollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          update: {
            args: Prisma.PayrollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          deleteMany: {
            args: Prisma.PayrollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          upsert: {
            args: Prisma.PayrollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          aggregate: {
            args: Prisma.PayrollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayroll>
          }
          groupBy: {
            args: Prisma.PayrollGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollCountAggregateOutputType> | number
          }
        }
      }
      PayrollEntry: {
        payload: Prisma.$PayrollEntryPayload<ExtArgs>
        fields: Prisma.PayrollEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          findFirst: {
            args: Prisma.PayrollEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          findMany: {
            args: Prisma.PayrollEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>[]
          }
          create: {
            args: Prisma.PayrollEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          createMany: {
            args: Prisma.PayrollEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>[]
          }
          delete: {
            args: Prisma.PayrollEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          update: {
            args: Prisma.PayrollEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          deleteMany: {
            args: Prisma.PayrollEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollEntryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>[]
          }
          upsert: {
            args: Prisma.PayrollEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollEntryPayload>
          }
          aggregate: {
            args: Prisma.PayrollEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollEntry>
          }
          groupBy: {
            args: Prisma.PayrollEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollEntryCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollEntryCountAggregateOutputType> | number
          }
        }
      }
      SalaryAdjustment: {
        payload: Prisma.$SalaryAdjustmentPayload<ExtArgs>
        fields: Prisma.SalaryAdjustmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SalaryAdjustmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SalaryAdjustmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload>
          }
          findFirst: {
            args: Prisma.SalaryAdjustmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SalaryAdjustmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload>
          }
          findMany: {
            args: Prisma.SalaryAdjustmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload>[]
          }
          create: {
            args: Prisma.SalaryAdjustmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload>
          }
          createMany: {
            args: Prisma.SalaryAdjustmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SalaryAdjustmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload>[]
          }
          delete: {
            args: Prisma.SalaryAdjustmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload>
          }
          update: {
            args: Prisma.SalaryAdjustmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload>
          }
          deleteMany: {
            args: Prisma.SalaryAdjustmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SalaryAdjustmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SalaryAdjustmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload>[]
          }
          upsert: {
            args: Prisma.SalaryAdjustmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SalaryAdjustmentPayload>
          }
          aggregate: {
            args: Prisma.SalaryAdjustmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSalaryAdjustment>
          }
          groupBy: {
            args: Prisma.SalaryAdjustmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<SalaryAdjustmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.SalaryAdjustmentCountArgs<ExtArgs>
            result: $Utils.Optional<SalaryAdjustmentCountAggregateOutputType> | number
          }
        }
      }
      EmployeeExpense: {
        payload: Prisma.$EmployeeExpensePayload<ExtArgs>
        fields: Prisma.EmployeeExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload>
          }
          findFirst: {
            args: Prisma.EmployeeExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload>
          }
          findMany: {
            args: Prisma.EmployeeExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload>[]
          }
          create: {
            args: Prisma.EmployeeExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload>
          }
          createMany: {
            args: Prisma.EmployeeExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload>[]
          }
          delete: {
            args: Prisma.EmployeeExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload>
          }
          update: {
            args: Prisma.EmployeeExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeExpenseUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeExpensePayload>
          }
          aggregate: {
            args: Prisma.EmployeeExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeExpense>
          }
          groupBy: {
            args: Prisma.EmployeeExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeExpenseCountAggregateOutputType> | number
          }
        }
      }
      PTORequest: {
        payload: Prisma.$PTORequestPayload<ExtArgs>
        fields: Prisma.PTORequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PTORequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PTORequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload>
          }
          findFirst: {
            args: Prisma.PTORequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PTORequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload>
          }
          findMany: {
            args: Prisma.PTORequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload>[]
          }
          create: {
            args: Prisma.PTORequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload>
          }
          createMany: {
            args: Prisma.PTORequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PTORequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload>[]
          }
          delete: {
            args: Prisma.PTORequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload>
          }
          update: {
            args: Prisma.PTORequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload>
          }
          deleteMany: {
            args: Prisma.PTORequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PTORequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PTORequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload>[]
          }
          upsert: {
            args: Prisma.PTORequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTORequestPayload>
          }
          aggregate: {
            args: Prisma.PTORequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePTORequest>
          }
          groupBy: {
            args: Prisma.PTORequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PTORequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PTORequestCountArgs<ExtArgs>
            result: $Utils.Optional<PTORequestCountAggregateOutputType> | number
          }
        }
      }
      PTOBalance: {
        payload: Prisma.$PTOBalancePayload<ExtArgs>
        fields: Prisma.PTOBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PTOBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PTOBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload>
          }
          findFirst: {
            args: Prisma.PTOBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PTOBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload>
          }
          findMany: {
            args: Prisma.PTOBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload>[]
          }
          create: {
            args: Prisma.PTOBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload>
          }
          createMany: {
            args: Prisma.PTOBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PTOBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload>[]
          }
          delete: {
            args: Prisma.PTOBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload>
          }
          update: {
            args: Prisma.PTOBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload>
          }
          deleteMany: {
            args: Prisma.PTOBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PTOBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PTOBalanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload>[]
          }
          upsert: {
            args: Prisma.PTOBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PTOBalancePayload>
          }
          aggregate: {
            args: Prisma.PTOBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePTOBalance>
          }
          groupBy: {
            args: Prisma.PTOBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<PTOBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.PTOBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<PTOBalanceCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    role?: RoleOmit
    project?: ProjectOmit
    task?: TaskOmit
    document?: DocumentOmit
    documentRevision?: DocumentRevisionOmit
    product?: ProductOmit
    sale?: SaleOmit
    bankAccount?: BankAccountOmit
    transactionCategory?: TransactionCategoryOmit
    transaction?: TransactionOmit
    bankBalance?: BankBalanceOmit
    user?: UserOmit
    magicToken?: MagicTokenOmit
    auditTrail?: AuditTrailOmit
    notificationTemplate?: NotificationTemplateOmit
    notificationRule?: NotificationRuleOmit
    notification?: NotificationOmit
    payroll?: PayrollOmit
    payrollEntry?: PayrollEntryOmit
    salaryAdjustment?: SalaryAdjustmentOmit
    employeeExpense?: EmployeeExpenseOmit
    pTORequest?: PTORequestOmit
    pTOBalance?: PTOBalanceOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type RoleCountOutputType
   */

  export type RoleCountOutputType = {
    users: number
  }

  export type RoleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | RoleCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoleCountOutputType
     */
    select?: RoleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoleCountOutputType without action
   */
  export type RoleCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    tasks: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ProjectCountOutputTypeCountTasksArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    children: number
    revisions: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | DocumentCountOutputTypeCountChildrenArgs
    revisions?: boolean | DocumentCountOutputTypeCountRevisionsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentRevisionWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    sales: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | ProductCountOutputTypeCountSalesArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }


  /**
   * Count Type BankAccountCountOutputType
   */

  export type BankAccountCountOutputType = {
    transactions: number
    balanceHistory: number
  }

  export type BankAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | BankAccountCountOutputTypeCountTransactionsArgs
    balanceHistory?: boolean | BankAccountCountOutputTypeCountBalanceHistoryArgs
  }

  // Custom InputTypes
  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccountCountOutputType
     */
    select?: BankAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeCountBalanceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankBalanceWhereInput
  }


  /**
   * Count Type TransactionCategoryCountOutputType
   */

  export type TransactionCategoryCountOutputType = {
    transactions: number
  }

  export type TransactionCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | TransactionCategoryCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * TransactionCategoryCountOutputType without action
   */
  export type TransactionCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategoryCountOutputType
     */
    select?: TransactionCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TransactionCategoryCountOutputType without action
   */
  export type TransactionCategoryCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    tasks: number
    documents: number
    documentRevisions: number
    sales: number
    transactions: number
    auditTrails: number
    notificationTemplatesCreated: number
    notificationRulesCreated: number
    notifications: number
    magicTokens: number
    payrollsApproved: number
    payrollsProcessed: number
    payrollEntries: number
    salaryAdjustments: number
    salaryAdjustmentsApproved: number
    employeeExpenses: number
    expenseReviews: number
    ptoRequests: number
    ptoApprovals: number
    ptoBalances: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | UserCountOutputTypeCountTasksArgs
    documents?: boolean | UserCountOutputTypeCountDocumentsArgs
    documentRevisions?: boolean | UserCountOutputTypeCountDocumentRevisionsArgs
    sales?: boolean | UserCountOutputTypeCountSalesArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    auditTrails?: boolean | UserCountOutputTypeCountAuditTrailsArgs
    notificationTemplatesCreated?: boolean | UserCountOutputTypeCountNotificationTemplatesCreatedArgs
    notificationRulesCreated?: boolean | UserCountOutputTypeCountNotificationRulesCreatedArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    magicTokens?: boolean | UserCountOutputTypeCountMagicTokensArgs
    payrollsApproved?: boolean | UserCountOutputTypeCountPayrollsApprovedArgs
    payrollsProcessed?: boolean | UserCountOutputTypeCountPayrollsProcessedArgs
    payrollEntries?: boolean | UserCountOutputTypeCountPayrollEntriesArgs
    salaryAdjustments?: boolean | UserCountOutputTypeCountSalaryAdjustmentsArgs
    salaryAdjustmentsApproved?: boolean | UserCountOutputTypeCountSalaryAdjustmentsApprovedArgs
    employeeExpenses?: boolean | UserCountOutputTypeCountEmployeeExpensesArgs
    expenseReviews?: boolean | UserCountOutputTypeCountExpenseReviewsArgs
    ptoRequests?: boolean | UserCountOutputTypeCountPtoRequestsArgs
    ptoApprovals?: boolean | UserCountOutputTypeCountPtoApprovalsArgs
    ptoBalances?: boolean | UserCountOutputTypeCountPtoBalancesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDocumentRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentRevisionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditTrailWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationTemplatesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTemplateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationRulesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMagicTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicTokenWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPayrollsApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPayrollsProcessedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPayrollEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalaryAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryAdjustmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSalaryAdjustmentsApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryAdjustmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmployeeExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeExpenseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountExpenseReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeExpenseWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPtoRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PTORequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPtoApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PTORequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPtoBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PTOBalanceWhereInput
  }


  /**
   * Count Type NotificationTemplateCountOutputType
   */

  export type NotificationTemplateCountOutputType = {
    rules: number
    notifications: number
  }

  export type NotificationTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rules?: boolean | NotificationTemplateCountOutputTypeCountRulesArgs
    notifications?: boolean | NotificationTemplateCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * NotificationTemplateCountOutputType without action
   */
  export type NotificationTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplateCountOutputType
     */
    select?: NotificationTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationTemplateCountOutputType without action
   */
  export type NotificationTemplateCountOutputTypeCountRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRuleWhereInput
  }

  /**
   * NotificationTemplateCountOutputType without action
   */
  export type NotificationTemplateCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type NotificationRuleCountOutputType
   */

  export type NotificationRuleCountOutputType = {
    notifications: number
  }

  export type NotificationRuleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notifications?: boolean | NotificationRuleCountOutputTypeCountNotificationsArgs
  }

  // Custom InputTypes
  /**
   * NotificationRuleCountOutputType without action
   */
  export type NotificationRuleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRuleCountOutputType
     */
    select?: NotificationRuleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationRuleCountOutputType without action
   */
  export type NotificationRuleCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }


  /**
   * Count Type PayrollCountOutputType
   */

  export type PayrollCountOutputType = {
    payrollEntries: number
    transactions: number
  }

  export type PayrollCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payrollEntries?: boolean | PayrollCountOutputTypeCountPayrollEntriesArgs
    transactions?: boolean | PayrollCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * PayrollCountOutputType without action
   */
  export type PayrollCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollCountOutputType
     */
    select?: PayrollCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayrollCountOutputType without action
   */
  export type PayrollCountOutputTypeCountPayrollEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollEntryWhereInput
  }

  /**
   * PayrollCountOutputType without action
   */
  export type PayrollCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Role
   */

  export type AggregateRole = {
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  export type RoleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    permissions: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    permissions?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Role to aggregate.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RoleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoleMaxAggregateInputType
  }

  export type GetRoleAggregateType<T extends RoleAggregateArgs> = {
        [P in keyof T & keyof AggregateRole]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole[P]>
      : GetScalarType<T[P], AggregateRole[P]>
  }




  export type RoleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoleWhereInput
    orderBy?: RoleOrderByWithAggregationInput | RoleOrderByWithAggregationInput[]
    by: RoleScalarFieldEnum[] | RoleScalarFieldEnum
    having?: RoleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoleCountAggregateInputType | true
    _min?: RoleMinAggregateInputType
    _max?: RoleMaxAggregateInputType
  }

  export type RoleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    permissions: string[]
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoleCountAggregateOutputType | null
    _min: RoleMinAggregateOutputType | null
    _max: RoleMaxAggregateOutputType | null
  }

  type GetRoleGroupByPayload<T extends RoleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoleGroupByOutputType[P]>
            : GetScalarType<T[P], RoleGroupByOutputType[P]>
        }
      >
    >


  export type RoleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role"]>

  export type RoleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["role"]>

  export type RoleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    permissions?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "permissions" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["role"]>
  export type RoleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Role$usersArgs<ExtArgs>
    _count?: boolean | RoleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RoleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Role"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      permissions: string[]
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["role"]>
    composites: {}
  }

  type RoleGetPayload<S extends boolean | null | undefined | RoleDefaultArgs> = $Result.GetResult<Prisma.$RolePayload, S>

  type RoleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoleCountAggregateInputType | true
    }

  export interface RoleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Role'], meta: { name: 'Role' } }
    /**
     * Find zero or one Role that matches the filter.
     * @param {RoleFindUniqueArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoleFindUniqueArgs>(args: SelectSubset<T, RoleFindUniqueArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoleFindUniqueOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoleFindFirstArgs>(args?: SelectSubset<T, RoleFindFirstArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindFirstOrThrowArgs} args - Arguments to find a Role
     * @example
     * // Get one Role
     * const role = await prisma.role.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.role.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.role.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roleWithIdOnly = await prisma.role.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoleFindManyArgs>(args?: SelectSubset<T, RoleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role.
     * @param {RoleCreateArgs} args - Arguments to create a Role.
     * @example
     * // Create one Role
     * const Role = await prisma.role.create({
     *   data: {
     *     // ... data to create a Role
     *   }
     * })
     * 
     */
    create<T extends RoleCreateArgs>(args: SelectSubset<T, RoleCreateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RoleCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoleCreateManyArgs>(args?: SelectSubset<T, RoleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RoleCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const role = await prisma.role.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Role.
     * @param {RoleDeleteArgs} args - Arguments to delete one Role.
     * @example
     * // Delete one Role
     * const Role = await prisma.role.delete({
     *   where: {
     *     // ... filter to delete one Role
     *   }
     * })
     * 
     */
    delete<T extends RoleDeleteArgs>(args: SelectSubset<T, RoleDeleteArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role.
     * @param {RoleUpdateArgs} args - Arguments to update one Role.
     * @example
     * // Update one Role
     * const role = await prisma.role.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoleUpdateArgs>(args: SelectSubset<T, RoleUpdateArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RoleDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.role.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoleDeleteManyArgs>(args?: SelectSubset<T, RoleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoleUpdateManyArgs>(args: SelectSubset<T, RoleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RoleUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const role = await prisma.role.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const roleWithIdOnly = await prisma.role.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Role.
     * @param {RoleUpsertArgs} args - Arguments to update or create a Role.
     * @example
     * // Update or create a Role
     * const role = await prisma.role.upsert({
     *   create: {
     *     // ... data to create a Role
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role we want to update
     *   }
     * })
     */
    upsert<T extends RoleUpsertArgs>(args: SelectSubset<T, RoleUpsertArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.role.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RoleCountArgs>(
      args?: Subset<T, RoleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoleAggregateArgs>(args: Subset<T, RoleAggregateArgs>): Prisma.PrismaPromise<GetRoleAggregateType<T>>

    /**
     * Group by Role.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoleGroupByArgs['orderBy'] }
        : { orderBy?: RoleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Role model
   */
  readonly fields: RoleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Role.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Role$usersArgs<ExtArgs> = {}>(args?: Subset<T, Role$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Role model
   */
  interface RoleFieldRefs {
    readonly id: FieldRef<"Role", 'String'>
    readonly name: FieldRef<"Role", 'String'>
    readonly description: FieldRef<"Role", 'String'>
    readonly permissions: FieldRef<"Role", 'String[]'>
    readonly tenantId: FieldRef<"Role", 'String'>
    readonly isDeleted: FieldRef<"Role", 'Boolean'>
    readonly deletedAt: FieldRef<"Role", 'DateTime'>
    readonly deletedBy: FieldRef<"Role", 'String'>
    readonly createdBy: FieldRef<"Role", 'String'>
    readonly createdAt: FieldRef<"Role", 'DateTime'>
    readonly updatedAt: FieldRef<"Role", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Role findUnique
   */
  export type RoleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findUniqueOrThrow
   */
  export type RoleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role findFirst
   */
  export type RoleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findFirstOrThrow
   */
  export type RoleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Role to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role findMany
   */
  export type RoleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RoleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RoleOrderByWithRelationInput | RoleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RoleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RoleScalarFieldEnum | RoleScalarFieldEnum[]
  }

  /**
   * Role create
   */
  export type RoleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to create a Role.
     */
    data: XOR<RoleCreateInput, RoleUncheckedCreateInput>
  }

  /**
   * Role createMany
   */
  export type RoleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role createManyAndReturn
   */
  export type RoleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RoleCreateManyInput | RoleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Role update
   */
  export type RoleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The data needed to update a Role.
     */
    data: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
    /**
     * Choose, which Role to update.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role updateMany
   */
  export type RoleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role updateManyAndReturn
   */
  export type RoleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RoleUpdateManyMutationInput, RoleUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Role upsert
   */
  export type RoleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * The filter to search for the Role to update in case it exists.
     */
    where: RoleWhereUniqueInput
    /**
     * In case the Role found by the `where` argument doesn't exist, create a new Role with this data.
     */
    create: XOR<RoleCreateInput, RoleUncheckedCreateInput>
    /**
     * In case the Role was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoleUpdateInput, RoleUncheckedUpdateInput>
  }

  /**
   * Role delete
   */
  export type RoleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
    /**
     * Filter which Role to delete.
     */
    where: RoleWhereUniqueInput
  }

  /**
   * Role deleteMany
   */
  export type RoleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RoleWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Role.users
   */
  export type Role$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Role without action
   */
  export type RoleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Role
     */
    select?: RoleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Role
     */
    omit?: RoleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoleInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    name: number
    description: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProjectMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    name: string
    description: string | null
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProjectCountAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | Project$tasksArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      tasks: Prisma.$TaskPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tasks<T extends Project$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Project$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly name: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly tenantId: FieldRef<"Project", 'String'>
    readonly isDeleted: FieldRef<"Project", 'Boolean'>
    readonly deletedAt: FieldRef<"Project", 'DateTime'>
    readonly deletedBy: FieldRef<"Project", 'String'>
    readonly createdBy: FieldRef<"Project", 'String'>
    readonly createdAt: FieldRef<"Project", 'DateTime'>
    readonly updatedAt: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.tasks
   */
  export type Project$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model Task
   */

  export type AggregateTask = {
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  export type TaskMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    projectId: string | null
    assigneeId: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    status: $Enums.TaskStatus | null
    projectId: string | null
    assigneeId: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TaskCountAggregateOutputType = {
    id: number
    title: number
    description: number
    status: number
    projectId: number
    assigneeId: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TaskMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    projectId?: true
    assigneeId?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    projectId?: true
    assigneeId?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TaskCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    status?: true
    projectId?: true
    assigneeId?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Task to aggregate.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tasks
    **/
    _count?: true | TaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TaskMaxAggregateInputType
  }

  export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
        [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTask[P]>
      : GetScalarType<T[P], AggregateTask[P]>
  }




  export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[]
    by: TaskScalarFieldEnum[] | TaskScalarFieldEnum
    having?: TaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TaskCountAggregateInputType | true
    _min?: TaskMinAggregateInputType
    _max?: TaskMaxAggregateInputType
  }

  export type TaskGroupByOutputType = {
    id: string
    title: string
    description: string | null
    status: $Enums.TaskStatus
    projectId: string
    assigneeId: string | null
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: TaskCountAggregateOutputType | null
    _min: TaskMinAggregateOutputType | null
    _max: TaskMaxAggregateOutputType | null
  }

  type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TaskGroupByOutputType[P]>
            : GetScalarType<T[P], TaskGroupByOutputType[P]>
        }
      >
    >


  export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    projectId?: boolean
    assigneeId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    projectId?: boolean
    assigneeId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    projectId?: boolean
    assigneeId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["task"]>

  export type TaskSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    projectId?: boolean
    assigneeId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "status" | "projectId" | "assigneeId" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["task"]>
  export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
  }
  export type TaskIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
  }
  export type TaskIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    assignee?: boolean | Task$assigneeArgs<ExtArgs>
  }

  export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Task"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      assignee: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      status: $Enums.TaskStatus
      projectId: string
      assigneeId: string | null
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["task"]>
    composites: {}
  }

  type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<Prisma.$TaskPayload, S>

  type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TaskFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskCountAggregateInputType | true
    }

  export interface TaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task'], meta: { name: 'Task' } }
    /**
     * Find zero or one Task that matches the filter.
     * @param {TaskFindUniqueArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TaskFindUniqueArgs>(args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Task that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TaskFindFirstArgs>(args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Task that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
     * @example
     * // Get one Task
     * const task = await prisma.task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tasks
     * const tasks = await prisma.task.findMany()
     * 
     * // Get first 10 Tasks
     * const tasks = await prisma.task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TaskFindManyArgs>(args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Task.
     * @param {TaskCreateArgs} args - Arguments to create a Task.
     * @example
     * // Create one Task
     * const Task = await prisma.task.create({
     *   data: {
     *     // ... data to create a Task
     *   }
     * })
     * 
     */
    create<T extends TaskCreateArgs>(args: SelectSubset<T, TaskCreateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tasks.
     * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TaskCreateManyArgs>(args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tasks and returns the data saved in the database.
     * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
     * @example
     * // Create many Tasks
     * const task = await prisma.task.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Task.
     * @param {TaskDeleteArgs} args - Arguments to delete one Task.
     * @example
     * // Delete one Task
     * const Task = await prisma.task.delete({
     *   where: {
     *     // ... filter to delete one Task
     *   }
     * })
     * 
     */
    delete<T extends TaskDeleteArgs>(args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Task.
     * @param {TaskUpdateArgs} args - Arguments to update one Task.
     * @example
     * // Update one Task
     * const task = await prisma.task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TaskUpdateArgs>(args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tasks.
     * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
     * @example
     * // Delete a few Tasks
     * const { count } = await prisma.task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TaskDeleteManyArgs>(args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TaskUpdateManyArgs>(args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tasks and returns the data updated in the database.
     * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
     * @example
     * // Update many Tasks
     * const task = await prisma.task.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tasks and only return the `id`
     * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Task.
     * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
     * @example
     * // Update or create a Task
     * const task = await prisma.task.upsert({
     *   create: {
     *     // ... data to create a Task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Task we want to update
     *   }
     * })
     */
    upsert<T extends TaskUpsertArgs>(args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>): Prisma__TaskClient<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
     * @example
     * // Count the number of Tasks
     * const count = await prisma.task.count({
     *   where: {
     *     // ... the filter for the Tasks we want to count
     *   }
     * })
    **/
    count<T extends TaskCountArgs>(
      args?: Subset<T, TaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TaskAggregateArgs>(args: Subset<T, TaskAggregateArgs>): Prisma.PrismaPromise<GetTaskAggregateType<T>>

    /**
     * Group by Task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TaskGroupByArgs['orderBy'] }
        : { orderBy?: TaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Task model
   */
  readonly fields: TaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignee<T extends Task$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, Task$assigneeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Task model
   */
  interface TaskFieldRefs {
    readonly id: FieldRef<"Task", 'String'>
    readonly title: FieldRef<"Task", 'String'>
    readonly description: FieldRef<"Task", 'String'>
    readonly status: FieldRef<"Task", 'TaskStatus'>
    readonly projectId: FieldRef<"Task", 'String'>
    readonly assigneeId: FieldRef<"Task", 'String'>
    readonly tenantId: FieldRef<"Task", 'String'>
    readonly isDeleted: FieldRef<"Task", 'Boolean'>
    readonly deletedAt: FieldRef<"Task", 'DateTime'>
    readonly deletedBy: FieldRef<"Task", 'String'>
    readonly createdBy: FieldRef<"Task", 'String'>
    readonly createdAt: FieldRef<"Task", 'DateTime'>
    readonly updatedAt: FieldRef<"Task", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Task findUnique
   */
  export type TaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findUniqueOrThrow
   */
  export type TaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task findFirst
   */
  export type TaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findFirstOrThrow
   */
  export type TaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Task to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tasks.
     */
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task findMany
   */
  export type TaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter, which Tasks to fetch.
     */
    where?: TaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tasks to fetch.
     */
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tasks.
     */
    cursor?: TaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tasks.
     */
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * Task create
   */
  export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to create a Task.
     */
    data: XOR<TaskCreateInput, TaskUncheckedCreateInput>
  }

  /**
   * Task createMany
   */
  export type TaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Task createManyAndReturn
   */
  export type TaskCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to create many Tasks.
     */
    data: TaskCreateManyInput | TaskCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task update
   */
  export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The data needed to update a Task.
     */
    data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
    /**
     * Choose, which Task to update.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task updateMany
   */
  export type TaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
  }

  /**
   * Task updateManyAndReturn
   */
  export type TaskUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * The data used to update Tasks.
     */
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>
    /**
     * Filter which Tasks to update
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Task upsert
   */
  export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * The filter to search for the Task to update in case it exists.
     */
    where: TaskWhereUniqueInput
    /**
     * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
     */
    create: XOR<TaskCreateInput, TaskUncheckedCreateInput>
    /**
     * In case the Task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>
  }

  /**
   * Task delete
   */
  export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    /**
     * Filter which Task to delete.
     */
    where: TaskWhereUniqueInput
  }

  /**
   * Task deleteMany
   */
  export type TaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tasks to delete
     */
    where?: TaskWhereInput
    /**
     * Limit how many Tasks to delete.
     */
    limit?: number
  }

  /**
   * Task.assignee
   */
  export type Task$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Task without action
   */
  export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    viewCount: number | null
  }

  export type DocumentSumAggregateOutputType = {
    viewCount: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    slug: string | null
    summary: string | null
    type: $Enums.DocumentType | null
    status: $Enums.DocumentStatus | null
    parentId: string | null
    authorId: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
    viewCount: number | null
    lastViewedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    slug: string | null
    summary: string | null
    type: $Enums.DocumentType | null
    status: $Enums.DocumentStatus | null
    parentId: string | null
    authorId: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    publishedAt: Date | null
    viewCount: number | null
    lastViewedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    title: number
    content: number
    slug: number
    summary: number
    type: number
    status: number
    tags: number
    parentId: number
    authorId: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    publishedAt: number
    viewCount: number
    lastViewedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    viewCount?: true
  }

  export type DocumentSumAggregateInputType = {
    viewCount?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    slug?: true
    summary?: true
    type?: true
    status?: true
    parentId?: true
    authorId?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    viewCount?: true
    lastViewedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    slug?: true
    summary?: true
    type?: true
    status?: true
    parentId?: true
    authorId?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    viewCount?: true
    lastViewedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    slug?: true
    summary?: true
    type?: true
    status?: true
    tags?: true
    parentId?: true
    authorId?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    publishedAt?: true
    viewCount?: true
    lastViewedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    title: string
    content: string
    slug: string
    summary: string | null
    type: $Enums.DocumentType
    status: $Enums.DocumentStatus
    tags: string[]
    parentId: string | null
    authorId: string
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    publishedAt: Date | null
    viewCount: number
    lastViewedAt: Date | null
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    summary?: boolean
    type?: boolean
    status?: boolean
    tags?: boolean
    parentId?: boolean
    authorId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    parent?: boolean | Document$parentArgs<ExtArgs>
    children?: boolean | Document$childrenArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    revisions?: boolean | Document$revisionsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    summary?: boolean
    type?: boolean
    status?: boolean
    tags?: boolean
    parentId?: boolean
    authorId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    parent?: boolean | Document$parentArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    summary?: boolean
    type?: boolean
    status?: boolean
    tags?: boolean
    parentId?: boolean
    authorId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
    parent?: boolean | Document$parentArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    slug?: boolean
    summary?: boolean
    type?: boolean
    status?: boolean
    tags?: boolean
    parentId?: boolean
    authorId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    publishedAt?: boolean
    viewCount?: boolean
    lastViewedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "slug" | "summary" | "type" | "status" | "tags" | "parentId" | "authorId" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt" | "publishedAt" | "viewCount" | "lastViewedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Document$parentArgs<ExtArgs>
    children?: boolean | Document$childrenArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
    revisions?: boolean | Document$revisionsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Document$parentArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | Document$parentArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      parent: Prisma.$DocumentPayload<ExtArgs> | null
      children: Prisma.$DocumentPayload<ExtArgs>[]
      author: Prisma.$UserPayload<ExtArgs>
      revisions: Prisma.$DocumentRevisionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string
      slug: string
      summary: string | null
      type: $Enums.DocumentType
      status: $Enums.DocumentStatus
      tags: string[]
      parentId: string | null
      authorId: string
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
      publishedAt: Date | null
      viewCount: number
      lastViewedAt: Date | null
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends Document$parentArgs<ExtArgs> = {}>(args?: Subset<T, Document$parentArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Document$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Document$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    revisions<T extends Document$revisionsArgs<ExtArgs> = {}>(args?: Subset<T, Document$revisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly title: FieldRef<"Document", 'String'>
    readonly content: FieldRef<"Document", 'String'>
    readonly slug: FieldRef<"Document", 'String'>
    readonly summary: FieldRef<"Document", 'String'>
    readonly type: FieldRef<"Document", 'DocumentType'>
    readonly status: FieldRef<"Document", 'DocumentStatus'>
    readonly tags: FieldRef<"Document", 'String[]'>
    readonly parentId: FieldRef<"Document", 'String'>
    readonly authorId: FieldRef<"Document", 'String'>
    readonly tenantId: FieldRef<"Document", 'String'>
    readonly isDeleted: FieldRef<"Document", 'Boolean'>
    readonly deletedAt: FieldRef<"Document", 'DateTime'>
    readonly deletedBy: FieldRef<"Document", 'String'>
    readonly createdBy: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
    readonly publishedAt: FieldRef<"Document", 'DateTime'>
    readonly viewCount: FieldRef<"Document", 'Int'>
    readonly lastViewedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.parent
   */
  export type Document$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
  }

  /**
   * Document.children
   */
  export type Document$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document.revisions
   */
  export type Document$revisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    where?: DocumentRevisionWhereInput
    orderBy?: DocumentRevisionOrderByWithRelationInput | DocumentRevisionOrderByWithRelationInput[]
    cursor?: DocumentRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentRevisionScalarFieldEnum | DocumentRevisionScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model DocumentRevision
   */

  export type AggregateDocumentRevision = {
    _count: DocumentRevisionCountAggregateOutputType | null
    _avg: DocumentRevisionAvgAggregateOutputType | null
    _sum: DocumentRevisionSumAggregateOutputType | null
    _min: DocumentRevisionMinAggregateOutputType | null
    _max: DocumentRevisionMaxAggregateOutputType | null
  }

  export type DocumentRevisionAvgAggregateOutputType = {
    version: number | null
  }

  export type DocumentRevisionSumAggregateOutputType = {
    version: number | null
  }

  export type DocumentRevisionMinAggregateOutputType = {
    id: string | null
    documentId: string | null
    version: number | null
    title: string | null
    content: string | null
    summary: string | null
    changeLog: string | null
    authorId: string | null
    tenantId: string | null
    createdAt: Date | null
  }

  export type DocumentRevisionMaxAggregateOutputType = {
    id: string | null
    documentId: string | null
    version: number | null
    title: string | null
    content: string | null
    summary: string | null
    changeLog: string | null
    authorId: string | null
    tenantId: string | null
    createdAt: Date | null
  }

  export type DocumentRevisionCountAggregateOutputType = {
    id: number
    documentId: number
    version: number
    title: number
    content: number
    summary: number
    changeLog: number
    authorId: number
    tenantId: number
    createdAt: number
    _all: number
  }


  export type DocumentRevisionAvgAggregateInputType = {
    version?: true
  }

  export type DocumentRevisionSumAggregateInputType = {
    version?: true
  }

  export type DocumentRevisionMinAggregateInputType = {
    id?: true
    documentId?: true
    version?: true
    title?: true
    content?: true
    summary?: true
    changeLog?: true
    authorId?: true
    tenantId?: true
    createdAt?: true
  }

  export type DocumentRevisionMaxAggregateInputType = {
    id?: true
    documentId?: true
    version?: true
    title?: true
    content?: true
    summary?: true
    changeLog?: true
    authorId?: true
    tenantId?: true
    createdAt?: true
  }

  export type DocumentRevisionCountAggregateInputType = {
    id?: true
    documentId?: true
    version?: true
    title?: true
    content?: true
    summary?: true
    changeLog?: true
    authorId?: true
    tenantId?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentRevisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentRevision to aggregate.
     */
    where?: DocumentRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRevisions to fetch.
     */
    orderBy?: DocumentRevisionOrderByWithRelationInput | DocumentRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentRevisions
    **/
    _count?: true | DocumentRevisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentRevisionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentRevisionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentRevisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentRevisionMaxAggregateInputType
  }

  export type GetDocumentRevisionAggregateType<T extends DocumentRevisionAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentRevision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentRevision[P]>
      : GetScalarType<T[P], AggregateDocumentRevision[P]>
  }




  export type DocumentRevisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentRevisionWhereInput
    orderBy?: DocumentRevisionOrderByWithAggregationInput | DocumentRevisionOrderByWithAggregationInput[]
    by: DocumentRevisionScalarFieldEnum[] | DocumentRevisionScalarFieldEnum
    having?: DocumentRevisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentRevisionCountAggregateInputType | true
    _avg?: DocumentRevisionAvgAggregateInputType
    _sum?: DocumentRevisionSumAggregateInputType
    _min?: DocumentRevisionMinAggregateInputType
    _max?: DocumentRevisionMaxAggregateInputType
  }

  export type DocumentRevisionGroupByOutputType = {
    id: string
    documentId: string
    version: number
    title: string
    content: string
    summary: string | null
    changeLog: string | null
    authorId: string
    tenantId: string | null
    createdAt: Date
    _count: DocumentRevisionCountAggregateOutputType | null
    _avg: DocumentRevisionAvgAggregateOutputType | null
    _sum: DocumentRevisionSumAggregateOutputType | null
    _min: DocumentRevisionMinAggregateOutputType | null
    _max: DocumentRevisionMaxAggregateOutputType | null
  }

  type GetDocumentRevisionGroupByPayload<T extends DocumentRevisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentRevisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentRevisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentRevisionGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentRevisionGroupByOutputType[P]>
        }
      >
    >


  export type DocumentRevisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    changeLog?: boolean
    authorId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentRevision"]>

  export type DocumentRevisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    changeLog?: boolean
    authorId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentRevision"]>

  export type DocumentRevisionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    changeLog?: boolean
    authorId?: boolean
    tenantId?: boolean
    createdAt?: boolean
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentRevision"]>

  export type DocumentRevisionSelectScalar = {
    id?: boolean
    documentId?: boolean
    version?: boolean
    title?: boolean
    content?: boolean
    summary?: boolean
    changeLog?: boolean
    authorId?: boolean
    tenantId?: boolean
    createdAt?: boolean
  }

  export type DocumentRevisionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "documentId" | "version" | "title" | "content" | "summary" | "changeLog" | "authorId" | "tenantId" | "createdAt", ExtArgs["result"]["documentRevision"]>
  export type DocumentRevisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentRevisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DocumentRevisionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    document?: boolean | DocumentDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DocumentRevisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentRevision"
    objects: {
      document: Prisma.$DocumentPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentId: string
      version: number
      title: string
      content: string
      summary: string | null
      changeLog: string | null
      authorId: string
      tenantId: string | null
      createdAt: Date
    }, ExtArgs["result"]["documentRevision"]>
    composites: {}
  }

  type DocumentRevisionGetPayload<S extends boolean | null | undefined | DocumentRevisionDefaultArgs> = $Result.GetResult<Prisma.$DocumentRevisionPayload, S>

  type DocumentRevisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentRevisionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentRevisionCountAggregateInputType | true
    }

  export interface DocumentRevisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentRevision'], meta: { name: 'DocumentRevision' } }
    /**
     * Find zero or one DocumentRevision that matches the filter.
     * @param {DocumentRevisionFindUniqueArgs} args - Arguments to find a DocumentRevision
     * @example
     * // Get one DocumentRevision
     * const documentRevision = await prisma.documentRevision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentRevisionFindUniqueArgs>(args: SelectSubset<T, DocumentRevisionFindUniqueArgs<ExtArgs>>): Prisma__DocumentRevisionClient<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentRevision that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentRevisionFindUniqueOrThrowArgs} args - Arguments to find a DocumentRevision
     * @example
     * // Get one DocumentRevision
     * const documentRevision = await prisma.documentRevision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentRevisionFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentRevisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentRevisionClient<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentRevision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRevisionFindFirstArgs} args - Arguments to find a DocumentRevision
     * @example
     * // Get one DocumentRevision
     * const documentRevision = await prisma.documentRevision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentRevisionFindFirstArgs>(args?: SelectSubset<T, DocumentRevisionFindFirstArgs<ExtArgs>>): Prisma__DocumentRevisionClient<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentRevision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRevisionFindFirstOrThrowArgs} args - Arguments to find a DocumentRevision
     * @example
     * // Get one DocumentRevision
     * const documentRevision = await prisma.documentRevision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentRevisionFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentRevisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentRevisionClient<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentRevisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRevisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentRevisions
     * const documentRevisions = await prisma.documentRevision.findMany()
     * 
     * // Get first 10 DocumentRevisions
     * const documentRevisions = await prisma.documentRevision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentRevisionWithIdOnly = await prisma.documentRevision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentRevisionFindManyArgs>(args?: SelectSubset<T, DocumentRevisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentRevision.
     * @param {DocumentRevisionCreateArgs} args - Arguments to create a DocumentRevision.
     * @example
     * // Create one DocumentRevision
     * const DocumentRevision = await prisma.documentRevision.create({
     *   data: {
     *     // ... data to create a DocumentRevision
     *   }
     * })
     * 
     */
    create<T extends DocumentRevisionCreateArgs>(args: SelectSubset<T, DocumentRevisionCreateArgs<ExtArgs>>): Prisma__DocumentRevisionClient<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentRevisions.
     * @param {DocumentRevisionCreateManyArgs} args - Arguments to create many DocumentRevisions.
     * @example
     * // Create many DocumentRevisions
     * const documentRevision = await prisma.documentRevision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentRevisionCreateManyArgs>(args?: SelectSubset<T, DocumentRevisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentRevisions and returns the data saved in the database.
     * @param {DocumentRevisionCreateManyAndReturnArgs} args - Arguments to create many DocumentRevisions.
     * @example
     * // Create many DocumentRevisions
     * const documentRevision = await prisma.documentRevision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentRevisions and only return the `id`
     * const documentRevisionWithIdOnly = await prisma.documentRevision.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentRevisionCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentRevisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentRevision.
     * @param {DocumentRevisionDeleteArgs} args - Arguments to delete one DocumentRevision.
     * @example
     * // Delete one DocumentRevision
     * const DocumentRevision = await prisma.documentRevision.delete({
     *   where: {
     *     // ... filter to delete one DocumentRevision
     *   }
     * })
     * 
     */
    delete<T extends DocumentRevisionDeleteArgs>(args: SelectSubset<T, DocumentRevisionDeleteArgs<ExtArgs>>): Prisma__DocumentRevisionClient<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentRevision.
     * @param {DocumentRevisionUpdateArgs} args - Arguments to update one DocumentRevision.
     * @example
     * // Update one DocumentRevision
     * const documentRevision = await prisma.documentRevision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentRevisionUpdateArgs>(args: SelectSubset<T, DocumentRevisionUpdateArgs<ExtArgs>>): Prisma__DocumentRevisionClient<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentRevisions.
     * @param {DocumentRevisionDeleteManyArgs} args - Arguments to filter DocumentRevisions to delete.
     * @example
     * // Delete a few DocumentRevisions
     * const { count } = await prisma.documentRevision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentRevisionDeleteManyArgs>(args?: SelectSubset<T, DocumentRevisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRevisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentRevisions
     * const documentRevision = await prisma.documentRevision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentRevisionUpdateManyArgs>(args: SelectSubset<T, DocumentRevisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentRevisions and returns the data updated in the database.
     * @param {DocumentRevisionUpdateManyAndReturnArgs} args - Arguments to update many DocumentRevisions.
     * @example
     * // Update many DocumentRevisions
     * const documentRevision = await prisma.documentRevision.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentRevisions and only return the `id`
     * const documentRevisionWithIdOnly = await prisma.documentRevision.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentRevisionUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentRevisionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentRevision.
     * @param {DocumentRevisionUpsertArgs} args - Arguments to update or create a DocumentRevision.
     * @example
     * // Update or create a DocumentRevision
     * const documentRevision = await prisma.documentRevision.upsert({
     *   create: {
     *     // ... data to create a DocumentRevision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentRevision we want to update
     *   }
     * })
     */
    upsert<T extends DocumentRevisionUpsertArgs>(args: SelectSubset<T, DocumentRevisionUpsertArgs<ExtArgs>>): Prisma__DocumentRevisionClient<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentRevisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRevisionCountArgs} args - Arguments to filter DocumentRevisions to count.
     * @example
     * // Count the number of DocumentRevisions
     * const count = await prisma.documentRevision.count({
     *   where: {
     *     // ... the filter for the DocumentRevisions we want to count
     *   }
     * })
    **/
    count<T extends DocumentRevisionCountArgs>(
      args?: Subset<T, DocumentRevisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentRevisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRevisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentRevisionAggregateArgs>(args: Subset<T, DocumentRevisionAggregateArgs>): Prisma.PrismaPromise<GetDocumentRevisionAggregateType<T>>

    /**
     * Group by DocumentRevision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentRevisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentRevisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentRevisionGroupByArgs['orderBy'] }
        : { orderBy?: DocumentRevisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentRevisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentRevisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentRevision model
   */
  readonly fields: DocumentRevisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentRevision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentRevisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentRevision model
   */
  interface DocumentRevisionFieldRefs {
    readonly id: FieldRef<"DocumentRevision", 'String'>
    readonly documentId: FieldRef<"DocumentRevision", 'String'>
    readonly version: FieldRef<"DocumentRevision", 'Int'>
    readonly title: FieldRef<"DocumentRevision", 'String'>
    readonly content: FieldRef<"DocumentRevision", 'String'>
    readonly summary: FieldRef<"DocumentRevision", 'String'>
    readonly changeLog: FieldRef<"DocumentRevision", 'String'>
    readonly authorId: FieldRef<"DocumentRevision", 'String'>
    readonly tenantId: FieldRef<"DocumentRevision", 'String'>
    readonly createdAt: FieldRef<"DocumentRevision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentRevision findUnique
   */
  export type DocumentRevisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRevision to fetch.
     */
    where: DocumentRevisionWhereUniqueInput
  }

  /**
   * DocumentRevision findUniqueOrThrow
   */
  export type DocumentRevisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRevision to fetch.
     */
    where: DocumentRevisionWhereUniqueInput
  }

  /**
   * DocumentRevision findFirst
   */
  export type DocumentRevisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRevision to fetch.
     */
    where?: DocumentRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRevisions to fetch.
     */
    orderBy?: DocumentRevisionOrderByWithRelationInput | DocumentRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentRevisions.
     */
    cursor?: DocumentRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentRevisions.
     */
    distinct?: DocumentRevisionScalarFieldEnum | DocumentRevisionScalarFieldEnum[]
  }

  /**
   * DocumentRevision findFirstOrThrow
   */
  export type DocumentRevisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRevision to fetch.
     */
    where?: DocumentRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRevisions to fetch.
     */
    orderBy?: DocumentRevisionOrderByWithRelationInput | DocumentRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentRevisions.
     */
    cursor?: DocumentRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRevisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentRevisions.
     */
    distinct?: DocumentRevisionScalarFieldEnum | DocumentRevisionScalarFieldEnum[]
  }

  /**
   * DocumentRevision findMany
   */
  export type DocumentRevisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    /**
     * Filter, which DocumentRevisions to fetch.
     */
    where?: DocumentRevisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentRevisions to fetch.
     */
    orderBy?: DocumentRevisionOrderByWithRelationInput | DocumentRevisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentRevisions.
     */
    cursor?: DocumentRevisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentRevisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentRevisions.
     */
    skip?: number
    distinct?: DocumentRevisionScalarFieldEnum | DocumentRevisionScalarFieldEnum[]
  }

  /**
   * DocumentRevision create
   */
  export type DocumentRevisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentRevision.
     */
    data: XOR<DocumentRevisionCreateInput, DocumentRevisionUncheckedCreateInput>
  }

  /**
   * DocumentRevision createMany
   */
  export type DocumentRevisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentRevisions.
     */
    data: DocumentRevisionCreateManyInput | DocumentRevisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentRevision createManyAndReturn
   */
  export type DocumentRevisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentRevisions.
     */
    data: DocumentRevisionCreateManyInput | DocumentRevisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentRevision update
   */
  export type DocumentRevisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentRevision.
     */
    data: XOR<DocumentRevisionUpdateInput, DocumentRevisionUncheckedUpdateInput>
    /**
     * Choose, which DocumentRevision to update.
     */
    where: DocumentRevisionWhereUniqueInput
  }

  /**
   * DocumentRevision updateMany
   */
  export type DocumentRevisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentRevisions.
     */
    data: XOR<DocumentRevisionUpdateManyMutationInput, DocumentRevisionUncheckedUpdateManyInput>
    /**
     * Filter which DocumentRevisions to update
     */
    where?: DocumentRevisionWhereInput
    /**
     * Limit how many DocumentRevisions to update.
     */
    limit?: number
  }

  /**
   * DocumentRevision updateManyAndReturn
   */
  export type DocumentRevisionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * The data used to update DocumentRevisions.
     */
    data: XOR<DocumentRevisionUpdateManyMutationInput, DocumentRevisionUncheckedUpdateManyInput>
    /**
     * Filter which DocumentRevisions to update
     */
    where?: DocumentRevisionWhereInput
    /**
     * Limit how many DocumentRevisions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentRevision upsert
   */
  export type DocumentRevisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentRevision to update in case it exists.
     */
    where: DocumentRevisionWhereUniqueInput
    /**
     * In case the DocumentRevision found by the `where` argument doesn't exist, create a new DocumentRevision with this data.
     */
    create: XOR<DocumentRevisionCreateInput, DocumentRevisionUncheckedCreateInput>
    /**
     * In case the DocumentRevision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentRevisionUpdateInput, DocumentRevisionUncheckedUpdateInput>
  }

  /**
   * DocumentRevision delete
   */
  export type DocumentRevisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    /**
     * Filter which DocumentRevision to delete.
     */
    where: DocumentRevisionWhereUniqueInput
  }

  /**
   * DocumentRevision deleteMany
   */
  export type DocumentRevisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentRevisions to delete
     */
    where?: DocumentRevisionWhereInput
    /**
     * Limit how many DocumentRevisions to delete.
     */
    limit?: number
  }

  /**
   * DocumentRevision without action
   */
  export type DocumentRevisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductSumAggregateOutputType = {
    price: number | null
    stock: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    stock: number | null
    category: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    price: number | null
    stock: number | null
    category: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    description: number
    price: number
    stock: number
    category: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductSumAggregateInputType = {
    price?: true
    stock?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    price?: true
    stock?: true
    category?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    name: string
    description: string | null
    price: number
    stock: number
    category: string | null
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    sales?: boolean | Product$salesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    price?: boolean
    stock?: boolean
    category?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "price" | "stock" | "category" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sales?: boolean | Product$salesArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      sales: Prisma.$SalePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      price: number
      stock: number
      category: string | null
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sales<T extends Product$salesArgs<ExtArgs> = {}>(args?: Subset<T, Product$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly name: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly price: FieldRef<"Product", 'Float'>
    readonly stock: FieldRef<"Product", 'Int'>
    readonly category: FieldRef<"Product", 'String'>
    readonly tenantId: FieldRef<"Product", 'String'>
    readonly isDeleted: FieldRef<"Product", 'Boolean'>
    readonly deletedAt: FieldRef<"Product", 'DateTime'>
    readonly deletedBy: FieldRef<"Product", 'String'>
    readonly createdBy: FieldRef<"Product", 'String'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.sales
   */
  export type Product$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model Sale
   */

  export type AggregateSale = {
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  export type SaleAvgAggregateOutputType = {
    quantity: number | null
    total: number | null
  }

  export type SaleSumAggregateOutputType = {
    quantity: number | null
    total: number | null
  }

  export type SaleMinAggregateOutputType = {
    id: string | null
    productId: string | null
    quantity: number | null
    total: number | null
    soldBy: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type SaleMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    quantity: number | null
    total: number | null
    soldBy: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type SaleCountAggregateOutputType = {
    id: number
    productId: number
    quantity: number
    total: number
    soldBy: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type SaleAvgAggregateInputType = {
    quantity?: true
    total?: true
  }

  export type SaleSumAggregateInputType = {
    quantity?: true
    total?: true
  }

  export type SaleMinAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    total?: true
    soldBy?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
  }

  export type SaleMaxAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    total?: true
    soldBy?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
  }

  export type SaleCountAggregateInputType = {
    id?: true
    productId?: true
    quantity?: true
    total?: true
    soldBy?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type SaleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sale to aggregate.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sales
    **/
    _count?: true | SaleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaleMaxAggregateInputType
  }

  export type GetSaleAggregateType<T extends SaleAggregateArgs> = {
        [P in keyof T & keyof AggregateSale]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSale[P]>
      : GetScalarType<T[P], AggregateSale[P]>
  }




  export type SaleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithAggregationInput | SaleOrderByWithAggregationInput[]
    by: SaleScalarFieldEnum[] | SaleScalarFieldEnum
    having?: SaleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaleCountAggregateInputType | true
    _avg?: SaleAvgAggregateInputType
    _sum?: SaleSumAggregateInputType
    _min?: SaleMinAggregateInputType
    _max?: SaleMaxAggregateInputType
  }

  export type SaleGroupByOutputType = {
    id: string
    productId: string
    quantity: number
    total: number
    soldBy: string
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    _count: SaleCountAggregateOutputType | null
    _avg: SaleAvgAggregateOutputType | null
    _sum: SaleSumAggregateOutputType | null
    _min: SaleMinAggregateOutputType | null
    _max: SaleMaxAggregateOutputType | null
  }

  type GetSaleGroupByPayload<T extends SaleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SaleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaleGroupByOutputType[P]>
            : GetScalarType<T[P], SaleGroupByOutputType[P]>
        }
      >
    >


  export type SaleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    total?: boolean
    soldBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    total?: boolean
    soldBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    quantity?: boolean
    total?: boolean
    soldBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sale"]>

  export type SaleSelectScalar = {
    id?: boolean
    productId?: boolean
    quantity?: boolean
    total?: boolean
    soldBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type SaleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "quantity" | "total" | "soldBy" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt", ExtArgs["result"]["sale"]>
  export type SaleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SaleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SaleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    seller?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SalePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sale"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      seller: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      quantity: number
      total: number
      soldBy: string
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["sale"]>
    composites: {}
  }

  type SaleGetPayload<S extends boolean | null | undefined | SaleDefaultArgs> = $Result.GetResult<Prisma.$SalePayload, S>

  type SaleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SaleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SaleCountAggregateInputType | true
    }

  export interface SaleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sale'], meta: { name: 'Sale' } }
    /**
     * Find zero or one Sale that matches the filter.
     * @param {SaleFindUniqueArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SaleFindUniqueArgs>(args: SelectSubset<T, SaleFindUniqueArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sale that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SaleFindUniqueOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SaleFindUniqueOrThrowArgs>(args: SelectSubset<T, SaleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SaleFindFirstArgs>(args?: SelectSubset<T, SaleFindFirstArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sale that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindFirstOrThrowArgs} args - Arguments to find a Sale
     * @example
     * // Get one Sale
     * const sale = await prisma.sale.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SaleFindFirstOrThrowArgs>(args?: SelectSubset<T, SaleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sales that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sales
     * const sales = await prisma.sale.findMany()
     * 
     * // Get first 10 Sales
     * const sales = await prisma.sale.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saleWithIdOnly = await prisma.sale.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SaleFindManyArgs>(args?: SelectSubset<T, SaleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sale.
     * @param {SaleCreateArgs} args - Arguments to create a Sale.
     * @example
     * // Create one Sale
     * const Sale = await prisma.sale.create({
     *   data: {
     *     // ... data to create a Sale
     *   }
     * })
     * 
     */
    create<T extends SaleCreateArgs>(args: SelectSubset<T, SaleCreateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sales.
     * @param {SaleCreateManyArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SaleCreateManyArgs>(args?: SelectSubset<T, SaleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sales and returns the data saved in the database.
     * @param {SaleCreateManyAndReturnArgs} args - Arguments to create many Sales.
     * @example
     * // Create many Sales
     * const sale = await prisma.sale.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SaleCreateManyAndReturnArgs>(args?: SelectSubset<T, SaleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Sale.
     * @param {SaleDeleteArgs} args - Arguments to delete one Sale.
     * @example
     * // Delete one Sale
     * const Sale = await prisma.sale.delete({
     *   where: {
     *     // ... filter to delete one Sale
     *   }
     * })
     * 
     */
    delete<T extends SaleDeleteArgs>(args: SelectSubset<T, SaleDeleteArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sale.
     * @param {SaleUpdateArgs} args - Arguments to update one Sale.
     * @example
     * // Update one Sale
     * const sale = await prisma.sale.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SaleUpdateArgs>(args: SelectSubset<T, SaleUpdateArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sales.
     * @param {SaleDeleteManyArgs} args - Arguments to filter Sales to delete.
     * @example
     * // Delete a few Sales
     * const { count } = await prisma.sale.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SaleDeleteManyArgs>(args?: SelectSubset<T, SaleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SaleUpdateManyArgs>(args: SelectSubset<T, SaleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sales and returns the data updated in the database.
     * @param {SaleUpdateManyAndReturnArgs} args - Arguments to update many Sales.
     * @example
     * // Update many Sales
     * const sale = await prisma.sale.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sales and only return the `id`
     * const saleWithIdOnly = await prisma.sale.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SaleUpdateManyAndReturnArgs>(args: SelectSubset<T, SaleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Sale.
     * @param {SaleUpsertArgs} args - Arguments to update or create a Sale.
     * @example
     * // Update or create a Sale
     * const sale = await prisma.sale.upsert({
     *   create: {
     *     // ... data to create a Sale
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sale we want to update
     *   }
     * })
     */
    upsert<T extends SaleUpsertArgs>(args: SelectSubset<T, SaleUpsertArgs<ExtArgs>>): Prisma__SaleClient<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sales.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleCountArgs} args - Arguments to filter Sales to count.
     * @example
     * // Count the number of Sales
     * const count = await prisma.sale.count({
     *   where: {
     *     // ... the filter for the Sales we want to count
     *   }
     * })
    **/
    count<T extends SaleCountArgs>(
      args?: Subset<T, SaleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaleAggregateArgs>(args: Subset<T, SaleAggregateArgs>): Prisma.PrismaPromise<GetSaleAggregateType<T>>

    /**
     * Group by Sale.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaleGroupByArgs['orderBy'] }
        : { orderBy?: SaleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sale model
   */
  readonly fields: SaleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sale.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SaleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    seller<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sale model
   */
  interface SaleFieldRefs {
    readonly id: FieldRef<"Sale", 'String'>
    readonly productId: FieldRef<"Sale", 'String'>
    readonly quantity: FieldRef<"Sale", 'Int'>
    readonly total: FieldRef<"Sale", 'Float'>
    readonly soldBy: FieldRef<"Sale", 'String'>
    readonly tenantId: FieldRef<"Sale", 'String'>
    readonly isDeleted: FieldRef<"Sale", 'Boolean'>
    readonly deletedAt: FieldRef<"Sale", 'DateTime'>
    readonly deletedBy: FieldRef<"Sale", 'String'>
    readonly createdBy: FieldRef<"Sale", 'String'>
    readonly createdAt: FieldRef<"Sale", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sale findUnique
   */
  export type SaleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findUniqueOrThrow
   */
  export type SaleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale findFirst
   */
  export type SaleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findFirstOrThrow
   */
  export type SaleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sale to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sales.
     */
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale findMany
   */
  export type SaleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter, which Sales to fetch.
     */
    where?: SaleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sales to fetch.
     */
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sales.
     */
    cursor?: SaleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sales from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sales.
     */
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * Sale create
   */
  export type SaleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to create a Sale.
     */
    data: XOR<SaleCreateInput, SaleUncheckedCreateInput>
  }

  /**
   * Sale createMany
   */
  export type SaleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sale createManyAndReturn
   */
  export type SaleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to create many Sales.
     */
    data: SaleCreateManyInput | SaleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale update
   */
  export type SaleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The data needed to update a Sale.
     */
    data: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
    /**
     * Choose, which Sale to update.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale updateMany
   */
  export type SaleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
  }

  /**
   * Sale updateManyAndReturn
   */
  export type SaleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * The data used to update Sales.
     */
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyInput>
    /**
     * Filter which Sales to update
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sale upsert
   */
  export type SaleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * The filter to search for the Sale to update in case it exists.
     */
    where: SaleWhereUniqueInput
    /**
     * In case the Sale found by the `where` argument doesn't exist, create a new Sale with this data.
     */
    create: XOR<SaleCreateInput, SaleUncheckedCreateInput>
    /**
     * In case the Sale was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SaleUpdateInput, SaleUncheckedUpdateInput>
  }

  /**
   * Sale delete
   */
  export type SaleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    /**
     * Filter which Sale to delete.
     */
    where: SaleWhereUniqueInput
  }

  /**
   * Sale deleteMany
   */
  export type SaleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sales to delete
     */
    where?: SaleWhereInput
    /**
     * Limit how many Sales to delete.
     */
    limit?: number
  }

  /**
   * Sale without action
   */
  export type SaleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    currentBalance: number | null
  }

  export type BankAccountSumAggregateOutputType = {
    currentBalance: number | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: string | null
    name: string | null
    accountNumber: string | null
    bankName: string | null
    accountType: string | null
    currency: string | null
    currentBalance: number | null
    isActive: boolean | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    accountNumber: string | null
    bankName: string | null
    accountType: string | null
    currency: string | null
    currentBalance: number | null
    isActive: boolean | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    name: number
    accountNumber: number
    bankName: number
    accountType: number
    currency: number
    currentBalance: number
    isActive: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    currentBalance?: true
  }

  export type BankAccountSumAggregateInputType = {
    currentBalance?: true
  }

  export type BankAccountMinAggregateInputType = {
    id?: true
    name?: true
    accountNumber?: true
    bankName?: true
    accountType?: true
    currency?: true
    currentBalance?: true
    isActive?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    name?: true
    accountNumber?: true
    bankName?: true
    accountType?: true
    currency?: true
    currentBalance?: true
    isActive?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    name?: true
    accountNumber?: true
    bankName?: true
    accountType?: true
    currency?: true
    currentBalance?: true
    isActive?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: string
    name: string
    accountNumber: string | null
    bankName: string | null
    accountType: string | null
    currency: string
    currentBalance: number
    isActive: boolean
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankName?: boolean
    accountType?: boolean
    currency?: boolean
    currentBalance?: boolean
    isActive?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | BankAccount$transactionsArgs<ExtArgs>
    balanceHistory?: boolean | BankAccount$balanceHistoryArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankName?: boolean
    accountType?: boolean
    currency?: boolean
    currentBalance?: boolean
    isActive?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankName?: boolean
    accountType?: boolean
    currency?: boolean
    currentBalance?: boolean
    isActive?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectScalar = {
    id?: boolean
    name?: boolean
    accountNumber?: boolean
    bankName?: boolean
    accountType?: boolean
    currency?: boolean
    currentBalance?: boolean
    isActive?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "accountNumber" | "bankName" | "accountType" | "currency" | "currentBalance" | "isActive" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["bankAccount"]>
  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | BankAccount$transactionsArgs<ExtArgs>
    balanceHistory?: boolean | BankAccount$balanceHistoryArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BankAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BankAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      balanceHistory: Prisma.$BankBalancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      accountNumber: string | null
      bankName: string | null
      accountType: string | null
      currency: string
      currentBalance: number
      isActive: boolean
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankAccounts and returns the data saved in the database.
     * @param {BankAccountCreateManyAndReturnArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, BankAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts and returns the data updated in the database.
     * @param {BankAccountUpdateManyAndReturnArgs} args - Arguments to update many BankAccounts.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, BankAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends BankAccount$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, BankAccount$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    balanceHistory<T extends BankAccount$balanceHistoryArgs<ExtArgs> = {}>(args?: Subset<T, BankAccount$balanceHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'String'>
    readonly name: FieldRef<"BankAccount", 'String'>
    readonly accountNumber: FieldRef<"BankAccount", 'String'>
    readonly bankName: FieldRef<"BankAccount", 'String'>
    readonly accountType: FieldRef<"BankAccount", 'String'>
    readonly currency: FieldRef<"BankAccount", 'String'>
    readonly currentBalance: FieldRef<"BankAccount", 'Float'>
    readonly isActive: FieldRef<"BankAccount", 'Boolean'>
    readonly tenantId: FieldRef<"BankAccount", 'String'>
    readonly isDeleted: FieldRef<"BankAccount", 'Boolean'>
    readonly deletedAt: FieldRef<"BankAccount", 'DateTime'>
    readonly deletedBy: FieldRef<"BankAccount", 'String'>
    readonly createdBy: FieldRef<"BankAccount", 'String'>
    readonly createdAt: FieldRef<"BankAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"BankAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount createManyAndReturn
   */
  export type BankAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
  }

  /**
   * BankAccount updateManyAndReturn
   */
  export type BankAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to delete.
     */
    limit?: number
  }

  /**
   * BankAccount.transactions
   */
  export type BankAccount$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * BankAccount.balanceHistory
   */
  export type BankAccount$balanceHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
    where?: BankBalanceWhereInput
    orderBy?: BankBalanceOrderByWithRelationInput | BankBalanceOrderByWithRelationInput[]
    cursor?: BankBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankBalanceScalarFieldEnum | BankBalanceScalarFieldEnum[]
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
  }


  /**
   * Model TransactionCategory
   */

  export type AggregateTransactionCategory = {
    _count: TransactionCategoryCountAggregateOutputType | null
    _min: TransactionCategoryMinAggregateOutputType | null
    _max: TransactionCategoryMaxAggregateOutputType | null
  }

  export type TransactionCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    color: string | null
    description: string | null
    isActive: boolean | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    icon: string | null
    color: string | null
    description: string | null
    isActive: boolean | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TransactionCategoryCountAggregateOutputType = {
    id: number
    name: number
    icon: number
    color: number
    description: number
    isActive: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TransactionCategoryMinAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    description?: true
    isActive?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    description?: true
    isActive?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TransactionCategoryCountAggregateInputType = {
    id?: true
    name?: true
    icon?: true
    color?: true
    description?: true
    isActive?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TransactionCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionCategory to aggregate.
     */
    where?: TransactionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionCategories to fetch.
     */
    orderBy?: TransactionCategoryOrderByWithRelationInput | TransactionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionCategories
    **/
    _count?: true | TransactionCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionCategoryMaxAggregateInputType
  }

  export type GetTransactionCategoryAggregateType<T extends TransactionCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionCategory[P]>
      : GetScalarType<T[P], AggregateTransactionCategory[P]>
  }




  export type TransactionCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionCategoryWhereInput
    orderBy?: TransactionCategoryOrderByWithAggregationInput | TransactionCategoryOrderByWithAggregationInput[]
    by: TransactionCategoryScalarFieldEnum[] | TransactionCategoryScalarFieldEnum
    having?: TransactionCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCategoryCountAggregateInputType | true
    _min?: TransactionCategoryMinAggregateInputType
    _max?: TransactionCategoryMaxAggregateInputType
  }

  export type TransactionCategoryGroupByOutputType = {
    id: string
    name: string
    icon: string | null
    color: string | null
    description: string | null
    isActive: boolean
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: TransactionCategoryCountAggregateOutputType | null
    _min: TransactionCategoryMinAggregateOutputType | null
    _max: TransactionCategoryMaxAggregateOutputType | null
  }

  type GetTransactionCategoryGroupByPayload<T extends TransactionCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionCategoryGroupByOutputType[P]>
        }
      >
    >


  export type TransactionCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transactions?: boolean | TransactionCategory$transactionsArgs<ExtArgs>
    _count?: boolean | TransactionCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionCategory"]>

  export type TransactionCategorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transactionCategory"]>

  export type TransactionCategorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["transactionCategory"]>

  export type TransactionCategorySelectScalar = {
    id?: boolean
    name?: boolean
    icon?: boolean
    color?: boolean
    description?: boolean
    isActive?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TransactionCategoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "icon" | "color" | "description" | "isActive" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["transactionCategory"]>
  export type TransactionCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | TransactionCategory$transactionsArgs<ExtArgs>
    _count?: boolean | TransactionCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TransactionCategoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TransactionCategoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TransactionCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionCategory"
    objects: {
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      icon: string | null
      color: string | null
      description: string | null
      isActive: boolean
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["transactionCategory"]>
    composites: {}
  }

  type TransactionCategoryGetPayload<S extends boolean | null | undefined | TransactionCategoryDefaultArgs> = $Result.GetResult<Prisma.$TransactionCategoryPayload, S>

  type TransactionCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionCategoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCategoryCountAggregateInputType | true
    }

  export interface TransactionCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionCategory'], meta: { name: 'TransactionCategory' } }
    /**
     * Find zero or one TransactionCategory that matches the filter.
     * @param {TransactionCategoryFindUniqueArgs} args - Arguments to find a TransactionCategory
     * @example
     * // Get one TransactionCategory
     * const transactionCategory = await prisma.transactionCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionCategoryFindUniqueArgs>(args: SelectSubset<T, TransactionCategoryFindUniqueArgs<ExtArgs>>): Prisma__TransactionCategoryClient<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TransactionCategory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionCategoryFindUniqueOrThrowArgs} args - Arguments to find a TransactionCategory
     * @example
     * // Get one TransactionCategory
     * const transactionCategory = await prisma.transactionCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionCategoryClient<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCategoryFindFirstArgs} args - Arguments to find a TransactionCategory
     * @example
     * // Get one TransactionCategory
     * const transactionCategory = await prisma.transactionCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionCategoryFindFirstArgs>(args?: SelectSubset<T, TransactionCategoryFindFirstArgs<ExtArgs>>): Prisma__TransactionCategoryClient<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TransactionCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCategoryFindFirstOrThrowArgs} args - Arguments to find a TransactionCategory
     * @example
     * // Get one TransactionCategory
     * const transactionCategory = await prisma.transactionCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionCategoryClient<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TransactionCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionCategories
     * const transactionCategories = await prisma.transactionCategory.findMany()
     * 
     * // Get first 10 TransactionCategories
     * const transactionCategories = await prisma.transactionCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionCategoryWithIdOnly = await prisma.transactionCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionCategoryFindManyArgs>(args?: SelectSubset<T, TransactionCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TransactionCategory.
     * @param {TransactionCategoryCreateArgs} args - Arguments to create a TransactionCategory.
     * @example
     * // Create one TransactionCategory
     * const TransactionCategory = await prisma.transactionCategory.create({
     *   data: {
     *     // ... data to create a TransactionCategory
     *   }
     * })
     * 
     */
    create<T extends TransactionCategoryCreateArgs>(args: SelectSubset<T, TransactionCategoryCreateArgs<ExtArgs>>): Prisma__TransactionCategoryClient<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TransactionCategories.
     * @param {TransactionCategoryCreateManyArgs} args - Arguments to create many TransactionCategories.
     * @example
     * // Create many TransactionCategories
     * const transactionCategory = await prisma.transactionCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCategoryCreateManyArgs>(args?: SelectSubset<T, TransactionCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionCategories and returns the data saved in the database.
     * @param {TransactionCategoryCreateManyAndReturnArgs} args - Arguments to create many TransactionCategories.
     * @example
     * // Create many TransactionCategories
     * const transactionCategory = await prisma.transactionCategory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionCategories and only return the `id`
     * const transactionCategoryWithIdOnly = await prisma.transactionCategory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCategoryCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCategoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TransactionCategory.
     * @param {TransactionCategoryDeleteArgs} args - Arguments to delete one TransactionCategory.
     * @example
     * // Delete one TransactionCategory
     * const TransactionCategory = await prisma.transactionCategory.delete({
     *   where: {
     *     // ... filter to delete one TransactionCategory
     *   }
     * })
     * 
     */
    delete<T extends TransactionCategoryDeleteArgs>(args: SelectSubset<T, TransactionCategoryDeleteArgs<ExtArgs>>): Prisma__TransactionCategoryClient<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TransactionCategory.
     * @param {TransactionCategoryUpdateArgs} args - Arguments to update one TransactionCategory.
     * @example
     * // Update one TransactionCategory
     * const transactionCategory = await prisma.transactionCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionCategoryUpdateArgs>(args: SelectSubset<T, TransactionCategoryUpdateArgs<ExtArgs>>): Prisma__TransactionCategoryClient<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TransactionCategories.
     * @param {TransactionCategoryDeleteManyArgs} args - Arguments to filter TransactionCategories to delete.
     * @example
     * // Delete a few TransactionCategories
     * const { count } = await prisma.transactionCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionCategoryDeleteManyArgs>(args?: SelectSubset<T, TransactionCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionCategories
     * const transactionCategory = await prisma.transactionCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionCategoryUpdateManyArgs>(args: SelectSubset<T, TransactionCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionCategories and returns the data updated in the database.
     * @param {TransactionCategoryUpdateManyAndReturnArgs} args - Arguments to update many TransactionCategories.
     * @example
     * // Update many TransactionCategories
     * const transactionCategory = await prisma.transactionCategory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TransactionCategories and only return the `id`
     * const transactionCategoryWithIdOnly = await prisma.transactionCategory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionCategoryUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionCategoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TransactionCategory.
     * @param {TransactionCategoryUpsertArgs} args - Arguments to update or create a TransactionCategory.
     * @example
     * // Update or create a TransactionCategory
     * const transactionCategory = await prisma.transactionCategory.upsert({
     *   create: {
     *     // ... data to create a TransactionCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionCategory we want to update
     *   }
     * })
     */
    upsert<T extends TransactionCategoryUpsertArgs>(args: SelectSubset<T, TransactionCategoryUpsertArgs<ExtArgs>>): Prisma__TransactionCategoryClient<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TransactionCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCategoryCountArgs} args - Arguments to filter TransactionCategories to count.
     * @example
     * // Count the number of TransactionCategories
     * const count = await prisma.transactionCategory.count({
     *   where: {
     *     // ... the filter for the TransactionCategories we want to count
     *   }
     * })
    **/
    count<T extends TransactionCategoryCountArgs>(
      args?: Subset<T, TransactionCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionCategoryAggregateArgs>(args: Subset<T, TransactionCategoryAggregateArgs>): Prisma.PrismaPromise<GetTransactionCategoryAggregateType<T>>

    /**
     * Group by TransactionCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionCategoryGroupByArgs['orderBy'] }
        : { orderBy?: TransactionCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionCategory model
   */
  readonly fields: TransactionCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends TransactionCategory$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, TransactionCategory$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionCategory model
   */
  interface TransactionCategoryFieldRefs {
    readonly id: FieldRef<"TransactionCategory", 'String'>
    readonly name: FieldRef<"TransactionCategory", 'String'>
    readonly icon: FieldRef<"TransactionCategory", 'String'>
    readonly color: FieldRef<"TransactionCategory", 'String'>
    readonly description: FieldRef<"TransactionCategory", 'String'>
    readonly isActive: FieldRef<"TransactionCategory", 'Boolean'>
    readonly tenantId: FieldRef<"TransactionCategory", 'String'>
    readonly isDeleted: FieldRef<"TransactionCategory", 'Boolean'>
    readonly deletedAt: FieldRef<"TransactionCategory", 'DateTime'>
    readonly deletedBy: FieldRef<"TransactionCategory", 'String'>
    readonly createdBy: FieldRef<"TransactionCategory", 'String'>
    readonly createdAt: FieldRef<"TransactionCategory", 'DateTime'>
    readonly updatedAt: FieldRef<"TransactionCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionCategory findUnique
   */
  export type TransactionCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TransactionCategory to fetch.
     */
    where: TransactionCategoryWhereUniqueInput
  }

  /**
   * TransactionCategory findUniqueOrThrow
   */
  export type TransactionCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TransactionCategory to fetch.
     */
    where: TransactionCategoryWhereUniqueInput
  }

  /**
   * TransactionCategory findFirst
   */
  export type TransactionCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TransactionCategory to fetch.
     */
    where?: TransactionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionCategories to fetch.
     */
    orderBy?: TransactionCategoryOrderByWithRelationInput | TransactionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionCategories.
     */
    cursor?: TransactionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionCategories.
     */
    distinct?: TransactionCategoryScalarFieldEnum | TransactionCategoryScalarFieldEnum[]
  }

  /**
   * TransactionCategory findFirstOrThrow
   */
  export type TransactionCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TransactionCategory to fetch.
     */
    where?: TransactionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionCategories to fetch.
     */
    orderBy?: TransactionCategoryOrderByWithRelationInput | TransactionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionCategories.
     */
    cursor?: TransactionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionCategories.
     */
    distinct?: TransactionCategoryScalarFieldEnum | TransactionCategoryScalarFieldEnum[]
  }

  /**
   * TransactionCategory findMany
   */
  export type TransactionCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
    /**
     * Filter, which TransactionCategories to fetch.
     */
    where?: TransactionCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionCategories to fetch.
     */
    orderBy?: TransactionCategoryOrderByWithRelationInput | TransactionCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionCategories.
     */
    cursor?: TransactionCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionCategories.
     */
    skip?: number
    distinct?: TransactionCategoryScalarFieldEnum | TransactionCategoryScalarFieldEnum[]
  }

  /**
   * TransactionCategory create
   */
  export type TransactionCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionCategory.
     */
    data: XOR<TransactionCategoryCreateInput, TransactionCategoryUncheckedCreateInput>
  }

  /**
   * TransactionCategory createMany
   */
  export type TransactionCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionCategories.
     */
    data: TransactionCategoryCreateManyInput | TransactionCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionCategory createManyAndReturn
   */
  export type TransactionCategoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * The data used to create many TransactionCategories.
     */
    data: TransactionCategoryCreateManyInput | TransactionCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionCategory update
   */
  export type TransactionCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionCategory.
     */
    data: XOR<TransactionCategoryUpdateInput, TransactionCategoryUncheckedUpdateInput>
    /**
     * Choose, which TransactionCategory to update.
     */
    where: TransactionCategoryWhereUniqueInput
  }

  /**
   * TransactionCategory updateMany
   */
  export type TransactionCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionCategories.
     */
    data: XOR<TransactionCategoryUpdateManyMutationInput, TransactionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TransactionCategories to update
     */
    where?: TransactionCategoryWhereInput
    /**
     * Limit how many TransactionCategories to update.
     */
    limit?: number
  }

  /**
   * TransactionCategory updateManyAndReturn
   */
  export type TransactionCategoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * The data used to update TransactionCategories.
     */
    data: XOR<TransactionCategoryUpdateManyMutationInput, TransactionCategoryUncheckedUpdateManyInput>
    /**
     * Filter which TransactionCategories to update
     */
    where?: TransactionCategoryWhereInput
    /**
     * Limit how many TransactionCategories to update.
     */
    limit?: number
  }

  /**
   * TransactionCategory upsert
   */
  export type TransactionCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionCategory to update in case it exists.
     */
    where: TransactionCategoryWhereUniqueInput
    /**
     * In case the TransactionCategory found by the `where` argument doesn't exist, create a new TransactionCategory with this data.
     */
    create: XOR<TransactionCategoryCreateInput, TransactionCategoryUncheckedCreateInput>
    /**
     * In case the TransactionCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionCategoryUpdateInput, TransactionCategoryUncheckedUpdateInput>
  }

  /**
   * TransactionCategory delete
   */
  export type TransactionCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
    /**
     * Filter which TransactionCategory to delete.
     */
    where: TransactionCategoryWhereUniqueInput
  }

  /**
   * TransactionCategory deleteMany
   */
  export type TransactionCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionCategories to delete
     */
    where?: TransactionCategoryWhereInput
    /**
     * Limit how many TransactionCategories to delete.
     */
    limit?: number
  }

  /**
   * TransactionCategory.transactions
   */
  export type TransactionCategory$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * TransactionCategory without action
   */
  export type TransactionCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    description: string | null
    amount: number | null
    type: $Enums.TransactionType | null
    status: $Enums.TransactionStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    externalId: string | null
    accountId: string | null
    categoryId: string | null
    customerName: string | null
    supplierName: string | null
    employeeName: string | null
    projectName: string | null
    notes: string | null
    receiptUrl: string | null
    mpPaymentId: string | null
    mpStatus: string | null
    mpPaymentType: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    payrollId: string | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    description: string | null
    amount: number | null
    type: $Enums.TransactionType | null
    status: $Enums.TransactionStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    reference: string | null
    externalId: string | null
    accountId: string | null
    categoryId: string | null
    customerName: string | null
    supplierName: string | null
    employeeName: string | null
    projectName: string | null
    notes: string | null
    receiptUrl: string | null
    mpPaymentId: string | null
    mpStatus: string | null
    mpPaymentType: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
    payrollId: string | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    description: number
    amount: number
    type: number
    status: number
    paymentMethod: number
    reference: number
    externalId: number
    accountId: number
    categoryId: number
    customerName: number
    supplierName: number
    employeeName: number
    projectName: number
    items: number
    notes: number
    receiptUrl: number
    mpPaymentId: number
    mpStatus: number
    mpPaymentType: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    payrollId: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    type?: true
    status?: true
    paymentMethod?: true
    reference?: true
    externalId?: true
    accountId?: true
    categoryId?: true
    customerName?: true
    supplierName?: true
    employeeName?: true
    projectName?: true
    notes?: true
    receiptUrl?: true
    mpPaymentId?: true
    mpStatus?: true
    mpPaymentType?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    payrollId?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    type?: true
    status?: true
    paymentMethod?: true
    reference?: true
    externalId?: true
    accountId?: true
    categoryId?: true
    customerName?: true
    supplierName?: true
    employeeName?: true
    projectName?: true
    notes?: true
    receiptUrl?: true
    mpPaymentId?: true
    mpStatus?: true
    mpPaymentType?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    payrollId?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    type?: true
    status?: true
    paymentMethod?: true
    reference?: true
    externalId?: true
    accountId?: true
    categoryId?: true
    customerName?: true
    supplierName?: true
    employeeName?: true
    projectName?: true
    items?: true
    notes?: true
    receiptUrl?: true
    mpPaymentId?: true
    mpStatus?: true
    mpPaymentType?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    payrollId?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status: $Enums.TransactionStatus
    paymentMethod: $Enums.PaymentMethod
    reference: string | null
    externalId: string | null
    accountId: string
    categoryId: string | null
    customerName: string | null
    supplierName: string | null
    employeeName: string | null
    projectName: string | null
    items: JsonValue | null
    notes: string | null
    receiptUrl: string | null
    mpPaymentId: string | null
    mpStatus: string | null
    mpPaymentType: string | null
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    payrollId: string | null
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    externalId?: boolean
    accountId?: boolean
    categoryId?: boolean
    customerName?: boolean
    supplierName?: boolean
    employeeName?: boolean
    projectName?: boolean
    items?: boolean
    notes?: boolean
    receiptUrl?: boolean
    mpPaymentId?: boolean
    mpStatus?: boolean
    mpPaymentType?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payrollId?: boolean
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    creator?: boolean | Transaction$creatorArgs<ExtArgs>
    payroll?: boolean | Transaction$payrollArgs<ExtArgs>
    expenseReimbursement?: boolean | Transaction$expenseReimbursementArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    externalId?: boolean
    accountId?: boolean
    categoryId?: boolean
    customerName?: boolean
    supplierName?: boolean
    employeeName?: boolean
    projectName?: boolean
    items?: boolean
    notes?: boolean
    receiptUrl?: boolean
    mpPaymentId?: boolean
    mpStatus?: boolean
    mpPaymentType?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payrollId?: boolean
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    creator?: boolean | Transaction$creatorArgs<ExtArgs>
    payroll?: boolean | Transaction$payrollArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    externalId?: boolean
    accountId?: boolean
    categoryId?: boolean
    customerName?: boolean
    supplierName?: boolean
    employeeName?: boolean
    projectName?: boolean
    items?: boolean
    notes?: boolean
    receiptUrl?: boolean
    mpPaymentId?: boolean
    mpStatus?: boolean
    mpPaymentType?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payrollId?: boolean
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    creator?: boolean | Transaction$creatorArgs<ExtArgs>
    payroll?: boolean | Transaction$payrollArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    description?: boolean
    amount?: boolean
    type?: boolean
    status?: boolean
    paymentMethod?: boolean
    reference?: boolean
    externalId?: boolean
    accountId?: boolean
    categoryId?: boolean
    customerName?: boolean
    supplierName?: boolean
    employeeName?: boolean
    projectName?: boolean
    items?: boolean
    notes?: boolean
    receiptUrl?: boolean
    mpPaymentId?: boolean
    mpStatus?: boolean
    mpPaymentType?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payrollId?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "description" | "amount" | "type" | "status" | "paymentMethod" | "reference" | "externalId" | "accountId" | "categoryId" | "customerName" | "supplierName" | "employeeName" | "projectName" | "items" | "notes" | "receiptUrl" | "mpPaymentId" | "mpStatus" | "mpPaymentType" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt" | "payrollId", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    creator?: boolean | Transaction$creatorArgs<ExtArgs>
    payroll?: boolean | Transaction$payrollArgs<ExtArgs>
    expenseReimbursement?: boolean | Transaction$expenseReimbursementArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    creator?: boolean | Transaction$creatorArgs<ExtArgs>
    payroll?: boolean | Transaction$payrollArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
    category?: boolean | Transaction$categoryArgs<ExtArgs>
    creator?: boolean | Transaction$creatorArgs<ExtArgs>
    payroll?: boolean | Transaction$payrollArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      account: Prisma.$BankAccountPayload<ExtArgs>
      category: Prisma.$TransactionCategoryPayload<ExtArgs> | null
      creator: Prisma.$UserPayload<ExtArgs> | null
      payroll: Prisma.$PayrollPayload<ExtArgs> | null
      expenseReimbursement: Prisma.$EmployeeExpensePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      description: string
      amount: number
      type: $Enums.TransactionType
      status: $Enums.TransactionStatus
      paymentMethod: $Enums.PaymentMethod
      reference: string | null
      externalId: string | null
      accountId: string
      categoryId: string | null
      customerName: string | null
      supplierName: string | null
      employeeName: string | null
      projectName: string | null
      items: Prisma.JsonValue | null
      notes: string | null
      receiptUrl: string | null
      mpPaymentId: string | null
      mpStatus: string | null
      mpPaymentType: string | null
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
      payrollId: string | null
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends BankAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BankAccountDefaultArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    category<T extends Transaction$categoryArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$categoryArgs<ExtArgs>>): Prisma__TransactionCategoryClient<$Result.GetResult<Prisma.$TransactionCategoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    creator<T extends Transaction$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payroll<T extends Transaction$payrollArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$payrollArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    expenseReimbursement<T extends Transaction$expenseReimbursementArgs<ExtArgs> = {}>(args?: Subset<T, Transaction$expenseReimbursementArgs<ExtArgs>>): Prisma__EmployeeExpenseClient<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Float'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly status: FieldRef<"Transaction", 'TransactionStatus'>
    readonly paymentMethod: FieldRef<"Transaction", 'PaymentMethod'>
    readonly reference: FieldRef<"Transaction", 'String'>
    readonly externalId: FieldRef<"Transaction", 'String'>
    readonly accountId: FieldRef<"Transaction", 'String'>
    readonly categoryId: FieldRef<"Transaction", 'String'>
    readonly customerName: FieldRef<"Transaction", 'String'>
    readonly supplierName: FieldRef<"Transaction", 'String'>
    readonly employeeName: FieldRef<"Transaction", 'String'>
    readonly projectName: FieldRef<"Transaction", 'String'>
    readonly items: FieldRef<"Transaction", 'Json'>
    readonly notes: FieldRef<"Transaction", 'String'>
    readonly receiptUrl: FieldRef<"Transaction", 'String'>
    readonly mpPaymentId: FieldRef<"Transaction", 'String'>
    readonly mpStatus: FieldRef<"Transaction", 'String'>
    readonly mpPaymentType: FieldRef<"Transaction", 'String'>
    readonly tenantId: FieldRef<"Transaction", 'String'>
    readonly isDeleted: FieldRef<"Transaction", 'Boolean'>
    readonly deletedAt: FieldRef<"Transaction", 'DateTime'>
    readonly deletedBy: FieldRef<"Transaction", 'String'>
    readonly createdBy: FieldRef<"Transaction", 'String'>
    readonly createdAt: FieldRef<"Transaction", 'DateTime'>
    readonly updatedAt: FieldRef<"Transaction", 'DateTime'>
    readonly payrollId: FieldRef<"Transaction", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction.category
   */
  export type Transaction$categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionCategory
     */
    select?: TransactionCategorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the TransactionCategory
     */
    omit?: TransactionCategoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionCategoryInclude<ExtArgs> | null
    where?: TransactionCategoryWhereInput
  }

  /**
   * Transaction.creator
   */
  export type Transaction$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Transaction.payroll
   */
  export type Transaction$payrollArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
  }

  /**
   * Transaction.expenseReimbursement
   */
  export type Transaction$expenseReimbursementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    where?: EmployeeExpenseWhereInput
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model BankBalance
   */

  export type AggregateBankBalance = {
    _count: BankBalanceCountAggregateOutputType | null
    _avg: BankBalanceAvgAggregateOutputType | null
    _sum: BankBalanceSumAggregateOutputType | null
    _min: BankBalanceMinAggregateOutputType | null
    _max: BankBalanceMaxAggregateOutputType | null
  }

  export type BankBalanceAvgAggregateOutputType = {
    openingBalance: number | null
    closingBalance: number | null
    totalIncome: number | null
    totalExpenses: number | null
    transactionCount: number | null
  }

  export type BankBalanceSumAggregateOutputType = {
    openingBalance: number | null
    closingBalance: number | null
    totalIncome: number | null
    totalExpenses: number | null
    transactionCount: number | null
  }

  export type BankBalanceMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    balanceDate: Date | null
    openingBalance: number | null
    closingBalance: number | null
    totalIncome: number | null
    totalExpenses: number | null
    transactionCount: number | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankBalanceMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    balanceDate: Date | null
    openingBalance: number | null
    closingBalance: number | null
    totalIncome: number | null
    totalExpenses: number | null
    transactionCount: number | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BankBalanceCountAggregateOutputType = {
    id: number
    accountId: number
    balanceDate: number
    openingBalance: number
    closingBalance: number
    totalIncome: number
    totalExpenses: number
    transactionCount: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BankBalanceAvgAggregateInputType = {
    openingBalance?: true
    closingBalance?: true
    totalIncome?: true
    totalExpenses?: true
    transactionCount?: true
  }

  export type BankBalanceSumAggregateInputType = {
    openingBalance?: true
    closingBalance?: true
    totalIncome?: true
    totalExpenses?: true
    transactionCount?: true
  }

  export type BankBalanceMinAggregateInputType = {
    id?: true
    accountId?: true
    balanceDate?: true
    openingBalance?: true
    closingBalance?: true
    totalIncome?: true
    totalExpenses?: true
    transactionCount?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankBalanceMaxAggregateInputType = {
    id?: true
    accountId?: true
    balanceDate?: true
    openingBalance?: true
    closingBalance?: true
    totalIncome?: true
    totalExpenses?: true
    transactionCount?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BankBalanceCountAggregateInputType = {
    id?: true
    accountId?: true
    balanceDate?: true
    openingBalance?: true
    closingBalance?: true
    totalIncome?: true
    totalExpenses?: true
    transactionCount?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BankBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankBalance to aggregate.
     */
    where?: BankBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankBalances to fetch.
     */
    orderBy?: BankBalanceOrderByWithRelationInput | BankBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankBalances
    **/
    _count?: true | BankBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankBalanceMaxAggregateInputType
  }

  export type GetBankBalanceAggregateType<T extends BankBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateBankBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankBalance[P]>
      : GetScalarType<T[P], AggregateBankBalance[P]>
  }




  export type BankBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankBalanceWhereInput
    orderBy?: BankBalanceOrderByWithAggregationInput | BankBalanceOrderByWithAggregationInput[]
    by: BankBalanceScalarFieldEnum[] | BankBalanceScalarFieldEnum
    having?: BankBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankBalanceCountAggregateInputType | true
    _avg?: BankBalanceAvgAggregateInputType
    _sum?: BankBalanceSumAggregateInputType
    _min?: BankBalanceMinAggregateInputType
    _max?: BankBalanceMaxAggregateInputType
  }

  export type BankBalanceGroupByOutputType = {
    id: string
    accountId: string
    balanceDate: Date
    openingBalance: number
    closingBalance: number
    totalIncome: number
    totalExpenses: number
    transactionCount: number
    tenantId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BankBalanceCountAggregateOutputType | null
    _avg: BankBalanceAvgAggregateOutputType | null
    _sum: BankBalanceSumAggregateOutputType | null
    _min: BankBalanceMinAggregateOutputType | null
    _max: BankBalanceMaxAggregateOutputType | null
  }

  type GetBankBalanceGroupByPayload<T extends BankBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], BankBalanceGroupByOutputType[P]>
        }
      >
    >


  export type BankBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    balanceDate?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    transactionCount?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankBalance"]>

  export type BankBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    balanceDate?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    transactionCount?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankBalance"]>

  export type BankBalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    balanceDate?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    transactionCount?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankBalance"]>

  export type BankBalanceSelectScalar = {
    id?: boolean
    accountId?: boolean
    balanceDate?: boolean
    openingBalance?: boolean
    closingBalance?: boolean
    totalIncome?: boolean
    totalExpenses?: boolean
    transactionCount?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BankBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "balanceDate" | "openingBalance" | "closingBalance" | "totalIncome" | "totalExpenses" | "transactionCount" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["bankBalance"]>
  export type BankBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }
  export type BankBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }
  export type BankBalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }

  export type $BankBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankBalance"
    objects: {
      account: Prisma.$BankAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      balanceDate: Date
      openingBalance: number
      closingBalance: number
      totalIncome: number
      totalExpenses: number
      transactionCount: number
      tenantId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bankBalance"]>
    composites: {}
  }

  type BankBalanceGetPayload<S extends boolean | null | undefined | BankBalanceDefaultArgs> = $Result.GetResult<Prisma.$BankBalancePayload, S>

  type BankBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankBalanceCountAggregateInputType | true
    }

  export interface BankBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankBalance'], meta: { name: 'BankBalance' } }
    /**
     * Find zero or one BankBalance that matches the filter.
     * @param {BankBalanceFindUniqueArgs} args - Arguments to find a BankBalance
     * @example
     * // Get one BankBalance
     * const bankBalance = await prisma.bankBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankBalanceFindUniqueArgs>(args: SelectSubset<T, BankBalanceFindUniqueArgs<ExtArgs>>): Prisma__BankBalanceClient<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankBalanceFindUniqueOrThrowArgs} args - Arguments to find a BankBalance
     * @example
     * // Get one BankBalance
     * const bankBalance = await prisma.bankBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, BankBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankBalanceClient<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankBalanceFindFirstArgs} args - Arguments to find a BankBalance
     * @example
     * // Get one BankBalance
     * const bankBalance = await prisma.bankBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankBalanceFindFirstArgs>(args?: SelectSubset<T, BankBalanceFindFirstArgs<ExtArgs>>): Prisma__BankBalanceClient<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankBalanceFindFirstOrThrowArgs} args - Arguments to find a BankBalance
     * @example
     * // Get one BankBalance
     * const bankBalance = await prisma.bankBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, BankBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankBalanceClient<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankBalances
     * const bankBalances = await prisma.bankBalance.findMany()
     * 
     * // Get first 10 BankBalances
     * const bankBalances = await prisma.bankBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankBalanceWithIdOnly = await prisma.bankBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankBalanceFindManyArgs>(args?: SelectSubset<T, BankBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankBalance.
     * @param {BankBalanceCreateArgs} args - Arguments to create a BankBalance.
     * @example
     * // Create one BankBalance
     * const BankBalance = await prisma.bankBalance.create({
     *   data: {
     *     // ... data to create a BankBalance
     *   }
     * })
     * 
     */
    create<T extends BankBalanceCreateArgs>(args: SelectSubset<T, BankBalanceCreateArgs<ExtArgs>>): Prisma__BankBalanceClient<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankBalances.
     * @param {BankBalanceCreateManyArgs} args - Arguments to create many BankBalances.
     * @example
     * // Create many BankBalances
     * const bankBalance = await prisma.bankBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankBalanceCreateManyArgs>(args?: SelectSubset<T, BankBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankBalances and returns the data saved in the database.
     * @param {BankBalanceCreateManyAndReturnArgs} args - Arguments to create many BankBalances.
     * @example
     * // Create many BankBalances
     * const bankBalance = await prisma.bankBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankBalances and only return the `id`
     * const bankBalanceWithIdOnly = await prisma.bankBalance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, BankBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankBalance.
     * @param {BankBalanceDeleteArgs} args - Arguments to delete one BankBalance.
     * @example
     * // Delete one BankBalance
     * const BankBalance = await prisma.bankBalance.delete({
     *   where: {
     *     // ... filter to delete one BankBalance
     *   }
     * })
     * 
     */
    delete<T extends BankBalanceDeleteArgs>(args: SelectSubset<T, BankBalanceDeleteArgs<ExtArgs>>): Prisma__BankBalanceClient<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankBalance.
     * @param {BankBalanceUpdateArgs} args - Arguments to update one BankBalance.
     * @example
     * // Update one BankBalance
     * const bankBalance = await prisma.bankBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankBalanceUpdateArgs>(args: SelectSubset<T, BankBalanceUpdateArgs<ExtArgs>>): Prisma__BankBalanceClient<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankBalances.
     * @param {BankBalanceDeleteManyArgs} args - Arguments to filter BankBalances to delete.
     * @example
     * // Delete a few BankBalances
     * const { count } = await prisma.bankBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankBalanceDeleteManyArgs>(args?: SelectSubset<T, BankBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankBalances
     * const bankBalance = await prisma.bankBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankBalanceUpdateManyArgs>(args: SelectSubset<T, BankBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankBalances and returns the data updated in the database.
     * @param {BankBalanceUpdateManyAndReturnArgs} args - Arguments to update many BankBalances.
     * @example
     * // Update many BankBalances
     * const bankBalance = await prisma.bankBalance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankBalances and only return the `id`
     * const bankBalanceWithIdOnly = await prisma.bankBalance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankBalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, BankBalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankBalance.
     * @param {BankBalanceUpsertArgs} args - Arguments to update or create a BankBalance.
     * @example
     * // Update or create a BankBalance
     * const bankBalance = await prisma.bankBalance.upsert({
     *   create: {
     *     // ... data to create a BankBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankBalance we want to update
     *   }
     * })
     */
    upsert<T extends BankBalanceUpsertArgs>(args: SelectSubset<T, BankBalanceUpsertArgs<ExtArgs>>): Prisma__BankBalanceClient<$Result.GetResult<Prisma.$BankBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankBalanceCountArgs} args - Arguments to filter BankBalances to count.
     * @example
     * // Count the number of BankBalances
     * const count = await prisma.bankBalance.count({
     *   where: {
     *     // ... the filter for the BankBalances we want to count
     *   }
     * })
    **/
    count<T extends BankBalanceCountArgs>(
      args?: Subset<T, BankBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankBalanceAggregateArgs>(args: Subset<T, BankBalanceAggregateArgs>): Prisma.PrismaPromise<GetBankBalanceAggregateType<T>>

    /**
     * Group by BankBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankBalanceGroupByArgs['orderBy'] }
        : { orderBy?: BankBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankBalance model
   */
  readonly fields: BankBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends BankAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BankAccountDefaultArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankBalance model
   */
  interface BankBalanceFieldRefs {
    readonly id: FieldRef<"BankBalance", 'String'>
    readonly accountId: FieldRef<"BankBalance", 'String'>
    readonly balanceDate: FieldRef<"BankBalance", 'DateTime'>
    readonly openingBalance: FieldRef<"BankBalance", 'Float'>
    readonly closingBalance: FieldRef<"BankBalance", 'Float'>
    readonly totalIncome: FieldRef<"BankBalance", 'Float'>
    readonly totalExpenses: FieldRef<"BankBalance", 'Float'>
    readonly transactionCount: FieldRef<"BankBalance", 'Int'>
    readonly tenantId: FieldRef<"BankBalance", 'String'>
    readonly createdAt: FieldRef<"BankBalance", 'DateTime'>
    readonly updatedAt: FieldRef<"BankBalance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankBalance findUnique
   */
  export type BankBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
    /**
     * Filter, which BankBalance to fetch.
     */
    where: BankBalanceWhereUniqueInput
  }

  /**
   * BankBalance findUniqueOrThrow
   */
  export type BankBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
    /**
     * Filter, which BankBalance to fetch.
     */
    where: BankBalanceWhereUniqueInput
  }

  /**
   * BankBalance findFirst
   */
  export type BankBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
    /**
     * Filter, which BankBalance to fetch.
     */
    where?: BankBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankBalances to fetch.
     */
    orderBy?: BankBalanceOrderByWithRelationInput | BankBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankBalances.
     */
    cursor?: BankBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankBalances.
     */
    distinct?: BankBalanceScalarFieldEnum | BankBalanceScalarFieldEnum[]
  }

  /**
   * BankBalance findFirstOrThrow
   */
  export type BankBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
    /**
     * Filter, which BankBalance to fetch.
     */
    where?: BankBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankBalances to fetch.
     */
    orderBy?: BankBalanceOrderByWithRelationInput | BankBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankBalances.
     */
    cursor?: BankBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankBalances.
     */
    distinct?: BankBalanceScalarFieldEnum | BankBalanceScalarFieldEnum[]
  }

  /**
   * BankBalance findMany
   */
  export type BankBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
    /**
     * Filter, which BankBalances to fetch.
     */
    where?: BankBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankBalances to fetch.
     */
    orderBy?: BankBalanceOrderByWithRelationInput | BankBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankBalances.
     */
    cursor?: BankBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankBalances.
     */
    skip?: number
    distinct?: BankBalanceScalarFieldEnum | BankBalanceScalarFieldEnum[]
  }

  /**
   * BankBalance create
   */
  export type BankBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a BankBalance.
     */
    data: XOR<BankBalanceCreateInput, BankBalanceUncheckedCreateInput>
  }

  /**
   * BankBalance createMany
   */
  export type BankBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankBalances.
     */
    data: BankBalanceCreateManyInput | BankBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankBalance createManyAndReturn
   */
  export type BankBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * The data used to create many BankBalances.
     */
    data: BankBalanceCreateManyInput | BankBalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankBalance update
   */
  export type BankBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a BankBalance.
     */
    data: XOR<BankBalanceUpdateInput, BankBalanceUncheckedUpdateInput>
    /**
     * Choose, which BankBalance to update.
     */
    where: BankBalanceWhereUniqueInput
  }

  /**
   * BankBalance updateMany
   */
  export type BankBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankBalances.
     */
    data: XOR<BankBalanceUpdateManyMutationInput, BankBalanceUncheckedUpdateManyInput>
    /**
     * Filter which BankBalances to update
     */
    where?: BankBalanceWhereInput
    /**
     * Limit how many BankBalances to update.
     */
    limit?: number
  }

  /**
   * BankBalance updateManyAndReturn
   */
  export type BankBalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * The data used to update BankBalances.
     */
    data: XOR<BankBalanceUpdateManyMutationInput, BankBalanceUncheckedUpdateManyInput>
    /**
     * Filter which BankBalances to update
     */
    where?: BankBalanceWhereInput
    /**
     * Limit how many BankBalances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankBalance upsert
   */
  export type BankBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the BankBalance to update in case it exists.
     */
    where: BankBalanceWhereUniqueInput
    /**
     * In case the BankBalance found by the `where` argument doesn't exist, create a new BankBalance with this data.
     */
    create: XOR<BankBalanceCreateInput, BankBalanceUncheckedCreateInput>
    /**
     * In case the BankBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankBalanceUpdateInput, BankBalanceUncheckedUpdateInput>
  }

  /**
   * BankBalance delete
   */
  export type BankBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
    /**
     * Filter which BankBalance to delete.
     */
    where: BankBalanceWhereUniqueInput
  }

  /**
   * BankBalance deleteMany
   */
  export type BankBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankBalances to delete
     */
    where?: BankBalanceWhereInput
    /**
     * Limit how many BankBalances to delete.
     */
    limit?: number
  }

  /**
   * BankBalance without action
   */
  export type BankBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankBalance
     */
    select?: BankBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankBalance
     */
    omit?: BankBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankBalanceInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    isActive: boolean | null
    roleId: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    username: string | null
    firstName: string | null
    lastName: string | null
    password: string | null
    isActive: boolean | null
    roleId: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    username: number
    firstName: number
    lastName: number
    password: number
    isActive: number
    roleId: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    password?: true
    isActive?: true
    roleId?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    password?: true
    isActive?: true
    roleId?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    username?: true
    firstName?: true
    lastName?: true
    password?: true
    isActive?: true
    roleId?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive: boolean
    roleId: string
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    isActive?: boolean
    roleId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    documentRevisions?: boolean | User$documentRevisionsArgs<ExtArgs>
    sales?: boolean | User$salesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    auditTrails?: boolean | User$auditTrailsArgs<ExtArgs>
    notificationTemplatesCreated?: boolean | User$notificationTemplatesCreatedArgs<ExtArgs>
    notificationRulesCreated?: boolean | User$notificationRulesCreatedArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    magicTokens?: boolean | User$magicTokensArgs<ExtArgs>
    payrollsApproved?: boolean | User$payrollsApprovedArgs<ExtArgs>
    payrollsProcessed?: boolean | User$payrollsProcessedArgs<ExtArgs>
    payrollEntries?: boolean | User$payrollEntriesArgs<ExtArgs>
    salaryAdjustments?: boolean | User$salaryAdjustmentsArgs<ExtArgs>
    salaryAdjustmentsApproved?: boolean | User$salaryAdjustmentsApprovedArgs<ExtArgs>
    employeeExpenses?: boolean | User$employeeExpensesArgs<ExtArgs>
    expenseReviews?: boolean | User$expenseReviewsArgs<ExtArgs>
    ptoRequests?: boolean | User$ptoRequestsArgs<ExtArgs>
    ptoApprovals?: boolean | User$ptoApprovalsArgs<ExtArgs>
    ptoBalances?: boolean | User$ptoBalancesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    isActive?: boolean
    roleId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    isActive?: boolean
    roleId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    username?: boolean
    firstName?: boolean
    lastName?: boolean
    password?: boolean
    isActive?: boolean
    roleId?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "username" | "firstName" | "lastName" | "password" | "isActive" | "roleId" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
    tasks?: boolean | User$tasksArgs<ExtArgs>
    documents?: boolean | User$documentsArgs<ExtArgs>
    documentRevisions?: boolean | User$documentRevisionsArgs<ExtArgs>
    sales?: boolean | User$salesArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    auditTrails?: boolean | User$auditTrailsArgs<ExtArgs>
    notificationTemplatesCreated?: boolean | User$notificationTemplatesCreatedArgs<ExtArgs>
    notificationRulesCreated?: boolean | User$notificationRulesCreatedArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    magicTokens?: boolean | User$magicTokensArgs<ExtArgs>
    payrollsApproved?: boolean | User$payrollsApprovedArgs<ExtArgs>
    payrollsProcessed?: boolean | User$payrollsProcessedArgs<ExtArgs>
    payrollEntries?: boolean | User$payrollEntriesArgs<ExtArgs>
    salaryAdjustments?: boolean | User$salaryAdjustmentsArgs<ExtArgs>
    salaryAdjustmentsApproved?: boolean | User$salaryAdjustmentsApprovedArgs<ExtArgs>
    employeeExpenses?: boolean | User$employeeExpensesArgs<ExtArgs>
    expenseReviews?: boolean | User$expenseReviewsArgs<ExtArgs>
    ptoRequests?: boolean | User$ptoRequestsArgs<ExtArgs>
    ptoApprovals?: boolean | User$ptoApprovalsArgs<ExtArgs>
    ptoBalances?: boolean | User$ptoBalancesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    role?: boolean | RoleDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      role: Prisma.$RolePayload<ExtArgs>
      tasks: Prisma.$TaskPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      documentRevisions: Prisma.$DocumentRevisionPayload<ExtArgs>[]
      sales: Prisma.$SalePayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      auditTrails: Prisma.$AuditTrailPayload<ExtArgs>[]
      notificationTemplatesCreated: Prisma.$NotificationTemplatePayload<ExtArgs>[]
      notificationRulesCreated: Prisma.$NotificationRulePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      magicTokens: Prisma.$MagicTokenPayload<ExtArgs>[]
      payrollsApproved: Prisma.$PayrollPayload<ExtArgs>[]
      payrollsProcessed: Prisma.$PayrollPayload<ExtArgs>[]
      payrollEntries: Prisma.$PayrollEntryPayload<ExtArgs>[]
      salaryAdjustments: Prisma.$SalaryAdjustmentPayload<ExtArgs>[]
      salaryAdjustmentsApproved: Prisma.$SalaryAdjustmentPayload<ExtArgs>[]
      employeeExpenses: Prisma.$EmployeeExpensePayload<ExtArgs>[]
      expenseReviews: Prisma.$EmployeeExpensePayload<ExtArgs>[]
      ptoRequests: Prisma.$PTORequestPayload<ExtArgs>[]
      ptoApprovals: Prisma.$PTORequestPayload<ExtArgs>[]
      ptoBalances: Prisma.$PTOBalancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      username: string
      firstName: string
      lastName: string
      password: string
      isActive: boolean
      roleId: string
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    role<T extends RoleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoleDefaultArgs<ExtArgs>>): Prisma__RoleClient<$Result.GetResult<Prisma.$RolePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tasks<T extends User$tasksArgs<ExtArgs> = {}>(args?: Subset<T, User$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends User$documentsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentRevisions<T extends User$documentRevisionsArgs<ExtArgs> = {}>(args?: Subset<T, User$documentRevisionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentRevisionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sales<T extends User$salesArgs<ExtArgs> = {}>(args?: Subset<T, User$salesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditTrails<T extends User$auditTrailsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditTrailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationTemplatesCreated<T extends User$notificationTemplatesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationTemplatesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notificationRulesCreated<T extends User$notificationRulesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationRulesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    magicTokens<T extends User$magicTokensArgs<ExtArgs> = {}>(args?: Subset<T, User$magicTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollsApproved<T extends User$payrollsApprovedArgs<ExtArgs> = {}>(args?: Subset<T, User$payrollsApprovedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollsProcessed<T extends User$payrollsProcessedArgs<ExtArgs> = {}>(args?: Subset<T, User$payrollsProcessedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payrollEntries<T extends User$payrollEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$payrollEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaryAdjustments<T extends User$salaryAdjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$salaryAdjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    salaryAdjustmentsApproved<T extends User$salaryAdjustmentsApprovedArgs<ExtArgs> = {}>(args?: Subset<T, User$salaryAdjustmentsApprovedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    employeeExpenses<T extends User$employeeExpensesArgs<ExtArgs> = {}>(args?: Subset<T, User$employeeExpensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    expenseReviews<T extends User$expenseReviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$expenseReviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ptoRequests<T extends User$ptoRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$ptoRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ptoApprovals<T extends User$ptoApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$ptoApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ptoBalances<T extends User$ptoBalancesArgs<ExtArgs> = {}>(args?: Subset<T, User$ptoBalancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly roleId: FieldRef<"User", 'String'>
    readonly tenantId: FieldRef<"User", 'String'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly deletedBy: FieldRef<"User", 'String'>
    readonly createdBy: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.tasks
   */
  export type User$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Task
     */
    select?: TaskSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Task
     */
    omit?: TaskOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TaskInclude<ExtArgs> | null
    where?: TaskWhereInput
    orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[]
    cursor?: TaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[]
  }

  /**
   * User.documents
   */
  export type User$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * User.documentRevisions
   */
  export type User$documentRevisionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentRevision
     */
    select?: DocumentRevisionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentRevision
     */
    omit?: DocumentRevisionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentRevisionInclude<ExtArgs> | null
    where?: DocumentRevisionWhereInput
    orderBy?: DocumentRevisionOrderByWithRelationInput | DocumentRevisionOrderByWithRelationInput[]
    cursor?: DocumentRevisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentRevisionScalarFieldEnum | DocumentRevisionScalarFieldEnum[]
  }

  /**
   * User.sales
   */
  export type User$salesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sale
     */
    select?: SaleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Sale
     */
    omit?: SaleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SaleInclude<ExtArgs> | null
    where?: SaleWhereInput
    orderBy?: SaleOrderByWithRelationInput | SaleOrderByWithRelationInput[]
    cursor?: SaleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SaleScalarFieldEnum | SaleScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.auditTrails
   */
  export type User$auditTrailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    where?: AuditTrailWhereInput
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    cursor?: AuditTrailWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * User.notificationTemplatesCreated
   */
  export type User$notificationTemplatesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    where?: NotificationTemplateWhereInput
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    cursor?: NotificationTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * User.notificationRulesCreated
   */
  export type User$notificationRulesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    where?: NotificationRuleWhereInput
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    cursor?: NotificationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.magicTokens
   */
  export type User$magicTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
    where?: MagicTokenWhereInput
    orderBy?: MagicTokenOrderByWithRelationInput | MagicTokenOrderByWithRelationInput[]
    cursor?: MagicTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MagicTokenScalarFieldEnum | MagicTokenScalarFieldEnum[]
  }

  /**
   * User.payrollsApproved
   */
  export type User$payrollsApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * User.payrollsProcessed
   */
  export type User$payrollsProcessedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    cursor?: PayrollWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * User.payrollEntries
   */
  export type User$payrollEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    where?: PayrollEntryWhereInput
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    cursor?: PayrollEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * User.salaryAdjustments
   */
  export type User$salaryAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    where?: SalaryAdjustmentWhereInput
    orderBy?: SalaryAdjustmentOrderByWithRelationInput | SalaryAdjustmentOrderByWithRelationInput[]
    cursor?: SalaryAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryAdjustmentScalarFieldEnum | SalaryAdjustmentScalarFieldEnum[]
  }

  /**
   * User.salaryAdjustmentsApproved
   */
  export type User$salaryAdjustmentsApprovedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    where?: SalaryAdjustmentWhereInput
    orderBy?: SalaryAdjustmentOrderByWithRelationInput | SalaryAdjustmentOrderByWithRelationInput[]
    cursor?: SalaryAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SalaryAdjustmentScalarFieldEnum | SalaryAdjustmentScalarFieldEnum[]
  }

  /**
   * User.employeeExpenses
   */
  export type User$employeeExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    where?: EmployeeExpenseWhereInput
    orderBy?: EmployeeExpenseOrderByWithRelationInput | EmployeeExpenseOrderByWithRelationInput[]
    cursor?: EmployeeExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeExpenseScalarFieldEnum | EmployeeExpenseScalarFieldEnum[]
  }

  /**
   * User.expenseReviews
   */
  export type User$expenseReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    where?: EmployeeExpenseWhereInput
    orderBy?: EmployeeExpenseOrderByWithRelationInput | EmployeeExpenseOrderByWithRelationInput[]
    cursor?: EmployeeExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeExpenseScalarFieldEnum | EmployeeExpenseScalarFieldEnum[]
  }

  /**
   * User.ptoRequests
   */
  export type User$ptoRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    where?: PTORequestWhereInput
    orderBy?: PTORequestOrderByWithRelationInput | PTORequestOrderByWithRelationInput[]
    cursor?: PTORequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PTORequestScalarFieldEnum | PTORequestScalarFieldEnum[]
  }

  /**
   * User.ptoApprovals
   */
  export type User$ptoApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    where?: PTORequestWhereInput
    orderBy?: PTORequestOrderByWithRelationInput | PTORequestOrderByWithRelationInput[]
    cursor?: PTORequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PTORequestScalarFieldEnum | PTORequestScalarFieldEnum[]
  }

  /**
   * User.ptoBalances
   */
  export type User$ptoBalancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
    where?: PTOBalanceWhereInput
    orderBy?: PTOBalanceOrderByWithRelationInput | PTOBalanceOrderByWithRelationInput[]
    cursor?: PTOBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PTOBalanceScalarFieldEnum | PTOBalanceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model MagicToken
   */

  export type AggregateMagicToken = {
    _count: MagicTokenCountAggregateOutputType | null
    _min: MagicTokenMinAggregateOutputType | null
    _max: MagicTokenMaxAggregateOutputType | null
  }

  export type MagicTokenMinAggregateOutputType = {
    id: string | null
    userId: string | null
    purpose: string | null
    tokenHash: string | null
    expiresAt: Date | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MagicTokenMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    purpose: string | null
    tokenHash: string | null
    expiresAt: Date | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MagicTokenCountAggregateOutputType = {
    id: number
    userId: number
    purpose: number
    tokenHash: number
    expiresAt: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MagicTokenMinAggregateInputType = {
    id?: true
    userId?: true
    purpose?: true
    tokenHash?: true
    expiresAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MagicTokenMaxAggregateInputType = {
    id?: true
    userId?: true
    purpose?: true
    tokenHash?: true
    expiresAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MagicTokenCountAggregateInputType = {
    id?: true
    userId?: true
    purpose?: true
    tokenHash?: true
    expiresAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MagicTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicToken to aggregate.
     */
    where?: MagicTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicTokens to fetch.
     */
    orderBy?: MagicTokenOrderByWithRelationInput | MagicTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MagicTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MagicTokens
    **/
    _count?: true | MagicTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagicTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagicTokenMaxAggregateInputType
  }

  export type GetMagicTokenAggregateType<T extends MagicTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateMagicToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagicToken[P]>
      : GetScalarType<T[P], AggregateMagicToken[P]>
  }




  export type MagicTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MagicTokenWhereInput
    orderBy?: MagicTokenOrderByWithAggregationInput | MagicTokenOrderByWithAggregationInput[]
    by: MagicTokenScalarFieldEnum[] | MagicTokenScalarFieldEnum
    having?: MagicTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagicTokenCountAggregateInputType | true
    _min?: MagicTokenMinAggregateInputType
    _max?: MagicTokenMaxAggregateInputType
  }

  export type MagicTokenGroupByOutputType = {
    id: string
    userId: string
    purpose: string
    tokenHash: string
    expiresAt: Date
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: MagicTokenCountAggregateOutputType | null
    _min: MagicTokenMinAggregateOutputType | null
    _max: MagicTokenMaxAggregateOutputType | null
  }

  type GetMagicTokenGroupByPayload<T extends MagicTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MagicTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagicTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagicTokenGroupByOutputType[P]>
            : GetScalarType<T[P], MagicTokenGroupByOutputType[P]>
        }
      >
    >


  export type MagicTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    purpose?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicToken"]>

  export type MagicTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    purpose?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicToken"]>

  export type MagicTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    purpose?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["magicToken"]>

  export type MagicTokenSelectScalar = {
    id?: boolean
    userId?: boolean
    purpose?: boolean
    tokenHash?: boolean
    expiresAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MagicTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "purpose" | "tokenHash" | "expiresAt" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["magicToken"]>
  export type MagicTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MagicTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MagicTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MagicTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MagicToken"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      purpose: string
      tokenHash: string
      expiresAt: Date
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["magicToken"]>
    composites: {}
  }

  type MagicTokenGetPayload<S extends boolean | null | undefined | MagicTokenDefaultArgs> = $Result.GetResult<Prisma.$MagicTokenPayload, S>

  type MagicTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MagicTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MagicTokenCountAggregateInputType | true
    }

  export interface MagicTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MagicToken'], meta: { name: 'MagicToken' } }
    /**
     * Find zero or one MagicToken that matches the filter.
     * @param {MagicTokenFindUniqueArgs} args - Arguments to find a MagicToken
     * @example
     * // Get one MagicToken
     * const magicToken = await prisma.magicToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MagicTokenFindUniqueArgs>(args: SelectSubset<T, MagicTokenFindUniqueArgs<ExtArgs>>): Prisma__MagicTokenClient<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MagicToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MagicTokenFindUniqueOrThrowArgs} args - Arguments to find a MagicToken
     * @example
     * // Get one MagicToken
     * const magicToken = await prisma.magicToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MagicTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, MagicTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MagicTokenClient<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MagicToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicTokenFindFirstArgs} args - Arguments to find a MagicToken
     * @example
     * // Get one MagicToken
     * const magicToken = await prisma.magicToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MagicTokenFindFirstArgs>(args?: SelectSubset<T, MagicTokenFindFirstArgs<ExtArgs>>): Prisma__MagicTokenClient<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MagicToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicTokenFindFirstOrThrowArgs} args - Arguments to find a MagicToken
     * @example
     * // Get one MagicToken
     * const magicToken = await prisma.magicToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MagicTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, MagicTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__MagicTokenClient<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MagicTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MagicTokens
     * const magicTokens = await prisma.magicToken.findMany()
     * 
     * // Get first 10 MagicTokens
     * const magicTokens = await prisma.magicToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const magicTokenWithIdOnly = await prisma.magicToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MagicTokenFindManyArgs>(args?: SelectSubset<T, MagicTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MagicToken.
     * @param {MagicTokenCreateArgs} args - Arguments to create a MagicToken.
     * @example
     * // Create one MagicToken
     * const MagicToken = await prisma.magicToken.create({
     *   data: {
     *     // ... data to create a MagicToken
     *   }
     * })
     * 
     */
    create<T extends MagicTokenCreateArgs>(args: SelectSubset<T, MagicTokenCreateArgs<ExtArgs>>): Prisma__MagicTokenClient<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MagicTokens.
     * @param {MagicTokenCreateManyArgs} args - Arguments to create many MagicTokens.
     * @example
     * // Create many MagicTokens
     * const magicToken = await prisma.magicToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MagicTokenCreateManyArgs>(args?: SelectSubset<T, MagicTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MagicTokens and returns the data saved in the database.
     * @param {MagicTokenCreateManyAndReturnArgs} args - Arguments to create many MagicTokens.
     * @example
     * // Create many MagicTokens
     * const magicToken = await prisma.magicToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MagicTokens and only return the `id`
     * const magicTokenWithIdOnly = await prisma.magicToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MagicTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, MagicTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MagicToken.
     * @param {MagicTokenDeleteArgs} args - Arguments to delete one MagicToken.
     * @example
     * // Delete one MagicToken
     * const MagicToken = await prisma.magicToken.delete({
     *   where: {
     *     // ... filter to delete one MagicToken
     *   }
     * })
     * 
     */
    delete<T extends MagicTokenDeleteArgs>(args: SelectSubset<T, MagicTokenDeleteArgs<ExtArgs>>): Prisma__MagicTokenClient<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MagicToken.
     * @param {MagicTokenUpdateArgs} args - Arguments to update one MagicToken.
     * @example
     * // Update one MagicToken
     * const magicToken = await prisma.magicToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MagicTokenUpdateArgs>(args: SelectSubset<T, MagicTokenUpdateArgs<ExtArgs>>): Prisma__MagicTokenClient<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MagicTokens.
     * @param {MagicTokenDeleteManyArgs} args - Arguments to filter MagicTokens to delete.
     * @example
     * // Delete a few MagicTokens
     * const { count } = await prisma.magicToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MagicTokenDeleteManyArgs>(args?: SelectSubset<T, MagicTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MagicTokens
     * const magicToken = await prisma.magicToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MagicTokenUpdateManyArgs>(args: SelectSubset<T, MagicTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MagicTokens and returns the data updated in the database.
     * @param {MagicTokenUpdateManyAndReturnArgs} args - Arguments to update many MagicTokens.
     * @example
     * // Update many MagicTokens
     * const magicToken = await prisma.magicToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MagicTokens and only return the `id`
     * const magicTokenWithIdOnly = await prisma.magicToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MagicTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, MagicTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MagicToken.
     * @param {MagicTokenUpsertArgs} args - Arguments to update or create a MagicToken.
     * @example
     * // Update or create a MagicToken
     * const magicToken = await prisma.magicToken.upsert({
     *   create: {
     *     // ... data to create a MagicToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MagicToken we want to update
     *   }
     * })
     */
    upsert<T extends MagicTokenUpsertArgs>(args: SelectSubset<T, MagicTokenUpsertArgs<ExtArgs>>): Prisma__MagicTokenClient<$Result.GetResult<Prisma.$MagicTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MagicTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicTokenCountArgs} args - Arguments to filter MagicTokens to count.
     * @example
     * // Count the number of MagicTokens
     * const count = await prisma.magicToken.count({
     *   where: {
     *     // ... the filter for the MagicTokens we want to count
     *   }
     * })
    **/
    count<T extends MagicTokenCountArgs>(
      args?: Subset<T, MagicTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagicTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MagicToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagicTokenAggregateArgs>(args: Subset<T, MagicTokenAggregateArgs>): Prisma.PrismaPromise<GetMagicTokenAggregateType<T>>

    /**
     * Group by MagicToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagicTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagicTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagicTokenGroupByArgs['orderBy'] }
        : { orderBy?: MagicTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagicTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagicTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MagicToken model
   */
  readonly fields: MagicTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MagicToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MagicTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MagicToken model
   */
  interface MagicTokenFieldRefs {
    readonly id: FieldRef<"MagicToken", 'String'>
    readonly userId: FieldRef<"MagicToken", 'String'>
    readonly purpose: FieldRef<"MagicToken", 'String'>
    readonly tokenHash: FieldRef<"MagicToken", 'String'>
    readonly expiresAt: FieldRef<"MagicToken", 'DateTime'>
    readonly tenantId: FieldRef<"MagicToken", 'String'>
    readonly isDeleted: FieldRef<"MagicToken", 'Boolean'>
    readonly deletedAt: FieldRef<"MagicToken", 'DateTime'>
    readonly deletedBy: FieldRef<"MagicToken", 'String'>
    readonly createdBy: FieldRef<"MagicToken", 'String'>
    readonly createdAt: FieldRef<"MagicToken", 'DateTime'>
    readonly updatedAt: FieldRef<"MagicToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MagicToken findUnique
   */
  export type MagicTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
    /**
     * Filter, which MagicToken to fetch.
     */
    where: MagicTokenWhereUniqueInput
  }

  /**
   * MagicToken findUniqueOrThrow
   */
  export type MagicTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
    /**
     * Filter, which MagicToken to fetch.
     */
    where: MagicTokenWhereUniqueInput
  }

  /**
   * MagicToken findFirst
   */
  export type MagicTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
    /**
     * Filter, which MagicToken to fetch.
     */
    where?: MagicTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicTokens to fetch.
     */
    orderBy?: MagicTokenOrderByWithRelationInput | MagicTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicTokens.
     */
    cursor?: MagicTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicTokens.
     */
    distinct?: MagicTokenScalarFieldEnum | MagicTokenScalarFieldEnum[]
  }

  /**
   * MagicToken findFirstOrThrow
   */
  export type MagicTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
    /**
     * Filter, which MagicToken to fetch.
     */
    where?: MagicTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicTokens to fetch.
     */
    orderBy?: MagicTokenOrderByWithRelationInput | MagicTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MagicTokens.
     */
    cursor?: MagicTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MagicTokens.
     */
    distinct?: MagicTokenScalarFieldEnum | MagicTokenScalarFieldEnum[]
  }

  /**
   * MagicToken findMany
   */
  export type MagicTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
    /**
     * Filter, which MagicTokens to fetch.
     */
    where?: MagicTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MagicTokens to fetch.
     */
    orderBy?: MagicTokenOrderByWithRelationInput | MagicTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MagicTokens.
     */
    cursor?: MagicTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MagicTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MagicTokens.
     */
    skip?: number
    distinct?: MagicTokenScalarFieldEnum | MagicTokenScalarFieldEnum[]
  }

  /**
   * MagicToken create
   */
  export type MagicTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a MagicToken.
     */
    data: XOR<MagicTokenCreateInput, MagicTokenUncheckedCreateInput>
  }

  /**
   * MagicToken createMany
   */
  export type MagicTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MagicTokens.
     */
    data: MagicTokenCreateManyInput | MagicTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MagicToken createManyAndReturn
   */
  export type MagicTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * The data used to create many MagicTokens.
     */
    data: MagicTokenCreateManyInput | MagicTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MagicToken update
   */
  export type MagicTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a MagicToken.
     */
    data: XOR<MagicTokenUpdateInput, MagicTokenUncheckedUpdateInput>
    /**
     * Choose, which MagicToken to update.
     */
    where: MagicTokenWhereUniqueInput
  }

  /**
   * MagicToken updateMany
   */
  export type MagicTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MagicTokens.
     */
    data: XOR<MagicTokenUpdateManyMutationInput, MagicTokenUncheckedUpdateManyInput>
    /**
     * Filter which MagicTokens to update
     */
    where?: MagicTokenWhereInput
    /**
     * Limit how many MagicTokens to update.
     */
    limit?: number
  }

  /**
   * MagicToken updateManyAndReturn
   */
  export type MagicTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * The data used to update MagicTokens.
     */
    data: XOR<MagicTokenUpdateManyMutationInput, MagicTokenUncheckedUpdateManyInput>
    /**
     * Filter which MagicTokens to update
     */
    where?: MagicTokenWhereInput
    /**
     * Limit how many MagicTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MagicToken upsert
   */
  export type MagicTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the MagicToken to update in case it exists.
     */
    where: MagicTokenWhereUniqueInput
    /**
     * In case the MagicToken found by the `where` argument doesn't exist, create a new MagicToken with this data.
     */
    create: XOR<MagicTokenCreateInput, MagicTokenUncheckedCreateInput>
    /**
     * In case the MagicToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MagicTokenUpdateInput, MagicTokenUncheckedUpdateInput>
  }

  /**
   * MagicToken delete
   */
  export type MagicTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
    /**
     * Filter which MagicToken to delete.
     */
    where: MagicTokenWhereUniqueInput
  }

  /**
   * MagicToken deleteMany
   */
  export type MagicTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MagicTokens to delete
     */
    where?: MagicTokenWhereInput
    /**
     * Limit how many MagicTokens to delete.
     */
    limit?: number
  }

  /**
   * MagicToken without action
   */
  export type MagicTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MagicToken
     */
    select?: MagicTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MagicToken
     */
    omit?: MagicTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MagicTokenInclude<ExtArgs> | null
  }


  /**
   * Model AuditTrail
   */

  export type AggregateAuditTrail = {
    _count: AuditTrailCountAggregateOutputType | null
    _min: AuditTrailMinAggregateOutputType | null
    _max: AuditTrailMaxAggregateOutputType | null
  }

  export type AuditTrailMinAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    operation: $Enums.AuditOperation | null
    userId: string | null
    tenantId: string | null
    timestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type AuditTrailMaxAggregateOutputType = {
    id: string | null
    tableName: string | null
    recordId: string | null
    operation: $Enums.AuditOperation | null
    userId: string | null
    tenantId: string | null
    timestamp: Date | null
    ipAddress: string | null
    userAgent: string | null
  }

  export type AuditTrailCountAggregateOutputType = {
    id: number
    tableName: number
    recordId: number
    operation: number
    beforeData: number
    afterData: number
    userId: number
    tenantId: number
    timestamp: number
    ipAddress: number
    userAgent: number
    _all: number
  }


  export type AuditTrailMinAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operation?: true
    userId?: true
    tenantId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
  }

  export type AuditTrailMaxAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operation?: true
    userId?: true
    tenantId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
  }

  export type AuditTrailCountAggregateInputType = {
    id?: true
    tableName?: true
    recordId?: true
    operation?: true
    beforeData?: true
    afterData?: true
    userId?: true
    tenantId?: true
    timestamp?: true
    ipAddress?: true
    userAgent?: true
    _all?: true
  }

  export type AuditTrailAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditTrail to aggregate.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditTrails
    **/
    _count?: true | AuditTrailCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditTrailMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditTrailMaxAggregateInputType
  }

  export type GetAuditTrailAggregateType<T extends AuditTrailAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditTrail]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditTrail[P]>
      : GetScalarType<T[P], AggregateAuditTrail[P]>
  }




  export type AuditTrailGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditTrailWhereInput
    orderBy?: AuditTrailOrderByWithAggregationInput | AuditTrailOrderByWithAggregationInput[]
    by: AuditTrailScalarFieldEnum[] | AuditTrailScalarFieldEnum
    having?: AuditTrailScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditTrailCountAggregateInputType | true
    _min?: AuditTrailMinAggregateInputType
    _max?: AuditTrailMaxAggregateInputType
  }

  export type AuditTrailGroupByOutputType = {
    id: string
    tableName: string
    recordId: string
    operation: $Enums.AuditOperation
    beforeData: JsonValue | null
    afterData: JsonValue | null
    userId: string | null
    tenantId: string | null
    timestamp: Date
    ipAddress: string | null
    userAgent: string | null
    _count: AuditTrailCountAggregateOutputType | null
    _min: AuditTrailMinAggregateOutputType | null
    _max: AuditTrailMaxAggregateOutputType | null
  }

  type GetAuditTrailGroupByPayload<T extends AuditTrailGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditTrailGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditTrailGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditTrailGroupByOutputType[P]>
            : GetScalarType<T[P], AuditTrailGroupByOutputType[P]>
        }
      >
    >


  export type AuditTrailSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    beforeData?: boolean
    afterData?: boolean
    userId?: boolean
    tenantId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | AuditTrail$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditTrail"]>

  export type AuditTrailSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    beforeData?: boolean
    afterData?: boolean
    userId?: boolean
    tenantId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | AuditTrail$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditTrail"]>

  export type AuditTrailSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    beforeData?: boolean
    afterData?: boolean
    userId?: boolean
    tenantId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    user?: boolean | AuditTrail$userArgs<ExtArgs>
  }, ExtArgs["result"]["auditTrail"]>

  export type AuditTrailSelectScalar = {
    id?: boolean
    tableName?: boolean
    recordId?: boolean
    operation?: boolean
    beforeData?: boolean
    afterData?: boolean
    userId?: boolean
    tenantId?: boolean
    timestamp?: boolean
    ipAddress?: boolean
    userAgent?: boolean
  }

  export type AuditTrailOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tableName" | "recordId" | "operation" | "beforeData" | "afterData" | "userId" | "tenantId" | "timestamp" | "ipAddress" | "userAgent", ExtArgs["result"]["auditTrail"]>
  export type AuditTrailInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditTrail$userArgs<ExtArgs>
  }
  export type AuditTrailIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditTrail$userArgs<ExtArgs>
  }
  export type AuditTrailIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | AuditTrail$userArgs<ExtArgs>
  }

  export type $AuditTrailPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditTrail"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tableName: string
      recordId: string
      operation: $Enums.AuditOperation
      beforeData: Prisma.JsonValue | null
      afterData: Prisma.JsonValue | null
      userId: string | null
      tenantId: string | null
      timestamp: Date
      ipAddress: string | null
      userAgent: string | null
    }, ExtArgs["result"]["auditTrail"]>
    composites: {}
  }

  type AuditTrailGetPayload<S extends boolean | null | undefined | AuditTrailDefaultArgs> = $Result.GetResult<Prisma.$AuditTrailPayload, S>

  type AuditTrailCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditTrailFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditTrailCountAggregateInputType | true
    }

  export interface AuditTrailDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditTrail'], meta: { name: 'AuditTrail' } }
    /**
     * Find zero or one AuditTrail that matches the filter.
     * @param {AuditTrailFindUniqueArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditTrailFindUniqueArgs>(args: SelectSubset<T, AuditTrailFindUniqueArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditTrail that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditTrailFindUniqueOrThrowArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditTrailFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditTrailFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditTrail that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindFirstArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditTrailFindFirstArgs>(args?: SelectSubset<T, AuditTrailFindFirstArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditTrail that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindFirstOrThrowArgs} args - Arguments to find a AuditTrail
     * @example
     * // Get one AuditTrail
     * const auditTrail = await prisma.auditTrail.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditTrailFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditTrailFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditTrails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditTrails
     * const auditTrails = await prisma.auditTrail.findMany()
     * 
     * // Get first 10 AuditTrails
     * const auditTrails = await prisma.auditTrail.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditTrailWithIdOnly = await prisma.auditTrail.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditTrailFindManyArgs>(args?: SelectSubset<T, AuditTrailFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditTrail.
     * @param {AuditTrailCreateArgs} args - Arguments to create a AuditTrail.
     * @example
     * // Create one AuditTrail
     * const AuditTrail = await prisma.auditTrail.create({
     *   data: {
     *     // ... data to create a AuditTrail
     *   }
     * })
     * 
     */
    create<T extends AuditTrailCreateArgs>(args: SelectSubset<T, AuditTrailCreateArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditTrails.
     * @param {AuditTrailCreateManyArgs} args - Arguments to create many AuditTrails.
     * @example
     * // Create many AuditTrails
     * const auditTrail = await prisma.auditTrail.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditTrailCreateManyArgs>(args?: SelectSubset<T, AuditTrailCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditTrails and returns the data saved in the database.
     * @param {AuditTrailCreateManyAndReturnArgs} args - Arguments to create many AuditTrails.
     * @example
     * // Create many AuditTrails
     * const auditTrail = await prisma.auditTrail.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditTrails and only return the `id`
     * const auditTrailWithIdOnly = await prisma.auditTrail.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditTrailCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditTrailCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditTrail.
     * @param {AuditTrailDeleteArgs} args - Arguments to delete one AuditTrail.
     * @example
     * // Delete one AuditTrail
     * const AuditTrail = await prisma.auditTrail.delete({
     *   where: {
     *     // ... filter to delete one AuditTrail
     *   }
     * })
     * 
     */
    delete<T extends AuditTrailDeleteArgs>(args: SelectSubset<T, AuditTrailDeleteArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditTrail.
     * @param {AuditTrailUpdateArgs} args - Arguments to update one AuditTrail.
     * @example
     * // Update one AuditTrail
     * const auditTrail = await prisma.auditTrail.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditTrailUpdateArgs>(args: SelectSubset<T, AuditTrailUpdateArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditTrails.
     * @param {AuditTrailDeleteManyArgs} args - Arguments to filter AuditTrails to delete.
     * @example
     * // Delete a few AuditTrails
     * const { count } = await prisma.auditTrail.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditTrailDeleteManyArgs>(args?: SelectSubset<T, AuditTrailDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditTrails
     * const auditTrail = await prisma.auditTrail.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditTrailUpdateManyArgs>(args: SelectSubset<T, AuditTrailUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditTrails and returns the data updated in the database.
     * @param {AuditTrailUpdateManyAndReturnArgs} args - Arguments to update many AuditTrails.
     * @example
     * // Update many AuditTrails
     * const auditTrail = await prisma.auditTrail.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditTrails and only return the `id`
     * const auditTrailWithIdOnly = await prisma.auditTrail.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditTrailUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditTrailUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditTrail.
     * @param {AuditTrailUpsertArgs} args - Arguments to update or create a AuditTrail.
     * @example
     * // Update or create a AuditTrail
     * const auditTrail = await prisma.auditTrail.upsert({
     *   create: {
     *     // ... data to create a AuditTrail
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditTrail we want to update
     *   }
     * })
     */
    upsert<T extends AuditTrailUpsertArgs>(args: SelectSubset<T, AuditTrailUpsertArgs<ExtArgs>>): Prisma__AuditTrailClient<$Result.GetResult<Prisma.$AuditTrailPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditTrails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailCountArgs} args - Arguments to filter AuditTrails to count.
     * @example
     * // Count the number of AuditTrails
     * const count = await prisma.auditTrail.count({
     *   where: {
     *     // ... the filter for the AuditTrails we want to count
     *   }
     * })
    **/
    count<T extends AuditTrailCountArgs>(
      args?: Subset<T, AuditTrailCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditTrailCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditTrailAggregateArgs>(args: Subset<T, AuditTrailAggregateArgs>): Prisma.PrismaPromise<GetAuditTrailAggregateType<T>>

    /**
     * Group by AuditTrail.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditTrailGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditTrailGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditTrailGroupByArgs['orderBy'] }
        : { orderBy?: AuditTrailGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditTrailGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditTrailGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditTrail model
   */
  readonly fields: AuditTrailFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditTrail.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditTrailClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends AuditTrail$userArgs<ExtArgs> = {}>(args?: Subset<T, AuditTrail$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditTrail model
   */
  interface AuditTrailFieldRefs {
    readonly id: FieldRef<"AuditTrail", 'String'>
    readonly tableName: FieldRef<"AuditTrail", 'String'>
    readonly recordId: FieldRef<"AuditTrail", 'String'>
    readonly operation: FieldRef<"AuditTrail", 'AuditOperation'>
    readonly beforeData: FieldRef<"AuditTrail", 'Json'>
    readonly afterData: FieldRef<"AuditTrail", 'Json'>
    readonly userId: FieldRef<"AuditTrail", 'String'>
    readonly tenantId: FieldRef<"AuditTrail", 'String'>
    readonly timestamp: FieldRef<"AuditTrail", 'DateTime'>
    readonly ipAddress: FieldRef<"AuditTrail", 'String'>
    readonly userAgent: FieldRef<"AuditTrail", 'String'>
  }
    

  // Custom InputTypes
  /**
   * AuditTrail findUnique
   */
  export type AuditTrailFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail findUniqueOrThrow
   */
  export type AuditTrailFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail findFirst
   */
  export type AuditTrailFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditTrails.
     */
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail findFirstOrThrow
   */
  export type AuditTrailFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrail to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditTrails.
     */
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail findMany
   */
  export type AuditTrailFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter, which AuditTrails to fetch.
     */
    where?: AuditTrailWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditTrails to fetch.
     */
    orderBy?: AuditTrailOrderByWithRelationInput | AuditTrailOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditTrails.
     */
    cursor?: AuditTrailWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditTrails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditTrails.
     */
    skip?: number
    distinct?: AuditTrailScalarFieldEnum | AuditTrailScalarFieldEnum[]
  }

  /**
   * AuditTrail create
   */
  export type AuditTrailCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditTrail.
     */
    data: XOR<AuditTrailCreateInput, AuditTrailUncheckedCreateInput>
  }

  /**
   * AuditTrail createMany
   */
  export type AuditTrailCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditTrails.
     */
    data: AuditTrailCreateManyInput | AuditTrailCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditTrail createManyAndReturn
   */
  export type AuditTrailCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * The data used to create many AuditTrails.
     */
    data: AuditTrailCreateManyInput | AuditTrailCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditTrail update
   */
  export type AuditTrailUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditTrail.
     */
    data: XOR<AuditTrailUpdateInput, AuditTrailUncheckedUpdateInput>
    /**
     * Choose, which AuditTrail to update.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail updateMany
   */
  export type AuditTrailUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditTrails.
     */
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyInput>
    /**
     * Filter which AuditTrails to update
     */
    where?: AuditTrailWhereInput
    /**
     * Limit how many AuditTrails to update.
     */
    limit?: number
  }

  /**
   * AuditTrail updateManyAndReturn
   */
  export type AuditTrailUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * The data used to update AuditTrails.
     */
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyInput>
    /**
     * Filter which AuditTrails to update
     */
    where?: AuditTrailWhereInput
    /**
     * Limit how many AuditTrails to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditTrail upsert
   */
  export type AuditTrailUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditTrail to update in case it exists.
     */
    where: AuditTrailWhereUniqueInput
    /**
     * In case the AuditTrail found by the `where` argument doesn't exist, create a new AuditTrail with this data.
     */
    create: XOR<AuditTrailCreateInput, AuditTrailUncheckedCreateInput>
    /**
     * In case the AuditTrail was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditTrailUpdateInput, AuditTrailUncheckedUpdateInput>
  }

  /**
   * AuditTrail delete
   */
  export type AuditTrailDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
    /**
     * Filter which AuditTrail to delete.
     */
    where: AuditTrailWhereUniqueInput
  }

  /**
   * AuditTrail deleteMany
   */
  export type AuditTrailDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditTrails to delete
     */
    where?: AuditTrailWhereInput
    /**
     * Limit how many AuditTrails to delete.
     */
    limit?: number
  }

  /**
   * AuditTrail.user
   */
  export type AuditTrail$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditTrail without action
   */
  export type AuditTrailDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditTrail
     */
    select?: AuditTrailSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditTrail
     */
    omit?: AuditTrailOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditTrailInclude<ExtArgs> | null
  }


  /**
   * Model NotificationTemplate
   */

  export type AggregateNotificationTemplate = {
    _count: NotificationTemplateCountAggregateOutputType | null
    _min: NotificationTemplateMinAggregateOutputType | null
    _max: NotificationTemplateMaxAggregateOutputType | null
  }

  export type NotificationTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.NotificationType | null
    subject: string | null
    content: string | null
    isActive: boolean | null
    createdBy: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    type: $Enums.NotificationType | null
    subject: string | null
    content: string | null
    isActive: boolean | null
    createdBy: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationTemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    type: number
    subject: number
    content: number
    variables: number
    isActive: number
    createdBy: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationTemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    subject?: true
    content?: true
    isActive?: true
    createdBy?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    subject?: true
    content?: true
    isActive?: true
    createdBy?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationTemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    type?: true
    subject?: true
    content?: true
    variables?: true
    isActive?: true
    createdBy?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTemplate to aggregate.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationTemplates
    **/
    _count?: true | NotificationTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationTemplateMaxAggregateInputType
  }

  export type GetNotificationTemplateAggregateType<T extends NotificationTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationTemplate[P]>
      : GetScalarType<T[P], AggregateNotificationTemplate[P]>
  }




  export type NotificationTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationTemplateWhereInput
    orderBy?: NotificationTemplateOrderByWithAggregationInput | NotificationTemplateOrderByWithAggregationInput[]
    by: NotificationTemplateScalarFieldEnum[] | NotificationTemplateScalarFieldEnum
    having?: NotificationTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationTemplateCountAggregateInputType | true
    _min?: NotificationTemplateMinAggregateInputType
    _max?: NotificationTemplateMaxAggregateInputType
  }

  export type NotificationTemplateGroupByOutputType = {
    id: string
    name: string
    description: string | null
    type: $Enums.NotificationType
    subject: string | null
    content: string
    variables: string[]
    isActive: boolean
    createdBy: string
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationTemplateCountAggregateOutputType | null
    _min: NotificationTemplateMinAggregateOutputType | null
    _max: NotificationTemplateMaxAggregateOutputType | null
  }

  type GetNotificationTemplateGroupByPayload<T extends NotificationTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationTemplateGroupByOutputType[P]>
        }
      >
    >


  export type NotificationTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    isActive?: boolean
    createdBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    rules?: boolean | NotificationTemplate$rulesArgs<ExtArgs>
    notifications?: boolean | NotificationTemplate$notificationsArgs<ExtArgs>
    _count?: boolean | NotificationTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    isActive?: boolean
    createdBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    isActive?: boolean
    createdBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationTemplate"]>

  export type NotificationTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    type?: boolean
    subject?: boolean
    content?: boolean
    variables?: boolean
    isActive?: boolean
    createdBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "type" | "subject" | "content" | "variables" | "isActive" | "createdBy" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationTemplate"]>
  export type NotificationTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    rules?: boolean | NotificationTemplate$rulesArgs<ExtArgs>
    notifications?: boolean | NotificationTemplate$notificationsArgs<ExtArgs>
    _count?: boolean | NotificationTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationTemplate"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      rules: Prisma.$NotificationRulePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      type: $Enums.NotificationType
      subject: string | null
      content: string
      variables: string[]
      isActive: boolean
      createdBy: string
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationTemplate"]>
    composites: {}
  }

  type NotificationTemplateGetPayload<S extends boolean | null | undefined | NotificationTemplateDefaultArgs> = $Result.GetResult<Prisma.$NotificationTemplatePayload, S>

  type NotificationTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationTemplateCountAggregateInputType | true
    }

  export interface NotificationTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationTemplate'], meta: { name: 'NotificationTemplate' } }
    /**
     * Find zero or one NotificationTemplate that matches the filter.
     * @param {NotificationTemplateFindUniqueArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationTemplateFindUniqueArgs>(args: SelectSubset<T, NotificationTemplateFindUniqueArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationTemplateFindUniqueOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationTemplateFindFirstArgs>(args?: SelectSubset<T, NotificationTemplateFindFirstArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindFirstOrThrowArgs} args - Arguments to find a NotificationTemplate
     * @example
     * // Get one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany()
     * 
     * // Get first 10 NotificationTemplates
     * const notificationTemplates = await prisma.notificationTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationTemplateFindManyArgs>(args?: SelectSubset<T, NotificationTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationTemplate.
     * @param {NotificationTemplateCreateArgs} args - Arguments to create a NotificationTemplate.
     * @example
     * // Create one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.create({
     *   data: {
     *     // ... data to create a NotificationTemplate
     *   }
     * })
     * 
     */
    create<T extends NotificationTemplateCreateArgs>(args: SelectSubset<T, NotificationTemplateCreateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationTemplates.
     * @param {NotificationTemplateCreateManyArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationTemplateCreateManyArgs>(args?: SelectSubset<T, NotificationTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationTemplates and returns the data saved in the database.
     * @param {NotificationTemplateCreateManyAndReturnArgs} args - Arguments to create many NotificationTemplates.
     * @example
     * // Create many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationTemplates and only return the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationTemplate.
     * @param {NotificationTemplateDeleteArgs} args - Arguments to delete one NotificationTemplate.
     * @example
     * // Delete one NotificationTemplate
     * const NotificationTemplate = await prisma.notificationTemplate.delete({
     *   where: {
     *     // ... filter to delete one NotificationTemplate
     *   }
     * })
     * 
     */
    delete<T extends NotificationTemplateDeleteArgs>(args: SelectSubset<T, NotificationTemplateDeleteArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationTemplate.
     * @param {NotificationTemplateUpdateArgs} args - Arguments to update one NotificationTemplate.
     * @example
     * // Update one NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationTemplateUpdateArgs>(args: SelectSubset<T, NotificationTemplateUpdateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationTemplates.
     * @param {NotificationTemplateDeleteManyArgs} args - Arguments to filter NotificationTemplates to delete.
     * @example
     * // Delete a few NotificationTemplates
     * const { count } = await prisma.notificationTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationTemplateDeleteManyArgs>(args?: SelectSubset<T, NotificationTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationTemplateUpdateManyArgs>(args: SelectSubset<T, NotificationTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationTemplates and returns the data updated in the database.
     * @param {NotificationTemplateUpdateManyAndReturnArgs} args - Arguments to update many NotificationTemplates.
     * @example
     * // Update many NotificationTemplates
     * const notificationTemplate = await prisma.notificationTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationTemplates and only return the `id`
     * const notificationTemplateWithIdOnly = await prisma.notificationTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationTemplate.
     * @param {NotificationTemplateUpsertArgs} args - Arguments to update or create a NotificationTemplate.
     * @example
     * // Update or create a NotificationTemplate
     * const notificationTemplate = await prisma.notificationTemplate.upsert({
     *   create: {
     *     // ... data to create a NotificationTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationTemplate we want to update
     *   }
     * })
     */
    upsert<T extends NotificationTemplateUpsertArgs>(args: SelectSubset<T, NotificationTemplateUpsertArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateCountArgs} args - Arguments to filter NotificationTemplates to count.
     * @example
     * // Count the number of NotificationTemplates
     * const count = await prisma.notificationTemplate.count({
     *   where: {
     *     // ... the filter for the NotificationTemplates we want to count
     *   }
     * })
    **/
    count<T extends NotificationTemplateCountArgs>(
      args?: Subset<T, NotificationTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationTemplateAggregateArgs>(args: Subset<T, NotificationTemplateAggregateArgs>): Prisma.PrismaPromise<GetNotificationTemplateAggregateType<T>>

    /**
     * Group by NotificationTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationTemplateGroupByArgs['orderBy'] }
        : { orderBy?: NotificationTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationTemplate model
   */
  readonly fields: NotificationTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    rules<T extends NotificationTemplate$rulesArgs<ExtArgs> = {}>(args?: Subset<T, NotificationTemplate$rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends NotificationTemplate$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, NotificationTemplate$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationTemplate model
   */
  interface NotificationTemplateFieldRefs {
    readonly id: FieldRef<"NotificationTemplate", 'String'>
    readonly name: FieldRef<"NotificationTemplate", 'String'>
    readonly description: FieldRef<"NotificationTemplate", 'String'>
    readonly type: FieldRef<"NotificationTemplate", 'NotificationType'>
    readonly subject: FieldRef<"NotificationTemplate", 'String'>
    readonly content: FieldRef<"NotificationTemplate", 'String'>
    readonly variables: FieldRef<"NotificationTemplate", 'String[]'>
    readonly isActive: FieldRef<"NotificationTemplate", 'Boolean'>
    readonly createdBy: FieldRef<"NotificationTemplate", 'String'>
    readonly tenantId: FieldRef<"NotificationTemplate", 'String'>
    readonly isDeleted: FieldRef<"NotificationTemplate", 'Boolean'>
    readonly deletedAt: FieldRef<"NotificationTemplate", 'DateTime'>
    readonly deletedBy: FieldRef<"NotificationTemplate", 'String'>
    readonly createdAt: FieldRef<"NotificationTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationTemplate findUnique
   */
  export type NotificationTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate findUniqueOrThrow
   */
  export type NotificationTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate findFirst
   */
  export type NotificationTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate findFirstOrThrow
   */
  export type NotificationTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplate to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationTemplates.
     */
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate findMany
   */
  export type NotificationTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter, which NotificationTemplates to fetch.
     */
    where?: NotificationTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationTemplates to fetch.
     */
    orderBy?: NotificationTemplateOrderByWithRelationInput | NotificationTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationTemplates.
     */
    cursor?: NotificationTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationTemplates.
     */
    skip?: number
    distinct?: NotificationTemplateScalarFieldEnum | NotificationTemplateScalarFieldEnum[]
  }

  /**
   * NotificationTemplate create
   */
  export type NotificationTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationTemplate.
     */
    data: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>
  }

  /**
   * NotificationTemplate createMany
   */
  export type NotificationTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationTemplate createManyAndReturn
   */
  export type NotificationTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationTemplates.
     */
    data: NotificationTemplateCreateManyInput | NotificationTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationTemplate update
   */
  export type NotificationTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationTemplate.
     */
    data: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>
    /**
     * Choose, which NotificationTemplate to update.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate updateMany
   */
  export type NotificationTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationTemplates.
     */
    data: XOR<NotificationTemplateUpdateManyMutationInput, NotificationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTemplates to update
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to update.
     */
    limit?: number
  }

  /**
   * NotificationTemplate updateManyAndReturn
   */
  export type NotificationTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * The data used to update NotificationTemplates.
     */
    data: XOR<NotificationTemplateUpdateManyMutationInput, NotificationTemplateUncheckedUpdateManyInput>
    /**
     * Filter which NotificationTemplates to update
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationTemplate upsert
   */
  export type NotificationTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationTemplate to update in case it exists.
     */
    where: NotificationTemplateWhereUniqueInput
    /**
     * In case the NotificationTemplate found by the `where` argument doesn't exist, create a new NotificationTemplate with this data.
     */
    create: XOR<NotificationTemplateCreateInput, NotificationTemplateUncheckedCreateInput>
    /**
     * In case the NotificationTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationTemplateUpdateInput, NotificationTemplateUncheckedUpdateInput>
  }

  /**
   * NotificationTemplate delete
   */
  export type NotificationTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    /**
     * Filter which NotificationTemplate to delete.
     */
    where: NotificationTemplateWhereUniqueInput
  }

  /**
   * NotificationTemplate deleteMany
   */
  export type NotificationTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationTemplates to delete
     */
    where?: NotificationTemplateWhereInput
    /**
     * Limit how many NotificationTemplates to delete.
     */
    limit?: number
  }

  /**
   * NotificationTemplate.rules
   */
  export type NotificationTemplate$rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    where?: NotificationRuleWhereInput
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    cursor?: NotificationRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * NotificationTemplate.notifications
   */
  export type NotificationTemplate$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * NotificationTemplate without action
   */
  export type NotificationTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
  }


  /**
   * Model NotificationRule
   */

  export type AggregateNotificationRule = {
    _count: NotificationRuleCountAggregateOutputType | null
    _avg: NotificationRuleAvgAggregateOutputType | null
    _sum: NotificationRuleSumAggregateOutputType | null
    _min: NotificationRuleMinAggregateOutputType | null
    _max: NotificationRuleMaxAggregateOutputType | null
  }

  export type NotificationRuleAvgAggregateOutputType = {
    delay: number | null
  }

  export type NotificationRuleSumAggregateOutputType = {
    delay: number | null
  }

  export type NotificationRuleMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    trigger: $Enums.RuleTrigger | null
    isActive: boolean | null
    templateId: string | null
    delay: number | null
    createdBy: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationRuleMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    trigger: $Enums.RuleTrigger | null
    isActive: boolean | null
    templateId: string | null
    delay: number | null
    createdBy: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationRuleCountAggregateOutputType = {
    id: number
    name: number
    description: number
    trigger: number
    conditions: number
    isActive: number
    templateId: number
    recipients: number
    delay: number
    createdBy: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationRuleAvgAggregateInputType = {
    delay?: true
  }

  export type NotificationRuleSumAggregateInputType = {
    delay?: true
  }

  export type NotificationRuleMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    trigger?: true
    isActive?: true
    templateId?: true
    delay?: true
    createdBy?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationRuleMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    trigger?: true
    isActive?: true
    templateId?: true
    delay?: true
    createdBy?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationRuleCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    trigger?: true
    conditions?: true
    isActive?: true
    templateId?: true
    recipients?: true
    delay?: true
    createdBy?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRule to aggregate.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationRules
    **/
    _count?: true | NotificationRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationRuleMaxAggregateInputType
  }

  export type GetNotificationRuleAggregateType<T extends NotificationRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationRule[P]>
      : GetScalarType<T[P], AggregateNotificationRule[P]>
  }




  export type NotificationRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRuleWhereInput
    orderBy?: NotificationRuleOrderByWithAggregationInput | NotificationRuleOrderByWithAggregationInput[]
    by: NotificationRuleScalarFieldEnum[] | NotificationRuleScalarFieldEnum
    having?: NotificationRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationRuleCountAggregateInputType | true
    _avg?: NotificationRuleAvgAggregateInputType
    _sum?: NotificationRuleSumAggregateInputType
    _min?: NotificationRuleMinAggregateInputType
    _max?: NotificationRuleMaxAggregateInputType
  }

  export type NotificationRuleGroupByOutputType = {
    id: string
    name: string
    description: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonValue
    isActive: boolean
    templateId: string
    recipients: JsonValue
    delay: number | null
    createdBy: string
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationRuleCountAggregateOutputType | null
    _avg: NotificationRuleAvgAggregateOutputType | null
    _sum: NotificationRuleSumAggregateOutputType | null
    _min: NotificationRuleMinAggregateOutputType | null
    _max: NotificationRuleMaxAggregateOutputType | null
  }

  type GetNotificationRuleGroupByPayload<T extends NotificationRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationRuleGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationRuleGroupByOutputType[P]>
        }
      >
    >


  export type NotificationRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    conditions?: boolean
    isActive?: boolean
    templateId?: boolean
    recipients?: boolean
    delay?: boolean
    createdBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | NotificationRule$notificationsArgs<ExtArgs>
    _count?: boolean | NotificationRuleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRule"]>

  export type NotificationRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    conditions?: boolean
    isActive?: boolean
    templateId?: boolean
    recipients?: boolean
    delay?: boolean
    createdBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRule"]>

  export type NotificationRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    conditions?: boolean
    isActive?: boolean
    templateId?: boolean
    recipients?: boolean
    delay?: boolean
    createdBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRule"]>

  export type NotificationRuleSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    trigger?: boolean
    conditions?: boolean
    isActive?: boolean
    templateId?: boolean
    recipients?: boolean
    delay?: boolean
    createdBy?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "trigger" | "conditions" | "isActive" | "templateId" | "recipients" | "delay" | "createdBy" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationRule"]>
  export type NotificationRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    notifications?: boolean | NotificationRule$notificationsArgs<ExtArgs>
    _count?: boolean | NotificationRuleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    template?: boolean | NotificationTemplateDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationRule"
    objects: {
      template: Prisma.$NotificationTemplatePayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      trigger: $Enums.RuleTrigger
      conditions: Prisma.JsonValue
      isActive: boolean
      templateId: string
      recipients: Prisma.JsonValue
      delay: number | null
      createdBy: string
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationRule"]>
    composites: {}
  }

  type NotificationRuleGetPayload<S extends boolean | null | undefined | NotificationRuleDefaultArgs> = $Result.GetResult<Prisma.$NotificationRulePayload, S>

  type NotificationRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationRuleCountAggregateInputType | true
    }

  export interface NotificationRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationRule'], meta: { name: 'NotificationRule' } }
    /**
     * Find zero or one NotificationRule that matches the filter.
     * @param {NotificationRuleFindUniqueArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationRuleFindUniqueArgs>(args: SelectSubset<T, NotificationRuleFindUniqueArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationRuleFindUniqueOrThrowArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleFindFirstArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationRuleFindFirstArgs>(args?: SelectSubset<T, NotificationRuleFindFirstArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleFindFirstOrThrowArgs} args - Arguments to find a NotificationRule
     * @example
     * // Get one NotificationRule
     * const notificationRule = await prisma.notificationRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationRules
     * const notificationRules = await prisma.notificationRule.findMany()
     * 
     * // Get first 10 NotificationRules
     * const notificationRules = await prisma.notificationRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationRuleWithIdOnly = await prisma.notificationRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationRuleFindManyArgs>(args?: SelectSubset<T, NotificationRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationRule.
     * @param {NotificationRuleCreateArgs} args - Arguments to create a NotificationRule.
     * @example
     * // Create one NotificationRule
     * const NotificationRule = await prisma.notificationRule.create({
     *   data: {
     *     // ... data to create a NotificationRule
     *   }
     * })
     * 
     */
    create<T extends NotificationRuleCreateArgs>(args: SelectSubset<T, NotificationRuleCreateArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationRules.
     * @param {NotificationRuleCreateManyArgs} args - Arguments to create many NotificationRules.
     * @example
     * // Create many NotificationRules
     * const notificationRule = await prisma.notificationRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationRuleCreateManyArgs>(args?: SelectSubset<T, NotificationRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationRules and returns the data saved in the database.
     * @param {NotificationRuleCreateManyAndReturnArgs} args - Arguments to create many NotificationRules.
     * @example
     * // Create many NotificationRules
     * const notificationRule = await prisma.notificationRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationRules and only return the `id`
     * const notificationRuleWithIdOnly = await prisma.notificationRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationRule.
     * @param {NotificationRuleDeleteArgs} args - Arguments to delete one NotificationRule.
     * @example
     * // Delete one NotificationRule
     * const NotificationRule = await prisma.notificationRule.delete({
     *   where: {
     *     // ... filter to delete one NotificationRule
     *   }
     * })
     * 
     */
    delete<T extends NotificationRuleDeleteArgs>(args: SelectSubset<T, NotificationRuleDeleteArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationRule.
     * @param {NotificationRuleUpdateArgs} args - Arguments to update one NotificationRule.
     * @example
     * // Update one NotificationRule
     * const notificationRule = await prisma.notificationRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationRuleUpdateArgs>(args: SelectSubset<T, NotificationRuleUpdateArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationRules.
     * @param {NotificationRuleDeleteManyArgs} args - Arguments to filter NotificationRules to delete.
     * @example
     * // Delete a few NotificationRules
     * const { count } = await prisma.notificationRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationRuleDeleteManyArgs>(args?: SelectSubset<T, NotificationRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationRules
     * const notificationRule = await prisma.notificationRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationRuleUpdateManyArgs>(args: SelectSubset<T, NotificationRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationRules and returns the data updated in the database.
     * @param {NotificationRuleUpdateManyAndReturnArgs} args - Arguments to update many NotificationRules.
     * @example
     * // Update many NotificationRules
     * const notificationRule = await prisma.notificationRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationRules and only return the `id`
     * const notificationRuleWithIdOnly = await prisma.notificationRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationRule.
     * @param {NotificationRuleUpsertArgs} args - Arguments to update or create a NotificationRule.
     * @example
     * // Update or create a NotificationRule
     * const notificationRule = await prisma.notificationRule.upsert({
     *   create: {
     *     // ... data to create a NotificationRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationRule we want to update
     *   }
     * })
     */
    upsert<T extends NotificationRuleUpsertArgs>(args: SelectSubset<T, NotificationRuleUpsertArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleCountArgs} args - Arguments to filter NotificationRules to count.
     * @example
     * // Count the number of NotificationRules
     * const count = await prisma.notificationRule.count({
     *   where: {
     *     // ... the filter for the NotificationRules we want to count
     *   }
     * })
    **/
    count<T extends NotificationRuleCountArgs>(
      args?: Subset<T, NotificationRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationRuleAggregateArgs>(args: Subset<T, NotificationRuleAggregateArgs>): Prisma.PrismaPromise<GetNotificationRuleAggregateType<T>>

    /**
     * Group by NotificationRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationRuleGroupByArgs['orderBy'] }
        : { orderBy?: NotificationRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationRule model
   */
  readonly fields: NotificationRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    template<T extends NotificationTemplateDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationTemplateDefaultArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    notifications<T extends NotificationRule$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, NotificationRule$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationRule model
   */
  interface NotificationRuleFieldRefs {
    readonly id: FieldRef<"NotificationRule", 'String'>
    readonly name: FieldRef<"NotificationRule", 'String'>
    readonly description: FieldRef<"NotificationRule", 'String'>
    readonly trigger: FieldRef<"NotificationRule", 'RuleTrigger'>
    readonly conditions: FieldRef<"NotificationRule", 'Json'>
    readonly isActive: FieldRef<"NotificationRule", 'Boolean'>
    readonly templateId: FieldRef<"NotificationRule", 'String'>
    readonly recipients: FieldRef<"NotificationRule", 'Json'>
    readonly delay: FieldRef<"NotificationRule", 'Int'>
    readonly createdBy: FieldRef<"NotificationRule", 'String'>
    readonly tenantId: FieldRef<"NotificationRule", 'String'>
    readonly isDeleted: FieldRef<"NotificationRule", 'Boolean'>
    readonly deletedAt: FieldRef<"NotificationRule", 'DateTime'>
    readonly deletedBy: FieldRef<"NotificationRule", 'String'>
    readonly createdAt: FieldRef<"NotificationRule", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationRule findUnique
   */
  export type NotificationRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule findUniqueOrThrow
   */
  export type NotificationRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule findFirst
   */
  export type NotificationRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationRules.
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationRules.
     */
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * NotificationRule findFirstOrThrow
   */
  export type NotificationRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRule to fetch.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationRules.
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationRules.
     */
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * NotificationRule findMany
   */
  export type NotificationRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRules to fetch.
     */
    where?: NotificationRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRules to fetch.
     */
    orderBy?: NotificationRuleOrderByWithRelationInput | NotificationRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationRules.
     */
    cursor?: NotificationRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRules.
     */
    skip?: number
    distinct?: NotificationRuleScalarFieldEnum | NotificationRuleScalarFieldEnum[]
  }

  /**
   * NotificationRule create
   */
  export type NotificationRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationRule.
     */
    data: XOR<NotificationRuleCreateInput, NotificationRuleUncheckedCreateInput>
  }

  /**
   * NotificationRule createMany
   */
  export type NotificationRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationRules.
     */
    data: NotificationRuleCreateManyInput | NotificationRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationRule createManyAndReturn
   */
  export type NotificationRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationRules.
     */
    data: NotificationRuleCreateManyInput | NotificationRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRule update
   */
  export type NotificationRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationRule.
     */
    data: XOR<NotificationRuleUpdateInput, NotificationRuleUncheckedUpdateInput>
    /**
     * Choose, which NotificationRule to update.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule updateMany
   */
  export type NotificationRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationRules.
     */
    data: XOR<NotificationRuleUpdateManyMutationInput, NotificationRuleUncheckedUpdateManyInput>
    /**
     * Filter which NotificationRules to update
     */
    where?: NotificationRuleWhereInput
    /**
     * Limit how many NotificationRules to update.
     */
    limit?: number
  }

  /**
   * NotificationRule updateManyAndReturn
   */
  export type NotificationRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * The data used to update NotificationRules.
     */
    data: XOR<NotificationRuleUpdateManyMutationInput, NotificationRuleUncheckedUpdateManyInput>
    /**
     * Filter which NotificationRules to update
     */
    where?: NotificationRuleWhereInput
    /**
     * Limit how many NotificationRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRule upsert
   */
  export type NotificationRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationRule to update in case it exists.
     */
    where: NotificationRuleWhereUniqueInput
    /**
     * In case the NotificationRule found by the `where` argument doesn't exist, create a new NotificationRule with this data.
     */
    create: XOR<NotificationRuleCreateInput, NotificationRuleUncheckedCreateInput>
    /**
     * In case the NotificationRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationRuleUpdateInput, NotificationRuleUncheckedUpdateInput>
  }

  /**
   * NotificationRule delete
   */
  export type NotificationRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    /**
     * Filter which NotificationRule to delete.
     */
    where: NotificationRuleWhereUniqueInput
  }

  /**
   * NotificationRule deleteMany
   */
  export type NotificationRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRules to delete
     */
    where?: NotificationRuleWhereInput
    /**
     * Limit how many NotificationRules to delete.
     */
    limit?: number
  }

  /**
   * NotificationRule.notifications
   */
  export type NotificationRule$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * NotificationRule without action
   */
  export type NotificationRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    status: $Enums.NotificationStatus | null
    subject: string | null
    content: string | null
    recipientId: string | null
    templateId: string | null
    ruleId: string | null
    entityType: string | null
    entityId: string | null
    scheduledAt: Date | null
    sentAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    readAt: Date | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    type: $Enums.NotificationType | null
    status: $Enums.NotificationStatus | null
    subject: string | null
    content: string | null
    recipientId: string | null
    templateId: string | null
    ruleId: string | null
    entityType: string | null
    entityId: string | null
    scheduledAt: Date | null
    sentAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    readAt: Date | null
    tenantId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    type: number
    status: number
    subject: number
    content: number
    recipientId: number
    templateId: number
    ruleId: number
    entityType: number
    entityId: number
    metadata: number
    scheduledAt: number
    sentAt: number
    failedAt: number
    errorMessage: number
    readAt: number
    tenantId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    type?: true
    status?: true
    subject?: true
    content?: true
    recipientId?: true
    templateId?: true
    ruleId?: true
    entityType?: true
    entityId?: true
    scheduledAt?: true
    sentAt?: true
    failedAt?: true
    errorMessage?: true
    readAt?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    type?: true
    status?: true
    subject?: true
    content?: true
    recipientId?: true
    templateId?: true
    ruleId?: true
    entityType?: true
    entityId?: true
    scheduledAt?: true
    sentAt?: true
    failedAt?: true
    errorMessage?: true
    readAt?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    type?: true
    status?: true
    subject?: true
    content?: true
    recipientId?: true
    templateId?: true
    ruleId?: true
    entityType?: true
    entityId?: true
    metadata?: true
    scheduledAt?: true
    sentAt?: true
    failedAt?: true
    errorMessage?: true
    readAt?: true
    tenantId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    type: $Enums.NotificationType
    status: $Enums.NotificationStatus
    subject: string | null
    content: string
    recipientId: string
    templateId: string | null
    ruleId: string | null
    entityType: string | null
    entityId: string | null
    metadata: JsonValue | null
    scheduledAt: Date | null
    sentAt: Date | null
    failedAt: Date | null
    errorMessage: string | null
    readAt: Date | null
    tenantId: string | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    content?: boolean
    recipientId?: boolean
    templateId?: boolean
    ruleId?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    readAt?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Notification$templateArgs<ExtArgs>
    rule?: boolean | Notification$ruleArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    content?: boolean
    recipientId?: boolean
    templateId?: boolean
    ruleId?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    readAt?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Notification$templateArgs<ExtArgs>
    rule?: boolean | Notification$ruleArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    content?: boolean
    recipientId?: boolean
    templateId?: boolean
    ruleId?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    readAt?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Notification$templateArgs<ExtArgs>
    rule?: boolean | Notification$ruleArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    type?: boolean
    status?: boolean
    subject?: boolean
    content?: boolean
    recipientId?: boolean
    templateId?: boolean
    ruleId?: boolean
    entityType?: boolean
    entityId?: boolean
    metadata?: boolean
    scheduledAt?: boolean
    sentAt?: boolean
    failedAt?: boolean
    errorMessage?: boolean
    readAt?: boolean
    tenantId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "status" | "subject" | "content" | "recipientId" | "templateId" | "ruleId" | "entityType" | "entityId" | "metadata" | "scheduledAt" | "sentAt" | "failedAt" | "errorMessage" | "readAt" | "tenantId" | "createdAt" | "updatedAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Notification$templateArgs<ExtArgs>
    rule?: boolean | Notification$ruleArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Notification$templateArgs<ExtArgs>
    rule?: boolean | Notification$ruleArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipient?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | Notification$templateArgs<ExtArgs>
    rule?: boolean | Notification$ruleArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      recipient: Prisma.$UserPayload<ExtArgs>
      template: Prisma.$NotificationTemplatePayload<ExtArgs> | null
      rule: Prisma.$NotificationRulePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.NotificationType
      status: $Enums.NotificationStatus
      subject: string | null
      content: string
      recipientId: string
      templateId: string | null
      ruleId: string | null
      entityType: string | null
      entityId: string | null
      metadata: Prisma.JsonValue | null
      scheduledAt: Date | null
      sentAt: Date | null
      failedAt: Date | null
      errorMessage: string | null
      readAt: Date | null
      tenantId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    recipient<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends Notification$templateArgs<ExtArgs> = {}>(args?: Subset<T, Notification$templateArgs<ExtArgs>>): Prisma__NotificationTemplateClient<$Result.GetResult<Prisma.$NotificationTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rule<T extends Notification$ruleArgs<ExtArgs> = {}>(args?: Subset<T, Notification$ruleArgs<ExtArgs>>): Prisma__NotificationRuleClient<$Result.GetResult<Prisma.$NotificationRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly status: FieldRef<"Notification", 'NotificationStatus'>
    readonly subject: FieldRef<"Notification", 'String'>
    readonly content: FieldRef<"Notification", 'String'>
    readonly recipientId: FieldRef<"Notification", 'String'>
    readonly templateId: FieldRef<"Notification", 'String'>
    readonly ruleId: FieldRef<"Notification", 'String'>
    readonly entityType: FieldRef<"Notification", 'String'>
    readonly entityId: FieldRef<"Notification", 'String'>
    readonly metadata: FieldRef<"Notification", 'Json'>
    readonly scheduledAt: FieldRef<"Notification", 'DateTime'>
    readonly sentAt: FieldRef<"Notification", 'DateTime'>
    readonly failedAt: FieldRef<"Notification", 'DateTime'>
    readonly errorMessage: FieldRef<"Notification", 'String'>
    readonly readAt: FieldRef<"Notification", 'DateTime'>
    readonly tenantId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
    readonly updatedAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.template
   */
  export type Notification$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationTemplate
     */
    select?: NotificationTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationTemplate
     */
    omit?: NotificationTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationTemplateInclude<ExtArgs> | null
    where?: NotificationTemplateWhereInput
  }

  /**
   * Notification.rule
   */
  export type Notification$ruleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRule
     */
    select?: NotificationRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRule
     */
    omit?: NotificationRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRuleInclude<ExtArgs> | null
    where?: NotificationRuleWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Payroll
   */

  export type AggregatePayroll = {
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  export type PayrollAvgAggregateOutputType = {
    totalGrossPay: Decimal | null
    totalDeductions: Decimal | null
    totalNetPay: Decimal | null
  }

  export type PayrollSumAggregateOutputType = {
    totalGrossPay: Decimal | null
    totalDeductions: Decimal | null
    totalNetPay: Decimal | null
  }

  export type PayrollMinAggregateOutputType = {
    id: string | null
    runDate: Date | null
    payPeriodStart: Date | null
    payPeriodEnd: Date | null
    status: $Enums.PayrollStatus | null
    totalGrossPay: Decimal | null
    totalDeductions: Decimal | null
    totalNetPay: Decimal | null
    notes: string | null
    approvedBy: string | null
    approvedAt: Date | null
    processedBy: string | null
    processedAt: Date | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollMaxAggregateOutputType = {
    id: string | null
    runDate: Date | null
    payPeriodStart: Date | null
    payPeriodEnd: Date | null
    status: $Enums.PayrollStatus | null
    totalGrossPay: Decimal | null
    totalDeductions: Decimal | null
    totalNetPay: Decimal | null
    notes: string | null
    approvedBy: string | null
    approvedAt: Date | null
    processedBy: string | null
    processedAt: Date | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollCountAggregateOutputType = {
    id: number
    runDate: number
    payPeriodStart: number
    payPeriodEnd: number
    status: number
    totalGrossPay: number
    totalDeductions: number
    totalNetPay: number
    notes: number
    approvedBy: number
    approvedAt: number
    processedBy: number
    processedAt: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollAvgAggregateInputType = {
    totalGrossPay?: true
    totalDeductions?: true
    totalNetPay?: true
  }

  export type PayrollSumAggregateInputType = {
    totalGrossPay?: true
    totalDeductions?: true
    totalNetPay?: true
  }

  export type PayrollMinAggregateInputType = {
    id?: true
    runDate?: true
    payPeriodStart?: true
    payPeriodEnd?: true
    status?: true
    totalGrossPay?: true
    totalDeductions?: true
    totalNetPay?: true
    notes?: true
    approvedBy?: true
    approvedAt?: true
    processedBy?: true
    processedAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollMaxAggregateInputType = {
    id?: true
    runDate?: true
    payPeriodStart?: true
    payPeriodEnd?: true
    status?: true
    totalGrossPay?: true
    totalDeductions?: true
    totalNetPay?: true
    notes?: true
    approvedBy?: true
    approvedAt?: true
    processedBy?: true
    processedAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollCountAggregateInputType = {
    id?: true
    runDate?: true
    payPeriodStart?: true
    payPeriodEnd?: true
    status?: true
    totalGrossPay?: true
    totalDeductions?: true
    totalNetPay?: true
    notes?: true
    approvedBy?: true
    approvedAt?: true
    processedBy?: true
    processedAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payroll to aggregate.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payrolls
    **/
    _count?: true | PayrollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollMaxAggregateInputType
  }

  export type GetPayrollAggregateType<T extends PayrollAggregateArgs> = {
        [P in keyof T & keyof AggregatePayroll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayroll[P]>
      : GetScalarType<T[P], AggregatePayroll[P]>
  }




  export type PayrollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithAggregationInput | PayrollOrderByWithAggregationInput[]
    by: PayrollScalarFieldEnum[] | PayrollScalarFieldEnum
    having?: PayrollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollCountAggregateInputType | true
    _avg?: PayrollAvgAggregateInputType
    _sum?: PayrollSumAggregateInputType
    _min?: PayrollMinAggregateInputType
    _max?: PayrollMaxAggregateInputType
  }

  export type PayrollGroupByOutputType = {
    id: string
    runDate: Date
    payPeriodStart: Date
    payPeriodEnd: Date
    status: $Enums.PayrollStatus
    totalGrossPay: Decimal
    totalDeductions: Decimal
    totalNetPay: Decimal
    notes: string | null
    approvedBy: string | null
    approvedAt: Date | null
    processedBy: string | null
    processedAt: Date | null
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  type GetPayrollGroupByPayload<T extends PayrollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollGroupByOutputType[P]>
        }
      >
    >


  export type PayrollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runDate?: boolean
    payPeriodStart?: boolean
    payPeriodEnd?: boolean
    status?: boolean
    totalGrossPay?: boolean
    totalDeductions?: boolean
    totalNetPay?: boolean
    notes?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    processedBy?: boolean
    processedAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approver?: boolean | Payroll$approverArgs<ExtArgs>
    processor?: boolean | Payroll$processorArgs<ExtArgs>
    payrollEntries?: boolean | Payroll$payrollEntriesArgs<ExtArgs>
    transactions?: boolean | Payroll$transactionsArgs<ExtArgs>
    _count?: boolean | PayrollCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runDate?: boolean
    payPeriodStart?: boolean
    payPeriodEnd?: boolean
    status?: boolean
    totalGrossPay?: boolean
    totalDeductions?: boolean
    totalNetPay?: boolean
    notes?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    processedBy?: boolean
    processedAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approver?: boolean | Payroll$approverArgs<ExtArgs>
    processor?: boolean | Payroll$processorArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    runDate?: boolean
    payPeriodStart?: boolean
    payPeriodEnd?: boolean
    status?: boolean
    totalGrossPay?: boolean
    totalDeductions?: boolean
    totalNetPay?: boolean
    notes?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    processedBy?: boolean
    processedAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    approver?: boolean | Payroll$approverArgs<ExtArgs>
    processor?: boolean | Payroll$processorArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectScalar = {
    id?: boolean
    runDate?: boolean
    payPeriodStart?: boolean
    payPeriodEnd?: boolean
    status?: boolean
    totalGrossPay?: boolean
    totalDeductions?: boolean
    totalNetPay?: boolean
    notes?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    processedBy?: boolean
    processedAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "runDate" | "payPeriodStart" | "payPeriodEnd" | "status" | "totalGrossPay" | "totalDeductions" | "totalNetPay" | "notes" | "approvedBy" | "approvedAt" | "processedBy" | "processedAt" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["payroll"]>
  export type PayrollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | Payroll$approverArgs<ExtArgs>
    processor?: boolean | Payroll$processorArgs<ExtArgs>
    payrollEntries?: boolean | Payroll$payrollEntriesArgs<ExtArgs>
    transactions?: boolean | Payroll$transactionsArgs<ExtArgs>
    _count?: boolean | PayrollCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayrollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | Payroll$approverArgs<ExtArgs>
    processor?: boolean | Payroll$processorArgs<ExtArgs>
  }
  export type PayrollIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    approver?: boolean | Payroll$approverArgs<ExtArgs>
    processor?: boolean | Payroll$processorArgs<ExtArgs>
  }

  export type $PayrollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payroll"
    objects: {
      approver: Prisma.$UserPayload<ExtArgs> | null
      processor: Prisma.$UserPayload<ExtArgs> | null
      payrollEntries: Prisma.$PayrollEntryPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      runDate: Date
      payPeriodStart: Date
      payPeriodEnd: Date
      status: $Enums.PayrollStatus
      totalGrossPay: Prisma.Decimal
      totalDeductions: Prisma.Decimal
      totalNetPay: Prisma.Decimal
      notes: string | null
      approvedBy: string | null
      approvedAt: Date | null
      processedBy: string | null
      processedAt: Date | null
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payroll"]>
    composites: {}
  }

  type PayrollGetPayload<S extends boolean | null | undefined | PayrollDefaultArgs> = $Result.GetResult<Prisma.$PayrollPayload, S>

  type PayrollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollCountAggregateInputType | true
    }

  export interface PayrollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payroll'], meta: { name: 'Payroll' } }
    /**
     * Find zero or one Payroll that matches the filter.
     * @param {PayrollFindUniqueArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollFindUniqueArgs>(args: SelectSubset<T, PayrollFindUniqueArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payroll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollFindUniqueOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollFindFirstArgs>(args?: SelectSubset<T, PayrollFindFirstArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payrolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payrolls
     * const payrolls = await prisma.payroll.findMany()
     * 
     * // Get first 10 Payrolls
     * const payrolls = await prisma.payroll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollWithIdOnly = await prisma.payroll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollFindManyArgs>(args?: SelectSubset<T, PayrollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payroll.
     * @param {PayrollCreateArgs} args - Arguments to create a Payroll.
     * @example
     * // Create one Payroll
     * const Payroll = await prisma.payroll.create({
     *   data: {
     *     // ... data to create a Payroll
     *   }
     * })
     * 
     */
    create<T extends PayrollCreateArgs>(args: SelectSubset<T, PayrollCreateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payrolls.
     * @param {PayrollCreateManyArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollCreateManyArgs>(args?: SelectSubset<T, PayrollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payrolls and returns the data saved in the database.
     * @param {PayrollCreateManyAndReturnArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payroll.
     * @param {PayrollDeleteArgs} args - Arguments to delete one Payroll.
     * @example
     * // Delete one Payroll
     * const Payroll = await prisma.payroll.delete({
     *   where: {
     *     // ... filter to delete one Payroll
     *   }
     * })
     * 
     */
    delete<T extends PayrollDeleteArgs>(args: SelectSubset<T, PayrollDeleteArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payroll.
     * @param {PayrollUpdateArgs} args - Arguments to update one Payroll.
     * @example
     * // Update one Payroll
     * const payroll = await prisma.payroll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollUpdateArgs>(args: SelectSubset<T, PayrollUpdateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payrolls.
     * @param {PayrollDeleteManyArgs} args - Arguments to filter Payrolls to delete.
     * @example
     * // Delete a few Payrolls
     * const { count } = await prisma.payroll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollDeleteManyArgs>(args?: SelectSubset<T, PayrollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollUpdateManyArgs>(args: SelectSubset<T, PayrollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls and returns the data updated in the database.
     * @param {PayrollUpdateManyAndReturnArgs} args - Arguments to update many Payrolls.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payroll.
     * @param {PayrollUpsertArgs} args - Arguments to update or create a Payroll.
     * @example
     * // Update or create a Payroll
     * const payroll = await prisma.payroll.upsert({
     *   create: {
     *     // ... data to create a Payroll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payroll we want to update
     *   }
     * })
     */
    upsert<T extends PayrollUpsertArgs>(args: SelectSubset<T, PayrollUpsertArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollCountArgs} args - Arguments to filter Payrolls to count.
     * @example
     * // Count the number of Payrolls
     * const count = await prisma.payroll.count({
     *   where: {
     *     // ... the filter for the Payrolls we want to count
     *   }
     * })
    **/
    count<T extends PayrollCountArgs>(
      args?: Subset<T, PayrollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollAggregateArgs>(args: Subset<T, PayrollAggregateArgs>): Prisma.PrismaPromise<GetPayrollAggregateType<T>>

    /**
     * Group by Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollGroupByArgs['orderBy'] }
        : { orderBy?: PayrollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payroll model
   */
  readonly fields: PayrollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payroll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    approver<T extends Payroll$approverArgs<ExtArgs> = {}>(args?: Subset<T, Payroll$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    processor<T extends Payroll$processorArgs<ExtArgs> = {}>(args?: Subset<T, Payroll$processorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payrollEntries<T extends Payroll$payrollEntriesArgs<ExtArgs> = {}>(args?: Subset<T, Payroll$payrollEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends Payroll$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, Payroll$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payroll model
   */
  interface PayrollFieldRefs {
    readonly id: FieldRef<"Payroll", 'String'>
    readonly runDate: FieldRef<"Payroll", 'DateTime'>
    readonly payPeriodStart: FieldRef<"Payroll", 'DateTime'>
    readonly payPeriodEnd: FieldRef<"Payroll", 'DateTime'>
    readonly status: FieldRef<"Payroll", 'PayrollStatus'>
    readonly totalGrossPay: FieldRef<"Payroll", 'Decimal'>
    readonly totalDeductions: FieldRef<"Payroll", 'Decimal'>
    readonly totalNetPay: FieldRef<"Payroll", 'Decimal'>
    readonly notes: FieldRef<"Payroll", 'String'>
    readonly approvedBy: FieldRef<"Payroll", 'String'>
    readonly approvedAt: FieldRef<"Payroll", 'DateTime'>
    readonly processedBy: FieldRef<"Payroll", 'String'>
    readonly processedAt: FieldRef<"Payroll", 'DateTime'>
    readonly tenantId: FieldRef<"Payroll", 'String'>
    readonly isDeleted: FieldRef<"Payroll", 'Boolean'>
    readonly deletedAt: FieldRef<"Payroll", 'DateTime'>
    readonly deletedBy: FieldRef<"Payroll", 'String'>
    readonly createdBy: FieldRef<"Payroll", 'String'>
    readonly createdAt: FieldRef<"Payroll", 'DateTime'>
    readonly updatedAt: FieldRef<"Payroll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payroll findUnique
   */
  export type PayrollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findUniqueOrThrow
   */
  export type PayrollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findFirst
   */
  export type PayrollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findFirstOrThrow
   */
  export type PayrollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findMany
   */
  export type PayrollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payrolls to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll create
   */
  export type PayrollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to create a Payroll.
     */
    data: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
  }

  /**
   * Payroll createMany
   */
  export type PayrollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payroll createManyAndReturn
   */
  export type PayrollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payroll update
   */
  export type PayrollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to update a Payroll.
     */
    data: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
    /**
     * Choose, which Payroll to update.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll updateMany
   */
  export type PayrollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to update.
     */
    limit?: number
  }

  /**
   * Payroll updateManyAndReturn
   */
  export type PayrollUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payroll upsert
   */
  export type PayrollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The filter to search for the Payroll to update in case it exists.
     */
    where: PayrollWhereUniqueInput
    /**
     * In case the Payroll found by the `where` argument doesn't exist, create a new Payroll with this data.
     */
    create: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
    /**
     * In case the Payroll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
  }

  /**
   * Payroll delete
   */
  export type PayrollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter which Payroll to delete.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll deleteMany
   */
  export type PayrollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payrolls to delete
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to delete.
     */
    limit?: number
  }

  /**
   * Payroll.approver
   */
  export type Payroll$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payroll.processor
   */
  export type Payroll$processorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Payroll.payrollEntries
   */
  export type Payroll$payrollEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    where?: PayrollEntryWhereInput
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    cursor?: PayrollEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * Payroll.transactions
   */
  export type Payroll$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Payroll without action
   */
  export type PayrollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
  }


  /**
   * Model PayrollEntry
   */

  export type AggregatePayrollEntry = {
    _count: PayrollEntryCountAggregateOutputType | null
    _avg: PayrollEntryAvgAggregateOutputType | null
    _sum: PayrollEntrySumAggregateOutputType | null
    _min: PayrollEntryMinAggregateOutputType | null
    _max: PayrollEntryMaxAggregateOutputType | null
  }

  export type PayrollEntryAvgAggregateOutputType = {
    baseSalary: Decimal | null
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    bonusAmount: Decimal | null
    allowances: Decimal | null
    grossPay: Decimal | null
    taxDeductions: Decimal | null
    socialSecurity: Decimal | null
    otherDeductions: Decimal | null
    netPay: Decimal | null
  }

  export type PayrollEntrySumAggregateOutputType = {
    baseSalary: Decimal | null
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    bonusAmount: Decimal | null
    allowances: Decimal | null
    grossPay: Decimal | null
    taxDeductions: Decimal | null
    socialSecurity: Decimal | null
    otherDeductions: Decimal | null
    netPay: Decimal | null
  }

  export type PayrollEntryMinAggregateOutputType = {
    id: string | null
    payrollId: string | null
    employeeId: string | null
    baseSalary: Decimal | null
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    bonusAmount: Decimal | null
    allowances: Decimal | null
    grossPay: Decimal | null
    taxDeductions: Decimal | null
    socialSecurity: Decimal | null
    otherDeductions: Decimal | null
    netPay: Decimal | null
    notes: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollEntryMaxAggregateOutputType = {
    id: string | null
    payrollId: string | null
    employeeId: string | null
    baseSalary: Decimal | null
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    bonusAmount: Decimal | null
    allowances: Decimal | null
    grossPay: Decimal | null
    taxDeductions: Decimal | null
    socialSecurity: Decimal | null
    otherDeductions: Decimal | null
    netPay: Decimal | null
    notes: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollEntryCountAggregateOutputType = {
    id: number
    payrollId: number
    employeeId: number
    baseSalary: number
    hoursWorked: number
    overtimeHours: number
    bonusAmount: number
    allowances: number
    grossPay: number
    taxDeductions: number
    socialSecurity: number
    otherDeductions: number
    netPay: number
    notes: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollEntryAvgAggregateInputType = {
    baseSalary?: true
    hoursWorked?: true
    overtimeHours?: true
    bonusAmount?: true
    allowances?: true
    grossPay?: true
    taxDeductions?: true
    socialSecurity?: true
    otherDeductions?: true
    netPay?: true
  }

  export type PayrollEntrySumAggregateInputType = {
    baseSalary?: true
    hoursWorked?: true
    overtimeHours?: true
    bonusAmount?: true
    allowances?: true
    grossPay?: true
    taxDeductions?: true
    socialSecurity?: true
    otherDeductions?: true
    netPay?: true
  }

  export type PayrollEntryMinAggregateInputType = {
    id?: true
    payrollId?: true
    employeeId?: true
    baseSalary?: true
    hoursWorked?: true
    overtimeHours?: true
    bonusAmount?: true
    allowances?: true
    grossPay?: true
    taxDeductions?: true
    socialSecurity?: true
    otherDeductions?: true
    netPay?: true
    notes?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollEntryMaxAggregateInputType = {
    id?: true
    payrollId?: true
    employeeId?: true
    baseSalary?: true
    hoursWorked?: true
    overtimeHours?: true
    bonusAmount?: true
    allowances?: true
    grossPay?: true
    taxDeductions?: true
    socialSecurity?: true
    otherDeductions?: true
    netPay?: true
    notes?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollEntryCountAggregateInputType = {
    id?: true
    payrollId?: true
    employeeId?: true
    baseSalary?: true
    hoursWorked?: true
    overtimeHours?: true
    bonusAmount?: true
    allowances?: true
    grossPay?: true
    taxDeductions?: true
    socialSecurity?: true
    otherDeductions?: true
    netPay?: true
    notes?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollEntry to aggregate.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollEntries
    **/
    _count?: true | PayrollEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollEntryMaxAggregateInputType
  }

  export type GetPayrollEntryAggregateType<T extends PayrollEntryAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollEntry[P]>
      : GetScalarType<T[P], AggregatePayrollEntry[P]>
  }




  export type PayrollEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollEntryWhereInput
    orderBy?: PayrollEntryOrderByWithAggregationInput | PayrollEntryOrderByWithAggregationInput[]
    by: PayrollEntryScalarFieldEnum[] | PayrollEntryScalarFieldEnum
    having?: PayrollEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollEntryCountAggregateInputType | true
    _avg?: PayrollEntryAvgAggregateInputType
    _sum?: PayrollEntrySumAggregateInputType
    _min?: PayrollEntryMinAggregateInputType
    _max?: PayrollEntryMaxAggregateInputType
  }

  export type PayrollEntryGroupByOutputType = {
    id: string
    payrollId: string
    employeeId: string
    baseSalary: Decimal
    hoursWorked: Decimal | null
    overtimeHours: Decimal | null
    bonusAmount: Decimal | null
    allowances: Decimal | null
    grossPay: Decimal
    taxDeductions: Decimal
    socialSecurity: Decimal
    otherDeductions: Decimal | null
    netPay: Decimal
    notes: string | null
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollEntryCountAggregateOutputType | null
    _avg: PayrollEntryAvgAggregateOutputType | null
    _sum: PayrollEntrySumAggregateOutputType | null
    _min: PayrollEntryMinAggregateOutputType | null
    _max: PayrollEntryMaxAggregateOutputType | null
  }

  type GetPayrollEntryGroupByPayload<T extends PayrollEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollEntryGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollEntryGroupByOutputType[P]>
        }
      >
    >


  export type PayrollEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payrollId?: boolean
    employeeId?: boolean
    baseSalary?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    bonusAmount?: boolean
    allowances?: boolean
    grossPay?: boolean
    taxDeductions?: boolean
    socialSecurity?: boolean
    otherDeductions?: boolean
    netPay?: boolean
    notes?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollEntry"]>

  export type PayrollEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payrollId?: boolean
    employeeId?: boolean
    baseSalary?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    bonusAmount?: boolean
    allowances?: boolean
    grossPay?: boolean
    taxDeductions?: boolean
    socialSecurity?: boolean
    otherDeductions?: boolean
    netPay?: boolean
    notes?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollEntry"]>

  export type PayrollEntrySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payrollId?: boolean
    employeeId?: boolean
    baseSalary?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    bonusAmount?: boolean
    allowances?: boolean
    grossPay?: boolean
    taxDeductions?: boolean
    socialSecurity?: boolean
    otherDeductions?: boolean
    netPay?: boolean
    notes?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollEntry"]>

  export type PayrollEntrySelectScalar = {
    id?: boolean
    payrollId?: boolean
    employeeId?: boolean
    baseSalary?: boolean
    hoursWorked?: boolean
    overtimeHours?: boolean
    bonusAmount?: boolean
    allowances?: boolean
    grossPay?: boolean
    taxDeductions?: boolean
    socialSecurity?: boolean
    otherDeductions?: boolean
    netPay?: boolean
    notes?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollEntryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "payrollId" | "employeeId" | "baseSalary" | "hoursWorked" | "overtimeHours" | "bonusAmount" | "allowances" | "grossPay" | "taxDeductions" | "socialSecurity" | "otherDeductions" | "netPay" | "notes" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["payrollEntry"]>
  export type PayrollEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PayrollEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PayrollEntryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PayrollEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollEntry"
    objects: {
      payroll: Prisma.$PayrollPayload<ExtArgs>
      employee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      payrollId: string
      employeeId: string
      baseSalary: Prisma.Decimal
      hoursWorked: Prisma.Decimal | null
      overtimeHours: Prisma.Decimal | null
      bonusAmount: Prisma.Decimal | null
      allowances: Prisma.Decimal | null
      grossPay: Prisma.Decimal
      taxDeductions: Prisma.Decimal
      socialSecurity: Prisma.Decimal
      otherDeductions: Prisma.Decimal | null
      netPay: Prisma.Decimal
      notes: string | null
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payrollEntry"]>
    composites: {}
  }

  type PayrollEntryGetPayload<S extends boolean | null | undefined | PayrollEntryDefaultArgs> = $Result.GetResult<Prisma.$PayrollEntryPayload, S>

  type PayrollEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollEntryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollEntryCountAggregateInputType | true
    }

  export interface PayrollEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollEntry'], meta: { name: 'PayrollEntry' } }
    /**
     * Find zero or one PayrollEntry that matches the filter.
     * @param {PayrollEntryFindUniqueArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollEntryFindUniqueArgs>(args: SelectSubset<T, PayrollEntryFindUniqueArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayrollEntry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollEntryFindUniqueOrThrowArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryFindFirstArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollEntryFindFirstArgs>(args?: SelectSubset<T, PayrollEntryFindFirstArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryFindFirstOrThrowArgs} args - Arguments to find a PayrollEntry
     * @example
     * // Get one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayrollEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollEntries
     * const payrollEntries = await prisma.payrollEntry.findMany()
     * 
     * // Get first 10 PayrollEntries
     * const payrollEntries = await prisma.payrollEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollEntryWithIdOnly = await prisma.payrollEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollEntryFindManyArgs>(args?: SelectSubset<T, PayrollEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayrollEntry.
     * @param {PayrollEntryCreateArgs} args - Arguments to create a PayrollEntry.
     * @example
     * // Create one PayrollEntry
     * const PayrollEntry = await prisma.payrollEntry.create({
     *   data: {
     *     // ... data to create a PayrollEntry
     *   }
     * })
     * 
     */
    create<T extends PayrollEntryCreateArgs>(args: SelectSubset<T, PayrollEntryCreateArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayrollEntries.
     * @param {PayrollEntryCreateManyArgs} args - Arguments to create many PayrollEntries.
     * @example
     * // Create many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollEntryCreateManyArgs>(args?: SelectSubset<T, PayrollEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollEntries and returns the data saved in the database.
     * @param {PayrollEntryCreateManyAndReturnArgs} args - Arguments to create many PayrollEntries.
     * @example
     * // Create many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollEntries and only return the `id`
     * const payrollEntryWithIdOnly = await prisma.payrollEntry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayrollEntry.
     * @param {PayrollEntryDeleteArgs} args - Arguments to delete one PayrollEntry.
     * @example
     * // Delete one PayrollEntry
     * const PayrollEntry = await prisma.payrollEntry.delete({
     *   where: {
     *     // ... filter to delete one PayrollEntry
     *   }
     * })
     * 
     */
    delete<T extends PayrollEntryDeleteArgs>(args: SelectSubset<T, PayrollEntryDeleteArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayrollEntry.
     * @param {PayrollEntryUpdateArgs} args - Arguments to update one PayrollEntry.
     * @example
     * // Update one PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollEntryUpdateArgs>(args: SelectSubset<T, PayrollEntryUpdateArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayrollEntries.
     * @param {PayrollEntryDeleteManyArgs} args - Arguments to filter PayrollEntries to delete.
     * @example
     * // Delete a few PayrollEntries
     * const { count } = await prisma.payrollEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollEntryDeleteManyArgs>(args?: SelectSubset<T, PayrollEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollEntryUpdateManyArgs>(args: SelectSubset<T, PayrollEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollEntries and returns the data updated in the database.
     * @param {PayrollEntryUpdateManyAndReturnArgs} args - Arguments to update many PayrollEntries.
     * @example
     * // Update many PayrollEntries
     * const payrollEntry = await prisma.payrollEntry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayrollEntries and only return the `id`
     * const payrollEntryWithIdOnly = await prisma.payrollEntry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollEntryUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollEntryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayrollEntry.
     * @param {PayrollEntryUpsertArgs} args - Arguments to update or create a PayrollEntry.
     * @example
     * // Update or create a PayrollEntry
     * const payrollEntry = await prisma.payrollEntry.upsert({
     *   create: {
     *     // ... data to create a PayrollEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollEntry we want to update
     *   }
     * })
     */
    upsert<T extends PayrollEntryUpsertArgs>(args: SelectSubset<T, PayrollEntryUpsertArgs<ExtArgs>>): Prisma__PayrollEntryClient<$Result.GetResult<Prisma.$PayrollEntryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayrollEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryCountArgs} args - Arguments to filter PayrollEntries to count.
     * @example
     * // Count the number of PayrollEntries
     * const count = await prisma.payrollEntry.count({
     *   where: {
     *     // ... the filter for the PayrollEntries we want to count
     *   }
     * })
    **/
    count<T extends PayrollEntryCountArgs>(
      args?: Subset<T, PayrollEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollEntryAggregateArgs>(args: Subset<T, PayrollEntryAggregateArgs>): Prisma.PrismaPromise<GetPayrollEntryAggregateType<T>>

    /**
     * Group by PayrollEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollEntryGroupByArgs['orderBy'] }
        : { orderBy?: PayrollEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollEntry model
   */
  readonly fields: PayrollEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payroll<T extends PayrollDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PayrollDefaultArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollEntry model
   */
  interface PayrollEntryFieldRefs {
    readonly id: FieldRef<"PayrollEntry", 'String'>
    readonly payrollId: FieldRef<"PayrollEntry", 'String'>
    readonly employeeId: FieldRef<"PayrollEntry", 'String'>
    readonly baseSalary: FieldRef<"PayrollEntry", 'Decimal'>
    readonly hoursWorked: FieldRef<"PayrollEntry", 'Decimal'>
    readonly overtimeHours: FieldRef<"PayrollEntry", 'Decimal'>
    readonly bonusAmount: FieldRef<"PayrollEntry", 'Decimal'>
    readonly allowances: FieldRef<"PayrollEntry", 'Decimal'>
    readonly grossPay: FieldRef<"PayrollEntry", 'Decimal'>
    readonly taxDeductions: FieldRef<"PayrollEntry", 'Decimal'>
    readonly socialSecurity: FieldRef<"PayrollEntry", 'Decimal'>
    readonly otherDeductions: FieldRef<"PayrollEntry", 'Decimal'>
    readonly netPay: FieldRef<"PayrollEntry", 'Decimal'>
    readonly notes: FieldRef<"PayrollEntry", 'String'>
    readonly tenantId: FieldRef<"PayrollEntry", 'String'>
    readonly isDeleted: FieldRef<"PayrollEntry", 'Boolean'>
    readonly deletedAt: FieldRef<"PayrollEntry", 'DateTime'>
    readonly deletedBy: FieldRef<"PayrollEntry", 'String'>
    readonly createdBy: FieldRef<"PayrollEntry", 'String'>
    readonly createdAt: FieldRef<"PayrollEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"PayrollEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayrollEntry findUnique
   */
  export type PayrollEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry findUniqueOrThrow
   */
  export type PayrollEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry findFirst
   */
  export type PayrollEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollEntries.
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollEntries.
     */
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollEntry findFirstOrThrow
   */
  export type PayrollEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntry to fetch.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollEntries.
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollEntries.
     */
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollEntry findMany
   */
  export type PayrollEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter, which PayrollEntries to fetch.
     */
    where?: PayrollEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollEntries to fetch.
     */
    orderBy?: PayrollEntryOrderByWithRelationInput | PayrollEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollEntries.
     */
    cursor?: PayrollEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollEntries.
     */
    skip?: number
    distinct?: PayrollEntryScalarFieldEnum | PayrollEntryScalarFieldEnum[]
  }

  /**
   * PayrollEntry create
   */
  export type PayrollEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollEntry.
     */
    data: XOR<PayrollEntryCreateInput, PayrollEntryUncheckedCreateInput>
  }

  /**
   * PayrollEntry createMany
   */
  export type PayrollEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollEntries.
     */
    data: PayrollEntryCreateManyInput | PayrollEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayrollEntry createManyAndReturn
   */
  export type PayrollEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * The data used to create many PayrollEntries.
     */
    data: PayrollEntryCreateManyInput | PayrollEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollEntry update
   */
  export type PayrollEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollEntry.
     */
    data: XOR<PayrollEntryUpdateInput, PayrollEntryUncheckedUpdateInput>
    /**
     * Choose, which PayrollEntry to update.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry updateMany
   */
  export type PayrollEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollEntries.
     */
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyInput>
    /**
     * Filter which PayrollEntries to update
     */
    where?: PayrollEntryWhereInput
    /**
     * Limit how many PayrollEntries to update.
     */
    limit?: number
  }

  /**
   * PayrollEntry updateManyAndReturn
   */
  export type PayrollEntryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * The data used to update PayrollEntries.
     */
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyInput>
    /**
     * Filter which PayrollEntries to update
     */
    where?: PayrollEntryWhereInput
    /**
     * Limit how many PayrollEntries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollEntry upsert
   */
  export type PayrollEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollEntry to update in case it exists.
     */
    where: PayrollEntryWhereUniqueInput
    /**
     * In case the PayrollEntry found by the `where` argument doesn't exist, create a new PayrollEntry with this data.
     */
    create: XOR<PayrollEntryCreateInput, PayrollEntryUncheckedCreateInput>
    /**
     * In case the PayrollEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollEntryUpdateInput, PayrollEntryUncheckedUpdateInput>
  }

  /**
   * PayrollEntry delete
   */
  export type PayrollEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
    /**
     * Filter which PayrollEntry to delete.
     */
    where: PayrollEntryWhereUniqueInput
  }

  /**
   * PayrollEntry deleteMany
   */
  export type PayrollEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollEntries to delete
     */
    where?: PayrollEntryWhereInput
    /**
     * Limit how many PayrollEntries to delete.
     */
    limit?: number
  }

  /**
   * PayrollEntry without action
   */
  export type PayrollEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollEntry
     */
    select?: PayrollEntrySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollEntry
     */
    omit?: PayrollEntryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollEntryInclude<ExtArgs> | null
  }


  /**
   * Model SalaryAdjustment
   */

  export type AggregateSalaryAdjustment = {
    _count: SalaryAdjustmentCountAggregateOutputType | null
    _avg: SalaryAdjustmentAvgAggregateOutputType | null
    _sum: SalaryAdjustmentSumAggregateOutputType | null
    _min: SalaryAdjustmentMinAggregateOutputType | null
    _max: SalaryAdjustmentMaxAggregateOutputType | null
  }

  export type SalaryAdjustmentAvgAggregateOutputType = {
    previousAmount: Decimal | null
    newAmount: Decimal | null
  }

  export type SalaryAdjustmentSumAggregateOutputType = {
    previousAmount: Decimal | null
    newAmount: Decimal | null
  }

  export type SalaryAdjustmentMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    adjustmentType: $Enums.SalaryAdjustmentType | null
    previousAmount: Decimal | null
    newAmount: Decimal | null
    effectiveDate: Date | null
    reason: string | null
    notes: string | null
    approvedBy: string | null
    approvedAt: Date | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryAdjustmentMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    adjustmentType: $Enums.SalaryAdjustmentType | null
    previousAmount: Decimal | null
    newAmount: Decimal | null
    effectiveDate: Date | null
    reason: string | null
    notes: string | null
    approvedBy: string | null
    approvedAt: Date | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SalaryAdjustmentCountAggregateOutputType = {
    id: number
    employeeId: number
    adjustmentType: number
    previousAmount: number
    newAmount: number
    effectiveDate: number
    reason: number
    notes: number
    approvedBy: number
    approvedAt: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SalaryAdjustmentAvgAggregateInputType = {
    previousAmount?: true
    newAmount?: true
  }

  export type SalaryAdjustmentSumAggregateInputType = {
    previousAmount?: true
    newAmount?: true
  }

  export type SalaryAdjustmentMinAggregateInputType = {
    id?: true
    employeeId?: true
    adjustmentType?: true
    previousAmount?: true
    newAmount?: true
    effectiveDate?: true
    reason?: true
    notes?: true
    approvedBy?: true
    approvedAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryAdjustmentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    adjustmentType?: true
    previousAmount?: true
    newAmount?: true
    effectiveDate?: true
    reason?: true
    notes?: true
    approvedBy?: true
    approvedAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SalaryAdjustmentCountAggregateInputType = {
    id?: true
    employeeId?: true
    adjustmentType?: true
    previousAmount?: true
    newAmount?: true
    effectiveDate?: true
    reason?: true
    notes?: true
    approvedBy?: true
    approvedAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SalaryAdjustmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryAdjustment to aggregate.
     */
    where?: SalaryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryAdjustments to fetch.
     */
    orderBy?: SalaryAdjustmentOrderByWithRelationInput | SalaryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SalaryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SalaryAdjustments
    **/
    _count?: true | SalaryAdjustmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SalaryAdjustmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SalaryAdjustmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SalaryAdjustmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SalaryAdjustmentMaxAggregateInputType
  }

  export type GetSalaryAdjustmentAggregateType<T extends SalaryAdjustmentAggregateArgs> = {
        [P in keyof T & keyof AggregateSalaryAdjustment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalaryAdjustment[P]>
      : GetScalarType<T[P], AggregateSalaryAdjustment[P]>
  }




  export type SalaryAdjustmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SalaryAdjustmentWhereInput
    orderBy?: SalaryAdjustmentOrderByWithAggregationInput | SalaryAdjustmentOrderByWithAggregationInput[]
    by: SalaryAdjustmentScalarFieldEnum[] | SalaryAdjustmentScalarFieldEnum
    having?: SalaryAdjustmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SalaryAdjustmentCountAggregateInputType | true
    _avg?: SalaryAdjustmentAvgAggregateInputType
    _sum?: SalaryAdjustmentSumAggregateInputType
    _min?: SalaryAdjustmentMinAggregateInputType
    _max?: SalaryAdjustmentMaxAggregateInputType
  }

  export type SalaryAdjustmentGroupByOutputType = {
    id: string
    employeeId: string
    adjustmentType: $Enums.SalaryAdjustmentType
    previousAmount: Decimal
    newAmount: Decimal
    effectiveDate: Date
    reason: string
    notes: string | null
    approvedBy: string | null
    approvedAt: Date | null
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: SalaryAdjustmentCountAggregateOutputType | null
    _avg: SalaryAdjustmentAvgAggregateOutputType | null
    _sum: SalaryAdjustmentSumAggregateOutputType | null
    _min: SalaryAdjustmentMinAggregateOutputType | null
    _max: SalaryAdjustmentMaxAggregateOutputType | null
  }

  type GetSalaryAdjustmentGroupByPayload<T extends SalaryAdjustmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SalaryAdjustmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SalaryAdjustmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SalaryAdjustmentGroupByOutputType[P]>
            : GetScalarType<T[P], SalaryAdjustmentGroupByOutputType[P]>
        }
      >
    >


  export type SalaryAdjustmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    adjustmentType?: boolean
    previousAmount?: boolean
    newAmount?: boolean
    effectiveDate?: boolean
    reason?: boolean
    notes?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | SalaryAdjustment$approverArgs<ExtArgs>
  }, ExtArgs["result"]["salaryAdjustment"]>

  export type SalaryAdjustmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    adjustmentType?: boolean
    previousAmount?: boolean
    newAmount?: boolean
    effectiveDate?: boolean
    reason?: boolean
    notes?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | SalaryAdjustment$approverArgs<ExtArgs>
  }, ExtArgs["result"]["salaryAdjustment"]>

  export type SalaryAdjustmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    adjustmentType?: boolean
    previousAmount?: boolean
    newAmount?: boolean
    effectiveDate?: boolean
    reason?: boolean
    notes?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | SalaryAdjustment$approverArgs<ExtArgs>
  }, ExtArgs["result"]["salaryAdjustment"]>

  export type SalaryAdjustmentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    adjustmentType?: boolean
    previousAmount?: boolean
    newAmount?: boolean
    effectiveDate?: boolean
    reason?: boolean
    notes?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SalaryAdjustmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "adjustmentType" | "previousAmount" | "newAmount" | "effectiveDate" | "reason" | "notes" | "approvedBy" | "approvedAt" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["salaryAdjustment"]>
  export type SalaryAdjustmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | SalaryAdjustment$approverArgs<ExtArgs>
  }
  export type SalaryAdjustmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | SalaryAdjustment$approverArgs<ExtArgs>
  }
  export type SalaryAdjustmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | SalaryAdjustment$approverArgs<ExtArgs>
  }

  export type $SalaryAdjustmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SalaryAdjustment"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      adjustmentType: $Enums.SalaryAdjustmentType
      previousAmount: Prisma.Decimal
      newAmount: Prisma.Decimal
      effectiveDate: Date
      reason: string
      notes: string | null
      approvedBy: string | null
      approvedAt: Date | null
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["salaryAdjustment"]>
    composites: {}
  }

  type SalaryAdjustmentGetPayload<S extends boolean | null | undefined | SalaryAdjustmentDefaultArgs> = $Result.GetResult<Prisma.$SalaryAdjustmentPayload, S>

  type SalaryAdjustmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SalaryAdjustmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SalaryAdjustmentCountAggregateInputType | true
    }

  export interface SalaryAdjustmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SalaryAdjustment'], meta: { name: 'SalaryAdjustment' } }
    /**
     * Find zero or one SalaryAdjustment that matches the filter.
     * @param {SalaryAdjustmentFindUniqueArgs} args - Arguments to find a SalaryAdjustment
     * @example
     * // Get one SalaryAdjustment
     * const salaryAdjustment = await prisma.salaryAdjustment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SalaryAdjustmentFindUniqueArgs>(args: SelectSubset<T, SalaryAdjustmentFindUniqueArgs<ExtArgs>>): Prisma__SalaryAdjustmentClient<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SalaryAdjustment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SalaryAdjustmentFindUniqueOrThrowArgs} args - Arguments to find a SalaryAdjustment
     * @example
     * // Get one SalaryAdjustment
     * const salaryAdjustment = await prisma.salaryAdjustment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SalaryAdjustmentFindUniqueOrThrowArgs>(args: SelectSubset<T, SalaryAdjustmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SalaryAdjustmentClient<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryAdjustment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAdjustmentFindFirstArgs} args - Arguments to find a SalaryAdjustment
     * @example
     * // Get one SalaryAdjustment
     * const salaryAdjustment = await prisma.salaryAdjustment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SalaryAdjustmentFindFirstArgs>(args?: SelectSubset<T, SalaryAdjustmentFindFirstArgs<ExtArgs>>): Prisma__SalaryAdjustmentClient<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SalaryAdjustment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAdjustmentFindFirstOrThrowArgs} args - Arguments to find a SalaryAdjustment
     * @example
     * // Get one SalaryAdjustment
     * const salaryAdjustment = await prisma.salaryAdjustment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SalaryAdjustmentFindFirstOrThrowArgs>(args?: SelectSubset<T, SalaryAdjustmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__SalaryAdjustmentClient<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SalaryAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAdjustmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SalaryAdjustments
     * const salaryAdjustments = await prisma.salaryAdjustment.findMany()
     * 
     * // Get first 10 SalaryAdjustments
     * const salaryAdjustments = await prisma.salaryAdjustment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const salaryAdjustmentWithIdOnly = await prisma.salaryAdjustment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SalaryAdjustmentFindManyArgs>(args?: SelectSubset<T, SalaryAdjustmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SalaryAdjustment.
     * @param {SalaryAdjustmentCreateArgs} args - Arguments to create a SalaryAdjustment.
     * @example
     * // Create one SalaryAdjustment
     * const SalaryAdjustment = await prisma.salaryAdjustment.create({
     *   data: {
     *     // ... data to create a SalaryAdjustment
     *   }
     * })
     * 
     */
    create<T extends SalaryAdjustmentCreateArgs>(args: SelectSubset<T, SalaryAdjustmentCreateArgs<ExtArgs>>): Prisma__SalaryAdjustmentClient<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SalaryAdjustments.
     * @param {SalaryAdjustmentCreateManyArgs} args - Arguments to create many SalaryAdjustments.
     * @example
     * // Create many SalaryAdjustments
     * const salaryAdjustment = await prisma.salaryAdjustment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SalaryAdjustmentCreateManyArgs>(args?: SelectSubset<T, SalaryAdjustmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SalaryAdjustments and returns the data saved in the database.
     * @param {SalaryAdjustmentCreateManyAndReturnArgs} args - Arguments to create many SalaryAdjustments.
     * @example
     * // Create many SalaryAdjustments
     * const salaryAdjustment = await prisma.salaryAdjustment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SalaryAdjustments and only return the `id`
     * const salaryAdjustmentWithIdOnly = await prisma.salaryAdjustment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SalaryAdjustmentCreateManyAndReturnArgs>(args?: SelectSubset<T, SalaryAdjustmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SalaryAdjustment.
     * @param {SalaryAdjustmentDeleteArgs} args - Arguments to delete one SalaryAdjustment.
     * @example
     * // Delete one SalaryAdjustment
     * const SalaryAdjustment = await prisma.salaryAdjustment.delete({
     *   where: {
     *     // ... filter to delete one SalaryAdjustment
     *   }
     * })
     * 
     */
    delete<T extends SalaryAdjustmentDeleteArgs>(args: SelectSubset<T, SalaryAdjustmentDeleteArgs<ExtArgs>>): Prisma__SalaryAdjustmentClient<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SalaryAdjustment.
     * @param {SalaryAdjustmentUpdateArgs} args - Arguments to update one SalaryAdjustment.
     * @example
     * // Update one SalaryAdjustment
     * const salaryAdjustment = await prisma.salaryAdjustment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SalaryAdjustmentUpdateArgs>(args: SelectSubset<T, SalaryAdjustmentUpdateArgs<ExtArgs>>): Prisma__SalaryAdjustmentClient<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SalaryAdjustments.
     * @param {SalaryAdjustmentDeleteManyArgs} args - Arguments to filter SalaryAdjustments to delete.
     * @example
     * // Delete a few SalaryAdjustments
     * const { count } = await prisma.salaryAdjustment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SalaryAdjustmentDeleteManyArgs>(args?: SelectSubset<T, SalaryAdjustmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAdjustmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SalaryAdjustments
     * const salaryAdjustment = await prisma.salaryAdjustment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SalaryAdjustmentUpdateManyArgs>(args: SelectSubset<T, SalaryAdjustmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SalaryAdjustments and returns the data updated in the database.
     * @param {SalaryAdjustmentUpdateManyAndReturnArgs} args - Arguments to update many SalaryAdjustments.
     * @example
     * // Update many SalaryAdjustments
     * const salaryAdjustment = await prisma.salaryAdjustment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SalaryAdjustments and only return the `id`
     * const salaryAdjustmentWithIdOnly = await prisma.salaryAdjustment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SalaryAdjustmentUpdateManyAndReturnArgs>(args: SelectSubset<T, SalaryAdjustmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SalaryAdjustment.
     * @param {SalaryAdjustmentUpsertArgs} args - Arguments to update or create a SalaryAdjustment.
     * @example
     * // Update or create a SalaryAdjustment
     * const salaryAdjustment = await prisma.salaryAdjustment.upsert({
     *   create: {
     *     // ... data to create a SalaryAdjustment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SalaryAdjustment we want to update
     *   }
     * })
     */
    upsert<T extends SalaryAdjustmentUpsertArgs>(args: SelectSubset<T, SalaryAdjustmentUpsertArgs<ExtArgs>>): Prisma__SalaryAdjustmentClient<$Result.GetResult<Prisma.$SalaryAdjustmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SalaryAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAdjustmentCountArgs} args - Arguments to filter SalaryAdjustments to count.
     * @example
     * // Count the number of SalaryAdjustments
     * const count = await prisma.salaryAdjustment.count({
     *   where: {
     *     // ... the filter for the SalaryAdjustments we want to count
     *   }
     * })
    **/
    count<T extends SalaryAdjustmentCountArgs>(
      args?: Subset<T, SalaryAdjustmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SalaryAdjustmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SalaryAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAdjustmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SalaryAdjustmentAggregateArgs>(args: Subset<T, SalaryAdjustmentAggregateArgs>): Prisma.PrismaPromise<GetSalaryAdjustmentAggregateType<T>>

    /**
     * Group by SalaryAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SalaryAdjustmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SalaryAdjustmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SalaryAdjustmentGroupByArgs['orderBy'] }
        : { orderBy?: SalaryAdjustmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SalaryAdjustmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSalaryAdjustmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SalaryAdjustment model
   */
  readonly fields: SalaryAdjustmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SalaryAdjustment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SalaryAdjustmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends SalaryAdjustment$approverArgs<ExtArgs> = {}>(args?: Subset<T, SalaryAdjustment$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SalaryAdjustment model
   */
  interface SalaryAdjustmentFieldRefs {
    readonly id: FieldRef<"SalaryAdjustment", 'String'>
    readonly employeeId: FieldRef<"SalaryAdjustment", 'String'>
    readonly adjustmentType: FieldRef<"SalaryAdjustment", 'SalaryAdjustmentType'>
    readonly previousAmount: FieldRef<"SalaryAdjustment", 'Decimal'>
    readonly newAmount: FieldRef<"SalaryAdjustment", 'Decimal'>
    readonly effectiveDate: FieldRef<"SalaryAdjustment", 'DateTime'>
    readonly reason: FieldRef<"SalaryAdjustment", 'String'>
    readonly notes: FieldRef<"SalaryAdjustment", 'String'>
    readonly approvedBy: FieldRef<"SalaryAdjustment", 'String'>
    readonly approvedAt: FieldRef<"SalaryAdjustment", 'DateTime'>
    readonly tenantId: FieldRef<"SalaryAdjustment", 'String'>
    readonly isDeleted: FieldRef<"SalaryAdjustment", 'Boolean'>
    readonly deletedAt: FieldRef<"SalaryAdjustment", 'DateTime'>
    readonly deletedBy: FieldRef<"SalaryAdjustment", 'String'>
    readonly createdBy: FieldRef<"SalaryAdjustment", 'String'>
    readonly createdAt: FieldRef<"SalaryAdjustment", 'DateTime'>
    readonly updatedAt: FieldRef<"SalaryAdjustment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SalaryAdjustment findUnique
   */
  export type SalaryAdjustmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryAdjustment to fetch.
     */
    where: SalaryAdjustmentWhereUniqueInput
  }

  /**
   * SalaryAdjustment findUniqueOrThrow
   */
  export type SalaryAdjustmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryAdjustment to fetch.
     */
    where: SalaryAdjustmentWhereUniqueInput
  }

  /**
   * SalaryAdjustment findFirst
   */
  export type SalaryAdjustmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryAdjustment to fetch.
     */
    where?: SalaryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryAdjustments to fetch.
     */
    orderBy?: SalaryAdjustmentOrderByWithRelationInput | SalaryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryAdjustments.
     */
    cursor?: SalaryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryAdjustments.
     */
    distinct?: SalaryAdjustmentScalarFieldEnum | SalaryAdjustmentScalarFieldEnum[]
  }

  /**
   * SalaryAdjustment findFirstOrThrow
   */
  export type SalaryAdjustmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryAdjustment to fetch.
     */
    where?: SalaryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryAdjustments to fetch.
     */
    orderBy?: SalaryAdjustmentOrderByWithRelationInput | SalaryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SalaryAdjustments.
     */
    cursor?: SalaryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SalaryAdjustments.
     */
    distinct?: SalaryAdjustmentScalarFieldEnum | SalaryAdjustmentScalarFieldEnum[]
  }

  /**
   * SalaryAdjustment findMany
   */
  export type SalaryAdjustmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which SalaryAdjustments to fetch.
     */
    where?: SalaryAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SalaryAdjustments to fetch.
     */
    orderBy?: SalaryAdjustmentOrderByWithRelationInput | SalaryAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SalaryAdjustments.
     */
    cursor?: SalaryAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SalaryAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SalaryAdjustments.
     */
    skip?: number
    distinct?: SalaryAdjustmentScalarFieldEnum | SalaryAdjustmentScalarFieldEnum[]
  }

  /**
   * SalaryAdjustment create
   */
  export type SalaryAdjustmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to create a SalaryAdjustment.
     */
    data: XOR<SalaryAdjustmentCreateInput, SalaryAdjustmentUncheckedCreateInput>
  }

  /**
   * SalaryAdjustment createMany
   */
  export type SalaryAdjustmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SalaryAdjustments.
     */
    data: SalaryAdjustmentCreateManyInput | SalaryAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SalaryAdjustment createManyAndReturn
   */
  export type SalaryAdjustmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to create many SalaryAdjustments.
     */
    data: SalaryAdjustmentCreateManyInput | SalaryAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryAdjustment update
   */
  export type SalaryAdjustmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to update a SalaryAdjustment.
     */
    data: XOR<SalaryAdjustmentUpdateInput, SalaryAdjustmentUncheckedUpdateInput>
    /**
     * Choose, which SalaryAdjustment to update.
     */
    where: SalaryAdjustmentWhereUniqueInput
  }

  /**
   * SalaryAdjustment updateMany
   */
  export type SalaryAdjustmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SalaryAdjustments.
     */
    data: XOR<SalaryAdjustmentUpdateManyMutationInput, SalaryAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which SalaryAdjustments to update
     */
    where?: SalaryAdjustmentWhereInput
    /**
     * Limit how many SalaryAdjustments to update.
     */
    limit?: number
  }

  /**
   * SalaryAdjustment updateManyAndReturn
   */
  export type SalaryAdjustmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * The data used to update SalaryAdjustments.
     */
    data: XOR<SalaryAdjustmentUpdateManyMutationInput, SalaryAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which SalaryAdjustments to update
     */
    where?: SalaryAdjustmentWhereInput
    /**
     * Limit how many SalaryAdjustments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SalaryAdjustment upsert
   */
  export type SalaryAdjustmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    /**
     * The filter to search for the SalaryAdjustment to update in case it exists.
     */
    where: SalaryAdjustmentWhereUniqueInput
    /**
     * In case the SalaryAdjustment found by the `where` argument doesn't exist, create a new SalaryAdjustment with this data.
     */
    create: XOR<SalaryAdjustmentCreateInput, SalaryAdjustmentUncheckedCreateInput>
    /**
     * In case the SalaryAdjustment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SalaryAdjustmentUpdateInput, SalaryAdjustmentUncheckedUpdateInput>
  }

  /**
   * SalaryAdjustment delete
   */
  export type SalaryAdjustmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
    /**
     * Filter which SalaryAdjustment to delete.
     */
    where: SalaryAdjustmentWhereUniqueInput
  }

  /**
   * SalaryAdjustment deleteMany
   */
  export type SalaryAdjustmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SalaryAdjustments to delete
     */
    where?: SalaryAdjustmentWhereInput
    /**
     * Limit how many SalaryAdjustments to delete.
     */
    limit?: number
  }

  /**
   * SalaryAdjustment.approver
   */
  export type SalaryAdjustment$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * SalaryAdjustment without action
   */
  export type SalaryAdjustmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SalaryAdjustment
     */
    select?: SalaryAdjustmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SalaryAdjustment
     */
    omit?: SalaryAdjustmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SalaryAdjustmentInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeExpense
   */

  export type AggregateEmployeeExpense = {
    _count: EmployeeExpenseCountAggregateOutputType | null
    _avg: EmployeeExpenseAvgAggregateOutputType | null
    _sum: EmployeeExpenseSumAggregateOutputType | null
    _min: EmployeeExpenseMinAggregateOutputType | null
    _max: EmployeeExpenseMaxAggregateOutputType | null
  }

  export type EmployeeExpenseAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type EmployeeExpenseSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type EmployeeExpenseMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    description: string | null
    amount: Decimal | null
    category: string | null
    expenseDate: Date | null
    receiptUrl: string | null
    status: $Enums.ExpenseStatus | null
    submittedAt: Date | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reimbursedAt: Date | null
    reimbursementTransactionId: string | null
    notes: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeExpenseMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    description: string | null
    amount: Decimal | null
    category: string | null
    expenseDate: Date | null
    receiptUrl: string | null
    status: $Enums.ExpenseStatus | null
    submittedAt: Date | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reimbursedAt: Date | null
    reimbursementTransactionId: string | null
    notes: string | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeExpenseCountAggregateOutputType = {
    id: number
    employeeId: number
    description: number
    amount: number
    category: number
    expenseDate: number
    receiptUrl: number
    status: number
    submittedAt: number
    reviewedBy: number
    reviewedAt: number
    reimbursedAt: number
    reimbursementTransactionId: number
    notes: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeExpenseAvgAggregateInputType = {
    amount?: true
  }

  export type EmployeeExpenseSumAggregateInputType = {
    amount?: true
  }

  export type EmployeeExpenseMinAggregateInputType = {
    id?: true
    employeeId?: true
    description?: true
    amount?: true
    category?: true
    expenseDate?: true
    receiptUrl?: true
    status?: true
    submittedAt?: true
    reviewedBy?: true
    reviewedAt?: true
    reimbursedAt?: true
    reimbursementTransactionId?: true
    notes?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeExpenseMaxAggregateInputType = {
    id?: true
    employeeId?: true
    description?: true
    amount?: true
    category?: true
    expenseDate?: true
    receiptUrl?: true
    status?: true
    submittedAt?: true
    reviewedBy?: true
    reviewedAt?: true
    reimbursedAt?: true
    reimbursementTransactionId?: true
    notes?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeExpenseCountAggregateInputType = {
    id?: true
    employeeId?: true
    description?: true
    amount?: true
    category?: true
    expenseDate?: true
    receiptUrl?: true
    status?: true
    submittedAt?: true
    reviewedBy?: true
    reviewedAt?: true
    reimbursedAt?: true
    reimbursementTransactionId?: true
    notes?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeExpense to aggregate.
     */
    where?: EmployeeExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeExpenses to fetch.
     */
    orderBy?: EmployeeExpenseOrderByWithRelationInput | EmployeeExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeExpenses
    **/
    _count?: true | EmployeeExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeExpenseMaxAggregateInputType
  }

  export type GetEmployeeExpenseAggregateType<T extends EmployeeExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeExpense[P]>
      : GetScalarType<T[P], AggregateEmployeeExpense[P]>
  }




  export type EmployeeExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeExpenseWhereInput
    orderBy?: EmployeeExpenseOrderByWithAggregationInput | EmployeeExpenseOrderByWithAggregationInput[]
    by: EmployeeExpenseScalarFieldEnum[] | EmployeeExpenseScalarFieldEnum
    having?: EmployeeExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeExpenseCountAggregateInputType | true
    _avg?: EmployeeExpenseAvgAggregateInputType
    _sum?: EmployeeExpenseSumAggregateInputType
    _min?: EmployeeExpenseMinAggregateInputType
    _max?: EmployeeExpenseMaxAggregateInputType
  }

  export type EmployeeExpenseGroupByOutputType = {
    id: string
    employeeId: string
    description: string
    amount: Decimal
    category: string
    expenseDate: Date
    receiptUrl: string | null
    status: $Enums.ExpenseStatus
    submittedAt: Date | null
    reviewedBy: string | null
    reviewedAt: Date | null
    reimbursedAt: Date | null
    reimbursementTransactionId: string | null
    notes: string | null
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeExpenseCountAggregateOutputType | null
    _avg: EmployeeExpenseAvgAggregateOutputType | null
    _sum: EmployeeExpenseSumAggregateOutputType | null
    _min: EmployeeExpenseMinAggregateOutputType | null
    _max: EmployeeExpenseMaxAggregateOutputType | null
  }

  type GetEmployeeExpenseGroupByPayload<T extends EmployeeExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeExpenseGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    expenseDate?: boolean
    receiptUrl?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reimbursedAt?: boolean
    reimbursementTransactionId?: boolean
    notes?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | EmployeeExpense$reviewerArgs<ExtArgs>
    reimbursementTransaction?: boolean | EmployeeExpense$reimbursementTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["employeeExpense"]>

  export type EmployeeExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    expenseDate?: boolean
    receiptUrl?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reimbursedAt?: boolean
    reimbursementTransactionId?: boolean
    notes?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | EmployeeExpense$reviewerArgs<ExtArgs>
    reimbursementTransaction?: boolean | EmployeeExpense$reimbursementTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["employeeExpense"]>

  export type EmployeeExpenseSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    expenseDate?: boolean
    receiptUrl?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reimbursedAt?: boolean
    reimbursementTransactionId?: boolean
    notes?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | EmployeeExpense$reviewerArgs<ExtArgs>
    reimbursementTransaction?: boolean | EmployeeExpense$reimbursementTransactionArgs<ExtArgs>
  }, ExtArgs["result"]["employeeExpense"]>

  export type EmployeeExpenseSelectScalar = {
    id?: boolean
    employeeId?: boolean
    description?: boolean
    amount?: boolean
    category?: boolean
    expenseDate?: boolean
    receiptUrl?: boolean
    status?: boolean
    submittedAt?: boolean
    reviewedBy?: boolean
    reviewedAt?: boolean
    reimbursedAt?: boolean
    reimbursementTransactionId?: boolean
    notes?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeExpenseOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "description" | "amount" | "category" | "expenseDate" | "receiptUrl" | "status" | "submittedAt" | "reviewedBy" | "reviewedAt" | "reimbursedAt" | "reimbursementTransactionId" | "notes" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["employeeExpense"]>
  export type EmployeeExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | EmployeeExpense$reviewerArgs<ExtArgs>
    reimbursementTransaction?: boolean | EmployeeExpense$reimbursementTransactionArgs<ExtArgs>
  }
  export type EmployeeExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | EmployeeExpense$reviewerArgs<ExtArgs>
    reimbursementTransaction?: boolean | EmployeeExpense$reimbursementTransactionArgs<ExtArgs>
  }
  export type EmployeeExpenseIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    reviewer?: boolean | EmployeeExpense$reviewerArgs<ExtArgs>
    reimbursementTransaction?: boolean | EmployeeExpense$reimbursementTransactionArgs<ExtArgs>
  }

  export type $EmployeeExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeExpense"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
      reviewer: Prisma.$UserPayload<ExtArgs> | null
      reimbursementTransaction: Prisma.$TransactionPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      description: string
      amount: Prisma.Decimal
      category: string
      expenseDate: Date
      receiptUrl: string | null
      status: $Enums.ExpenseStatus
      submittedAt: Date | null
      reviewedBy: string | null
      reviewedAt: Date | null
      reimbursedAt: Date | null
      reimbursementTransactionId: string | null
      notes: string | null
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeExpense"]>
    composites: {}
  }

  type EmployeeExpenseGetPayload<S extends boolean | null | undefined | EmployeeExpenseDefaultArgs> = $Result.GetResult<Prisma.$EmployeeExpensePayload, S>

  type EmployeeExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeExpenseFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeExpenseCountAggregateInputType | true
    }

  export interface EmployeeExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeExpense'], meta: { name: 'EmployeeExpense' } }
    /**
     * Find zero or one EmployeeExpense that matches the filter.
     * @param {EmployeeExpenseFindUniqueArgs} args - Arguments to find a EmployeeExpense
     * @example
     * // Get one EmployeeExpense
     * const employeeExpense = await prisma.employeeExpense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeExpenseFindUniqueArgs>(args: SelectSubset<T, EmployeeExpenseFindUniqueArgs<ExtArgs>>): Prisma__EmployeeExpenseClient<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmployeeExpense that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeExpenseFindUniqueOrThrowArgs} args - Arguments to find a EmployeeExpense
     * @example
     * // Get one EmployeeExpense
     * const employeeExpense = await prisma.employeeExpense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeExpenseClient<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeExpense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeExpenseFindFirstArgs} args - Arguments to find a EmployeeExpense
     * @example
     * // Get one EmployeeExpense
     * const employeeExpense = await prisma.employeeExpense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeExpenseFindFirstArgs>(args?: SelectSubset<T, EmployeeExpenseFindFirstArgs<ExtArgs>>): Prisma__EmployeeExpenseClient<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmployeeExpense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeExpenseFindFirstOrThrowArgs} args - Arguments to find a EmployeeExpense
     * @example
     * // Get one EmployeeExpense
     * const employeeExpense = await prisma.employeeExpense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeExpenseClient<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmployeeExpenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeExpenses
     * const employeeExpenses = await prisma.employeeExpense.findMany()
     * 
     * // Get first 10 EmployeeExpenses
     * const employeeExpenses = await prisma.employeeExpense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeExpenseWithIdOnly = await prisma.employeeExpense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeExpenseFindManyArgs>(args?: SelectSubset<T, EmployeeExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmployeeExpense.
     * @param {EmployeeExpenseCreateArgs} args - Arguments to create a EmployeeExpense.
     * @example
     * // Create one EmployeeExpense
     * const EmployeeExpense = await prisma.employeeExpense.create({
     *   data: {
     *     // ... data to create a EmployeeExpense
     *   }
     * })
     * 
     */
    create<T extends EmployeeExpenseCreateArgs>(args: SelectSubset<T, EmployeeExpenseCreateArgs<ExtArgs>>): Prisma__EmployeeExpenseClient<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmployeeExpenses.
     * @param {EmployeeExpenseCreateManyArgs} args - Arguments to create many EmployeeExpenses.
     * @example
     * // Create many EmployeeExpenses
     * const employeeExpense = await prisma.employeeExpense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeExpenseCreateManyArgs>(args?: SelectSubset<T, EmployeeExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeExpenses and returns the data saved in the database.
     * @param {EmployeeExpenseCreateManyAndReturnArgs} args - Arguments to create many EmployeeExpenses.
     * @example
     * // Create many EmployeeExpenses
     * const employeeExpense = await prisma.employeeExpense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeExpenses and only return the `id`
     * const employeeExpenseWithIdOnly = await prisma.employeeExpense.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmployeeExpense.
     * @param {EmployeeExpenseDeleteArgs} args - Arguments to delete one EmployeeExpense.
     * @example
     * // Delete one EmployeeExpense
     * const EmployeeExpense = await prisma.employeeExpense.delete({
     *   where: {
     *     // ... filter to delete one EmployeeExpense
     *   }
     * })
     * 
     */
    delete<T extends EmployeeExpenseDeleteArgs>(args: SelectSubset<T, EmployeeExpenseDeleteArgs<ExtArgs>>): Prisma__EmployeeExpenseClient<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmployeeExpense.
     * @param {EmployeeExpenseUpdateArgs} args - Arguments to update one EmployeeExpense.
     * @example
     * // Update one EmployeeExpense
     * const employeeExpense = await prisma.employeeExpense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeExpenseUpdateArgs>(args: SelectSubset<T, EmployeeExpenseUpdateArgs<ExtArgs>>): Prisma__EmployeeExpenseClient<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmployeeExpenses.
     * @param {EmployeeExpenseDeleteManyArgs} args - Arguments to filter EmployeeExpenses to delete.
     * @example
     * // Delete a few EmployeeExpenses
     * const { count } = await prisma.employeeExpense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeExpenseDeleteManyArgs>(args?: SelectSubset<T, EmployeeExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeExpenses
     * const employeeExpense = await prisma.employeeExpense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeExpenseUpdateManyArgs>(args: SelectSubset<T, EmployeeExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeExpenses and returns the data updated in the database.
     * @param {EmployeeExpenseUpdateManyAndReturnArgs} args - Arguments to update many EmployeeExpenses.
     * @example
     * // Update many EmployeeExpenses
     * const employeeExpense = await prisma.employeeExpense.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmployeeExpenses and only return the `id`
     * const employeeExpenseWithIdOnly = await prisma.employeeExpense.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeExpenseUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeExpenseUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmployeeExpense.
     * @param {EmployeeExpenseUpsertArgs} args - Arguments to update or create a EmployeeExpense.
     * @example
     * // Update or create a EmployeeExpense
     * const employeeExpense = await prisma.employeeExpense.upsert({
     *   create: {
     *     // ... data to create a EmployeeExpense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeExpense we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeExpenseUpsertArgs>(args: SelectSubset<T, EmployeeExpenseUpsertArgs<ExtArgs>>): Prisma__EmployeeExpenseClient<$Result.GetResult<Prisma.$EmployeeExpensePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmployeeExpenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeExpenseCountArgs} args - Arguments to filter EmployeeExpenses to count.
     * @example
     * // Count the number of EmployeeExpenses
     * const count = await prisma.employeeExpense.count({
     *   where: {
     *     // ... the filter for the EmployeeExpenses we want to count
     *   }
     * })
    **/
    count<T extends EmployeeExpenseCountArgs>(
      args?: Subset<T, EmployeeExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeExpenseAggregateArgs>(args: Subset<T, EmployeeExpenseAggregateArgs>): Prisma.PrismaPromise<GetEmployeeExpenseAggregateType<T>>

    /**
     * Group by EmployeeExpense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeExpenseGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeExpense model
   */
  readonly fields: EmployeeExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeExpense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    reviewer<T extends EmployeeExpense$reviewerArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeExpense$reviewerArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reimbursementTransaction<T extends EmployeeExpense$reimbursementTransactionArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeExpense$reimbursementTransactionArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeExpense model
   */
  interface EmployeeExpenseFieldRefs {
    readonly id: FieldRef<"EmployeeExpense", 'String'>
    readonly employeeId: FieldRef<"EmployeeExpense", 'String'>
    readonly description: FieldRef<"EmployeeExpense", 'String'>
    readonly amount: FieldRef<"EmployeeExpense", 'Decimal'>
    readonly category: FieldRef<"EmployeeExpense", 'String'>
    readonly expenseDate: FieldRef<"EmployeeExpense", 'DateTime'>
    readonly receiptUrl: FieldRef<"EmployeeExpense", 'String'>
    readonly status: FieldRef<"EmployeeExpense", 'ExpenseStatus'>
    readonly submittedAt: FieldRef<"EmployeeExpense", 'DateTime'>
    readonly reviewedBy: FieldRef<"EmployeeExpense", 'String'>
    readonly reviewedAt: FieldRef<"EmployeeExpense", 'DateTime'>
    readonly reimbursedAt: FieldRef<"EmployeeExpense", 'DateTime'>
    readonly reimbursementTransactionId: FieldRef<"EmployeeExpense", 'String'>
    readonly notes: FieldRef<"EmployeeExpense", 'String'>
    readonly tenantId: FieldRef<"EmployeeExpense", 'String'>
    readonly isDeleted: FieldRef<"EmployeeExpense", 'Boolean'>
    readonly deletedAt: FieldRef<"EmployeeExpense", 'DateTime'>
    readonly deletedBy: FieldRef<"EmployeeExpense", 'String'>
    readonly createdBy: FieldRef<"EmployeeExpense", 'String'>
    readonly createdAt: FieldRef<"EmployeeExpense", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeExpense", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeExpense findUnique
   */
  export type EmployeeExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeExpense to fetch.
     */
    where: EmployeeExpenseWhereUniqueInput
  }

  /**
   * EmployeeExpense findUniqueOrThrow
   */
  export type EmployeeExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeExpense to fetch.
     */
    where: EmployeeExpenseWhereUniqueInput
  }

  /**
   * EmployeeExpense findFirst
   */
  export type EmployeeExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeExpense to fetch.
     */
    where?: EmployeeExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeExpenses to fetch.
     */
    orderBy?: EmployeeExpenseOrderByWithRelationInput | EmployeeExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeExpenses.
     */
    cursor?: EmployeeExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeExpenses.
     */
    distinct?: EmployeeExpenseScalarFieldEnum | EmployeeExpenseScalarFieldEnum[]
  }

  /**
   * EmployeeExpense findFirstOrThrow
   */
  export type EmployeeExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeExpense to fetch.
     */
    where?: EmployeeExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeExpenses to fetch.
     */
    orderBy?: EmployeeExpenseOrderByWithRelationInput | EmployeeExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeExpenses.
     */
    cursor?: EmployeeExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeExpenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeExpenses.
     */
    distinct?: EmployeeExpenseScalarFieldEnum | EmployeeExpenseScalarFieldEnum[]
  }

  /**
   * EmployeeExpense findMany
   */
  export type EmployeeExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeExpenses to fetch.
     */
    where?: EmployeeExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeExpenses to fetch.
     */
    orderBy?: EmployeeExpenseOrderByWithRelationInput | EmployeeExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeExpenses.
     */
    cursor?: EmployeeExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeExpenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeExpenses.
     */
    skip?: number
    distinct?: EmployeeExpenseScalarFieldEnum | EmployeeExpenseScalarFieldEnum[]
  }

  /**
   * EmployeeExpense create
   */
  export type EmployeeExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeExpense.
     */
    data: XOR<EmployeeExpenseCreateInput, EmployeeExpenseUncheckedCreateInput>
  }

  /**
   * EmployeeExpense createMany
   */
  export type EmployeeExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeExpenses.
     */
    data: EmployeeExpenseCreateManyInput | EmployeeExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeExpense createManyAndReturn
   */
  export type EmployeeExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * The data used to create many EmployeeExpenses.
     */
    data: EmployeeExpenseCreateManyInput | EmployeeExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeExpense update
   */
  export type EmployeeExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeExpense.
     */
    data: XOR<EmployeeExpenseUpdateInput, EmployeeExpenseUncheckedUpdateInput>
    /**
     * Choose, which EmployeeExpense to update.
     */
    where: EmployeeExpenseWhereUniqueInput
  }

  /**
   * EmployeeExpense updateMany
   */
  export type EmployeeExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeExpenses.
     */
    data: XOR<EmployeeExpenseUpdateManyMutationInput, EmployeeExpenseUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeExpenses to update
     */
    where?: EmployeeExpenseWhereInput
    /**
     * Limit how many EmployeeExpenses to update.
     */
    limit?: number
  }

  /**
   * EmployeeExpense updateManyAndReturn
   */
  export type EmployeeExpenseUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * The data used to update EmployeeExpenses.
     */
    data: XOR<EmployeeExpenseUpdateManyMutationInput, EmployeeExpenseUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeExpenses to update
     */
    where?: EmployeeExpenseWhereInput
    /**
     * Limit how many EmployeeExpenses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeExpense upsert
   */
  export type EmployeeExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeExpense to update in case it exists.
     */
    where: EmployeeExpenseWhereUniqueInput
    /**
     * In case the EmployeeExpense found by the `where` argument doesn't exist, create a new EmployeeExpense with this data.
     */
    create: XOR<EmployeeExpenseCreateInput, EmployeeExpenseUncheckedCreateInput>
    /**
     * In case the EmployeeExpense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeExpenseUpdateInput, EmployeeExpenseUncheckedUpdateInput>
  }

  /**
   * EmployeeExpense delete
   */
  export type EmployeeExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
    /**
     * Filter which EmployeeExpense to delete.
     */
    where: EmployeeExpenseWhereUniqueInput
  }

  /**
   * EmployeeExpense deleteMany
   */
  export type EmployeeExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeExpenses to delete
     */
    where?: EmployeeExpenseWhereInput
    /**
     * Limit how many EmployeeExpenses to delete.
     */
    limit?: number
  }

  /**
   * EmployeeExpense.reviewer
   */
  export type EmployeeExpense$reviewerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * EmployeeExpense.reimbursementTransaction
   */
  export type EmployeeExpense$reimbursementTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
  }

  /**
   * EmployeeExpense without action
   */
  export type EmployeeExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeExpense
     */
    select?: EmployeeExpenseSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmployeeExpense
     */
    omit?: EmployeeExpenseOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeExpenseInclude<ExtArgs> | null
  }


  /**
   * Model PTORequest
   */

  export type AggregatePTORequest = {
    _count: PTORequestCountAggregateOutputType | null
    _avg: PTORequestAvgAggregateOutputType | null
    _sum: PTORequestSumAggregateOutputType | null
    _min: PTORequestMinAggregateOutputType | null
    _max: PTORequestMaxAggregateOutputType | null
  }

  export type PTORequestAvgAggregateOutputType = {
    totalDays: Decimal | null
  }

  export type PTORequestSumAggregateOutputType = {
    totalDays: Decimal | null
  }

  export type PTORequestMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    startDate: Date | null
    endDate: Date | null
    totalDays: Decimal | null
    status: $Enums.PTOStatus | null
    reason: string | null
    submittedAt: Date | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    cancelledAt: Date | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PTORequestMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    startDate: Date | null
    endDate: Date | null
    totalDays: Decimal | null
    status: $Enums.PTOStatus | null
    reason: string | null
    submittedAt: Date | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    cancelledAt: Date | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PTORequestCountAggregateOutputType = {
    id: number
    employeeId: number
    startDate: number
    endDate: number
    totalDays: number
    status: number
    reason: number
    submittedAt: number
    approvedBy: number
    approvedAt: number
    rejectedAt: number
    cancelledAt: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PTORequestAvgAggregateInputType = {
    totalDays?: true
  }

  export type PTORequestSumAggregateInputType = {
    totalDays?: true
  }

  export type PTORequestMinAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    status?: true
    reason?: true
    submittedAt?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    cancelledAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PTORequestMaxAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    status?: true
    reason?: true
    submittedAt?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    cancelledAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PTORequestCountAggregateInputType = {
    id?: true
    employeeId?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    status?: true
    reason?: true
    submittedAt?: true
    approvedBy?: true
    approvedAt?: true
    rejectedAt?: true
    cancelledAt?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PTORequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PTORequest to aggregate.
     */
    where?: PTORequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PTORequests to fetch.
     */
    orderBy?: PTORequestOrderByWithRelationInput | PTORequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PTORequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PTORequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PTORequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PTORequests
    **/
    _count?: true | PTORequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PTORequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PTORequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PTORequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PTORequestMaxAggregateInputType
  }

  export type GetPTORequestAggregateType<T extends PTORequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePTORequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePTORequest[P]>
      : GetScalarType<T[P], AggregatePTORequest[P]>
  }




  export type PTORequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PTORequestWhereInput
    orderBy?: PTORequestOrderByWithAggregationInput | PTORequestOrderByWithAggregationInput[]
    by: PTORequestScalarFieldEnum[] | PTORequestScalarFieldEnum
    having?: PTORequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PTORequestCountAggregateInputType | true
    _avg?: PTORequestAvgAggregateInputType
    _sum?: PTORequestSumAggregateInputType
    _min?: PTORequestMinAggregateInputType
    _max?: PTORequestMaxAggregateInputType
  }

  export type PTORequestGroupByOutputType = {
    id: string
    employeeId: string
    startDate: Date
    endDate: Date
    totalDays: Decimal
    status: $Enums.PTOStatus
    reason: string | null
    submittedAt: Date | null
    approvedBy: string | null
    approvedAt: Date | null
    rejectedAt: Date | null
    cancelledAt: Date | null
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: PTORequestCountAggregateOutputType | null
    _avg: PTORequestAvgAggregateOutputType | null
    _sum: PTORequestSumAggregateOutputType | null
    _min: PTORequestMinAggregateOutputType | null
    _max: PTORequestMaxAggregateOutputType | null
  }

  type GetPTORequestGroupByPayload<T extends PTORequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PTORequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PTORequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PTORequestGroupByOutputType[P]>
            : GetScalarType<T[P], PTORequestGroupByOutputType[P]>
        }
      >
    >


  export type PTORequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    status?: boolean
    reason?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    cancelledAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | PTORequest$approverArgs<ExtArgs>
  }, ExtArgs["result"]["pTORequest"]>

  export type PTORequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    status?: boolean
    reason?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    cancelledAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | PTORequest$approverArgs<ExtArgs>
  }, ExtArgs["result"]["pTORequest"]>

  export type PTORequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    status?: boolean
    reason?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    cancelledAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | PTORequest$approverArgs<ExtArgs>
  }, ExtArgs["result"]["pTORequest"]>

  export type PTORequestSelectScalar = {
    id?: boolean
    employeeId?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    status?: boolean
    reason?: boolean
    submittedAt?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    rejectedAt?: boolean
    cancelledAt?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PTORequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "startDate" | "endDate" | "totalDays" | "status" | "reason" | "submittedAt" | "approvedBy" | "approvedAt" | "rejectedAt" | "cancelledAt" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["pTORequest"]>
  export type PTORequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | PTORequest$approverArgs<ExtArgs>
  }
  export type PTORequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | PTORequest$approverArgs<ExtArgs>
  }
  export type PTORequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
    approver?: boolean | PTORequest$approverArgs<ExtArgs>
  }

  export type $PTORequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PTORequest"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
      approver: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      startDate: Date
      endDate: Date
      totalDays: Prisma.Decimal
      status: $Enums.PTOStatus
      reason: string | null
      submittedAt: Date | null
      approvedBy: string | null
      approvedAt: Date | null
      rejectedAt: Date | null
      cancelledAt: Date | null
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pTORequest"]>
    composites: {}
  }

  type PTORequestGetPayload<S extends boolean | null | undefined | PTORequestDefaultArgs> = $Result.GetResult<Prisma.$PTORequestPayload, S>

  type PTORequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PTORequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PTORequestCountAggregateInputType | true
    }

  export interface PTORequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PTORequest'], meta: { name: 'PTORequest' } }
    /**
     * Find zero or one PTORequest that matches the filter.
     * @param {PTORequestFindUniqueArgs} args - Arguments to find a PTORequest
     * @example
     * // Get one PTORequest
     * const pTORequest = await prisma.pTORequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PTORequestFindUniqueArgs>(args: SelectSubset<T, PTORequestFindUniqueArgs<ExtArgs>>): Prisma__PTORequestClient<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PTORequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PTORequestFindUniqueOrThrowArgs} args - Arguments to find a PTORequest
     * @example
     * // Get one PTORequest
     * const pTORequest = await prisma.pTORequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PTORequestFindUniqueOrThrowArgs>(args: SelectSubset<T, PTORequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PTORequestClient<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PTORequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTORequestFindFirstArgs} args - Arguments to find a PTORequest
     * @example
     * // Get one PTORequest
     * const pTORequest = await prisma.pTORequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PTORequestFindFirstArgs>(args?: SelectSubset<T, PTORequestFindFirstArgs<ExtArgs>>): Prisma__PTORequestClient<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PTORequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTORequestFindFirstOrThrowArgs} args - Arguments to find a PTORequest
     * @example
     * // Get one PTORequest
     * const pTORequest = await prisma.pTORequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PTORequestFindFirstOrThrowArgs>(args?: SelectSubset<T, PTORequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PTORequestClient<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PTORequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTORequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PTORequests
     * const pTORequests = await prisma.pTORequest.findMany()
     * 
     * // Get first 10 PTORequests
     * const pTORequests = await prisma.pTORequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pTORequestWithIdOnly = await prisma.pTORequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PTORequestFindManyArgs>(args?: SelectSubset<T, PTORequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PTORequest.
     * @param {PTORequestCreateArgs} args - Arguments to create a PTORequest.
     * @example
     * // Create one PTORequest
     * const PTORequest = await prisma.pTORequest.create({
     *   data: {
     *     // ... data to create a PTORequest
     *   }
     * })
     * 
     */
    create<T extends PTORequestCreateArgs>(args: SelectSubset<T, PTORequestCreateArgs<ExtArgs>>): Prisma__PTORequestClient<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PTORequests.
     * @param {PTORequestCreateManyArgs} args - Arguments to create many PTORequests.
     * @example
     * // Create many PTORequests
     * const pTORequest = await prisma.pTORequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PTORequestCreateManyArgs>(args?: SelectSubset<T, PTORequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PTORequests and returns the data saved in the database.
     * @param {PTORequestCreateManyAndReturnArgs} args - Arguments to create many PTORequests.
     * @example
     * // Create many PTORequests
     * const pTORequest = await prisma.pTORequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PTORequests and only return the `id`
     * const pTORequestWithIdOnly = await prisma.pTORequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PTORequestCreateManyAndReturnArgs>(args?: SelectSubset<T, PTORequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PTORequest.
     * @param {PTORequestDeleteArgs} args - Arguments to delete one PTORequest.
     * @example
     * // Delete one PTORequest
     * const PTORequest = await prisma.pTORequest.delete({
     *   where: {
     *     // ... filter to delete one PTORequest
     *   }
     * })
     * 
     */
    delete<T extends PTORequestDeleteArgs>(args: SelectSubset<T, PTORequestDeleteArgs<ExtArgs>>): Prisma__PTORequestClient<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PTORequest.
     * @param {PTORequestUpdateArgs} args - Arguments to update one PTORequest.
     * @example
     * // Update one PTORequest
     * const pTORequest = await prisma.pTORequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PTORequestUpdateArgs>(args: SelectSubset<T, PTORequestUpdateArgs<ExtArgs>>): Prisma__PTORequestClient<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PTORequests.
     * @param {PTORequestDeleteManyArgs} args - Arguments to filter PTORequests to delete.
     * @example
     * // Delete a few PTORequests
     * const { count } = await prisma.pTORequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PTORequestDeleteManyArgs>(args?: SelectSubset<T, PTORequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PTORequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTORequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PTORequests
     * const pTORequest = await prisma.pTORequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PTORequestUpdateManyArgs>(args: SelectSubset<T, PTORequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PTORequests and returns the data updated in the database.
     * @param {PTORequestUpdateManyAndReturnArgs} args - Arguments to update many PTORequests.
     * @example
     * // Update many PTORequests
     * const pTORequest = await prisma.pTORequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PTORequests and only return the `id`
     * const pTORequestWithIdOnly = await prisma.pTORequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PTORequestUpdateManyAndReturnArgs>(args: SelectSubset<T, PTORequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PTORequest.
     * @param {PTORequestUpsertArgs} args - Arguments to update or create a PTORequest.
     * @example
     * // Update or create a PTORequest
     * const pTORequest = await prisma.pTORequest.upsert({
     *   create: {
     *     // ... data to create a PTORequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PTORequest we want to update
     *   }
     * })
     */
    upsert<T extends PTORequestUpsertArgs>(args: SelectSubset<T, PTORequestUpsertArgs<ExtArgs>>): Prisma__PTORequestClient<$Result.GetResult<Prisma.$PTORequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PTORequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTORequestCountArgs} args - Arguments to filter PTORequests to count.
     * @example
     * // Count the number of PTORequests
     * const count = await prisma.pTORequest.count({
     *   where: {
     *     // ... the filter for the PTORequests we want to count
     *   }
     * })
    **/
    count<T extends PTORequestCountArgs>(
      args?: Subset<T, PTORequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PTORequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PTORequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTORequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PTORequestAggregateArgs>(args: Subset<T, PTORequestAggregateArgs>): Prisma.PrismaPromise<GetPTORequestAggregateType<T>>

    /**
     * Group by PTORequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTORequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PTORequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PTORequestGroupByArgs['orderBy'] }
        : { orderBy?: PTORequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PTORequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPTORequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PTORequest model
   */
  readonly fields: PTORequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PTORequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PTORequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    approver<T extends PTORequest$approverArgs<ExtArgs> = {}>(args?: Subset<T, PTORequest$approverArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PTORequest model
   */
  interface PTORequestFieldRefs {
    readonly id: FieldRef<"PTORequest", 'String'>
    readonly employeeId: FieldRef<"PTORequest", 'String'>
    readonly startDate: FieldRef<"PTORequest", 'DateTime'>
    readonly endDate: FieldRef<"PTORequest", 'DateTime'>
    readonly totalDays: FieldRef<"PTORequest", 'Decimal'>
    readonly status: FieldRef<"PTORequest", 'PTOStatus'>
    readonly reason: FieldRef<"PTORequest", 'String'>
    readonly submittedAt: FieldRef<"PTORequest", 'DateTime'>
    readonly approvedBy: FieldRef<"PTORequest", 'String'>
    readonly approvedAt: FieldRef<"PTORequest", 'DateTime'>
    readonly rejectedAt: FieldRef<"PTORequest", 'DateTime'>
    readonly cancelledAt: FieldRef<"PTORequest", 'DateTime'>
    readonly tenantId: FieldRef<"PTORequest", 'String'>
    readonly isDeleted: FieldRef<"PTORequest", 'Boolean'>
    readonly deletedAt: FieldRef<"PTORequest", 'DateTime'>
    readonly deletedBy: FieldRef<"PTORequest", 'String'>
    readonly createdBy: FieldRef<"PTORequest", 'String'>
    readonly createdAt: FieldRef<"PTORequest", 'DateTime'>
    readonly updatedAt: FieldRef<"PTORequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PTORequest findUnique
   */
  export type PTORequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    /**
     * Filter, which PTORequest to fetch.
     */
    where: PTORequestWhereUniqueInput
  }

  /**
   * PTORequest findUniqueOrThrow
   */
  export type PTORequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    /**
     * Filter, which PTORequest to fetch.
     */
    where: PTORequestWhereUniqueInput
  }

  /**
   * PTORequest findFirst
   */
  export type PTORequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    /**
     * Filter, which PTORequest to fetch.
     */
    where?: PTORequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PTORequests to fetch.
     */
    orderBy?: PTORequestOrderByWithRelationInput | PTORequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PTORequests.
     */
    cursor?: PTORequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PTORequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PTORequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PTORequests.
     */
    distinct?: PTORequestScalarFieldEnum | PTORequestScalarFieldEnum[]
  }

  /**
   * PTORequest findFirstOrThrow
   */
  export type PTORequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    /**
     * Filter, which PTORequest to fetch.
     */
    where?: PTORequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PTORequests to fetch.
     */
    orderBy?: PTORequestOrderByWithRelationInput | PTORequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PTORequests.
     */
    cursor?: PTORequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PTORequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PTORequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PTORequests.
     */
    distinct?: PTORequestScalarFieldEnum | PTORequestScalarFieldEnum[]
  }

  /**
   * PTORequest findMany
   */
  export type PTORequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    /**
     * Filter, which PTORequests to fetch.
     */
    where?: PTORequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PTORequests to fetch.
     */
    orderBy?: PTORequestOrderByWithRelationInput | PTORequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PTORequests.
     */
    cursor?: PTORequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PTORequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PTORequests.
     */
    skip?: number
    distinct?: PTORequestScalarFieldEnum | PTORequestScalarFieldEnum[]
  }

  /**
   * PTORequest create
   */
  export type PTORequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    /**
     * The data needed to create a PTORequest.
     */
    data: XOR<PTORequestCreateInput, PTORequestUncheckedCreateInput>
  }

  /**
   * PTORequest createMany
   */
  export type PTORequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PTORequests.
     */
    data: PTORequestCreateManyInput | PTORequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PTORequest createManyAndReturn
   */
  export type PTORequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * The data used to create many PTORequests.
     */
    data: PTORequestCreateManyInput | PTORequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PTORequest update
   */
  export type PTORequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    /**
     * The data needed to update a PTORequest.
     */
    data: XOR<PTORequestUpdateInput, PTORequestUncheckedUpdateInput>
    /**
     * Choose, which PTORequest to update.
     */
    where: PTORequestWhereUniqueInput
  }

  /**
   * PTORequest updateMany
   */
  export type PTORequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PTORequests.
     */
    data: XOR<PTORequestUpdateManyMutationInput, PTORequestUncheckedUpdateManyInput>
    /**
     * Filter which PTORequests to update
     */
    where?: PTORequestWhereInput
    /**
     * Limit how many PTORequests to update.
     */
    limit?: number
  }

  /**
   * PTORequest updateManyAndReturn
   */
  export type PTORequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * The data used to update PTORequests.
     */
    data: XOR<PTORequestUpdateManyMutationInput, PTORequestUncheckedUpdateManyInput>
    /**
     * Filter which PTORequests to update
     */
    where?: PTORequestWhereInput
    /**
     * Limit how many PTORequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PTORequest upsert
   */
  export type PTORequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    /**
     * The filter to search for the PTORequest to update in case it exists.
     */
    where: PTORequestWhereUniqueInput
    /**
     * In case the PTORequest found by the `where` argument doesn't exist, create a new PTORequest with this data.
     */
    create: XOR<PTORequestCreateInput, PTORequestUncheckedCreateInput>
    /**
     * In case the PTORequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PTORequestUpdateInput, PTORequestUncheckedUpdateInput>
  }

  /**
   * PTORequest delete
   */
  export type PTORequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
    /**
     * Filter which PTORequest to delete.
     */
    where: PTORequestWhereUniqueInput
  }

  /**
   * PTORequest deleteMany
   */
  export type PTORequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PTORequests to delete
     */
    where?: PTORequestWhereInput
    /**
     * Limit how many PTORequests to delete.
     */
    limit?: number
  }

  /**
   * PTORequest.approver
   */
  export type PTORequest$approverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PTORequest without action
   */
  export type PTORequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTORequest
     */
    select?: PTORequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTORequest
     */
    omit?: PTORequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTORequestInclude<ExtArgs> | null
  }


  /**
   * Model PTOBalance
   */

  export type AggregatePTOBalance = {
    _count: PTOBalanceCountAggregateOutputType | null
    _avg: PTOBalanceAvgAggregateOutputType | null
    _sum: PTOBalanceSumAggregateOutputType | null
    _min: PTOBalanceMinAggregateOutputType | null
    _max: PTOBalanceMaxAggregateOutputType | null
  }

  export type PTOBalanceAvgAggregateOutputType = {
    year: number | null
    totalDays: Decimal | null
    usedDays: Decimal | null
    carryOverDays: Decimal | null
  }

  export type PTOBalanceSumAggregateOutputType = {
    year: number | null
    totalDays: Decimal | null
    usedDays: Decimal | null
    carryOverDays: Decimal | null
  }

  export type PTOBalanceMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    year: number | null
    totalDays: Decimal | null
    usedDays: Decimal | null
    carryOverDays: Decimal | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PTOBalanceMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    year: number | null
    totalDays: Decimal | null
    usedDays: Decimal | null
    carryOverDays: Decimal | null
    tenantId: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PTOBalanceCountAggregateOutputType = {
    id: number
    employeeId: number
    year: number
    totalDays: number
    usedDays: number
    carryOverDays: number
    tenantId: number
    isDeleted: number
    deletedAt: number
    deletedBy: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PTOBalanceAvgAggregateInputType = {
    year?: true
    totalDays?: true
    usedDays?: true
    carryOverDays?: true
  }

  export type PTOBalanceSumAggregateInputType = {
    year?: true
    totalDays?: true
    usedDays?: true
    carryOverDays?: true
  }

  export type PTOBalanceMinAggregateInputType = {
    id?: true
    employeeId?: true
    year?: true
    totalDays?: true
    usedDays?: true
    carryOverDays?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PTOBalanceMaxAggregateInputType = {
    id?: true
    employeeId?: true
    year?: true
    totalDays?: true
    usedDays?: true
    carryOverDays?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PTOBalanceCountAggregateInputType = {
    id?: true
    employeeId?: true
    year?: true
    totalDays?: true
    usedDays?: true
    carryOverDays?: true
    tenantId?: true
    isDeleted?: true
    deletedAt?: true
    deletedBy?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PTOBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PTOBalance to aggregate.
     */
    where?: PTOBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PTOBalances to fetch.
     */
    orderBy?: PTOBalanceOrderByWithRelationInput | PTOBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PTOBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PTOBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PTOBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PTOBalances
    **/
    _count?: true | PTOBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PTOBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PTOBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PTOBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PTOBalanceMaxAggregateInputType
  }

  export type GetPTOBalanceAggregateType<T extends PTOBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregatePTOBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePTOBalance[P]>
      : GetScalarType<T[P], AggregatePTOBalance[P]>
  }




  export type PTOBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PTOBalanceWhereInput
    orderBy?: PTOBalanceOrderByWithAggregationInput | PTOBalanceOrderByWithAggregationInput[]
    by: PTOBalanceScalarFieldEnum[] | PTOBalanceScalarFieldEnum
    having?: PTOBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PTOBalanceCountAggregateInputType | true
    _avg?: PTOBalanceAvgAggregateInputType
    _sum?: PTOBalanceSumAggregateInputType
    _min?: PTOBalanceMinAggregateInputType
    _max?: PTOBalanceMaxAggregateInputType
  }

  export type PTOBalanceGroupByOutputType = {
    id: string
    employeeId: string
    year: number
    totalDays: Decimal
    usedDays: Decimal
    carryOverDays: Decimal
    tenantId: string | null
    isDeleted: boolean
    deletedAt: Date | null
    deletedBy: string | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: PTOBalanceCountAggregateOutputType | null
    _avg: PTOBalanceAvgAggregateOutputType | null
    _sum: PTOBalanceSumAggregateOutputType | null
    _min: PTOBalanceMinAggregateOutputType | null
    _max: PTOBalanceMaxAggregateOutputType | null
  }

  type GetPTOBalanceGroupByPayload<T extends PTOBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PTOBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PTOBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PTOBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], PTOBalanceGroupByOutputType[P]>
        }
      >
    >


  export type PTOBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    carryOverDays?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pTOBalance"]>

  export type PTOBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    carryOverDays?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pTOBalance"]>

  export type PTOBalanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    carryOverDays?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["pTOBalance"]>

  export type PTOBalanceSelectScalar = {
    id?: boolean
    employeeId?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    carryOverDays?: boolean
    tenantId?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    deletedBy?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PTOBalanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employeeId" | "year" | "totalDays" | "usedDays" | "carryOverDays" | "tenantId" | "isDeleted" | "deletedAt" | "deletedBy" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["pTOBalance"]>
  export type PTOBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PTOBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PTOBalanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PTOBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PTOBalance"
    objects: {
      employee: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      year: number
      totalDays: Prisma.Decimal
      usedDays: Prisma.Decimal
      carryOverDays: Prisma.Decimal
      tenantId: string | null
      isDeleted: boolean
      deletedAt: Date | null
      deletedBy: string | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["pTOBalance"]>
    composites: {}
  }

  type PTOBalanceGetPayload<S extends boolean | null | undefined | PTOBalanceDefaultArgs> = $Result.GetResult<Prisma.$PTOBalancePayload, S>

  type PTOBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PTOBalanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PTOBalanceCountAggregateInputType | true
    }

  export interface PTOBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PTOBalance'], meta: { name: 'PTOBalance' } }
    /**
     * Find zero or one PTOBalance that matches the filter.
     * @param {PTOBalanceFindUniqueArgs} args - Arguments to find a PTOBalance
     * @example
     * // Get one PTOBalance
     * const pTOBalance = await prisma.pTOBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PTOBalanceFindUniqueArgs>(args: SelectSubset<T, PTOBalanceFindUniqueArgs<ExtArgs>>): Prisma__PTOBalanceClient<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PTOBalance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PTOBalanceFindUniqueOrThrowArgs} args - Arguments to find a PTOBalance
     * @example
     * // Get one PTOBalance
     * const pTOBalance = await prisma.pTOBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PTOBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, PTOBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PTOBalanceClient<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PTOBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTOBalanceFindFirstArgs} args - Arguments to find a PTOBalance
     * @example
     * // Get one PTOBalance
     * const pTOBalance = await prisma.pTOBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PTOBalanceFindFirstArgs>(args?: SelectSubset<T, PTOBalanceFindFirstArgs<ExtArgs>>): Prisma__PTOBalanceClient<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PTOBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTOBalanceFindFirstOrThrowArgs} args - Arguments to find a PTOBalance
     * @example
     * // Get one PTOBalance
     * const pTOBalance = await prisma.pTOBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PTOBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, PTOBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__PTOBalanceClient<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PTOBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTOBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PTOBalances
     * const pTOBalances = await prisma.pTOBalance.findMany()
     * 
     * // Get first 10 PTOBalances
     * const pTOBalances = await prisma.pTOBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pTOBalanceWithIdOnly = await prisma.pTOBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PTOBalanceFindManyArgs>(args?: SelectSubset<T, PTOBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PTOBalance.
     * @param {PTOBalanceCreateArgs} args - Arguments to create a PTOBalance.
     * @example
     * // Create one PTOBalance
     * const PTOBalance = await prisma.pTOBalance.create({
     *   data: {
     *     // ... data to create a PTOBalance
     *   }
     * })
     * 
     */
    create<T extends PTOBalanceCreateArgs>(args: SelectSubset<T, PTOBalanceCreateArgs<ExtArgs>>): Prisma__PTOBalanceClient<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PTOBalances.
     * @param {PTOBalanceCreateManyArgs} args - Arguments to create many PTOBalances.
     * @example
     * // Create many PTOBalances
     * const pTOBalance = await prisma.pTOBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PTOBalanceCreateManyArgs>(args?: SelectSubset<T, PTOBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PTOBalances and returns the data saved in the database.
     * @param {PTOBalanceCreateManyAndReturnArgs} args - Arguments to create many PTOBalances.
     * @example
     * // Create many PTOBalances
     * const pTOBalance = await prisma.pTOBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PTOBalances and only return the `id`
     * const pTOBalanceWithIdOnly = await prisma.pTOBalance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PTOBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, PTOBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PTOBalance.
     * @param {PTOBalanceDeleteArgs} args - Arguments to delete one PTOBalance.
     * @example
     * // Delete one PTOBalance
     * const PTOBalance = await prisma.pTOBalance.delete({
     *   where: {
     *     // ... filter to delete one PTOBalance
     *   }
     * })
     * 
     */
    delete<T extends PTOBalanceDeleteArgs>(args: SelectSubset<T, PTOBalanceDeleteArgs<ExtArgs>>): Prisma__PTOBalanceClient<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PTOBalance.
     * @param {PTOBalanceUpdateArgs} args - Arguments to update one PTOBalance.
     * @example
     * // Update one PTOBalance
     * const pTOBalance = await prisma.pTOBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PTOBalanceUpdateArgs>(args: SelectSubset<T, PTOBalanceUpdateArgs<ExtArgs>>): Prisma__PTOBalanceClient<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PTOBalances.
     * @param {PTOBalanceDeleteManyArgs} args - Arguments to filter PTOBalances to delete.
     * @example
     * // Delete a few PTOBalances
     * const { count } = await prisma.pTOBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PTOBalanceDeleteManyArgs>(args?: SelectSubset<T, PTOBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PTOBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTOBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PTOBalances
     * const pTOBalance = await prisma.pTOBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PTOBalanceUpdateManyArgs>(args: SelectSubset<T, PTOBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PTOBalances and returns the data updated in the database.
     * @param {PTOBalanceUpdateManyAndReturnArgs} args - Arguments to update many PTOBalances.
     * @example
     * // Update many PTOBalances
     * const pTOBalance = await prisma.pTOBalance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PTOBalances and only return the `id`
     * const pTOBalanceWithIdOnly = await prisma.pTOBalance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PTOBalanceUpdateManyAndReturnArgs>(args: SelectSubset<T, PTOBalanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PTOBalance.
     * @param {PTOBalanceUpsertArgs} args - Arguments to update or create a PTOBalance.
     * @example
     * // Update or create a PTOBalance
     * const pTOBalance = await prisma.pTOBalance.upsert({
     *   create: {
     *     // ... data to create a PTOBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PTOBalance we want to update
     *   }
     * })
     */
    upsert<T extends PTOBalanceUpsertArgs>(args: SelectSubset<T, PTOBalanceUpsertArgs<ExtArgs>>): Prisma__PTOBalanceClient<$Result.GetResult<Prisma.$PTOBalancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PTOBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTOBalanceCountArgs} args - Arguments to filter PTOBalances to count.
     * @example
     * // Count the number of PTOBalances
     * const count = await prisma.pTOBalance.count({
     *   where: {
     *     // ... the filter for the PTOBalances we want to count
     *   }
     * })
    **/
    count<T extends PTOBalanceCountArgs>(
      args?: Subset<T, PTOBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PTOBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PTOBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTOBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PTOBalanceAggregateArgs>(args: Subset<T, PTOBalanceAggregateArgs>): Prisma.PrismaPromise<GetPTOBalanceAggregateType<T>>

    /**
     * Group by PTOBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PTOBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PTOBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PTOBalanceGroupByArgs['orderBy'] }
        : { orderBy?: PTOBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PTOBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPTOBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PTOBalance model
   */
  readonly fields: PTOBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PTOBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PTOBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PTOBalance model
   */
  interface PTOBalanceFieldRefs {
    readonly id: FieldRef<"PTOBalance", 'String'>
    readonly employeeId: FieldRef<"PTOBalance", 'String'>
    readonly year: FieldRef<"PTOBalance", 'Int'>
    readonly totalDays: FieldRef<"PTOBalance", 'Decimal'>
    readonly usedDays: FieldRef<"PTOBalance", 'Decimal'>
    readonly carryOverDays: FieldRef<"PTOBalance", 'Decimal'>
    readonly tenantId: FieldRef<"PTOBalance", 'String'>
    readonly isDeleted: FieldRef<"PTOBalance", 'Boolean'>
    readonly deletedAt: FieldRef<"PTOBalance", 'DateTime'>
    readonly deletedBy: FieldRef<"PTOBalance", 'String'>
    readonly createdBy: FieldRef<"PTOBalance", 'String'>
    readonly createdAt: FieldRef<"PTOBalance", 'DateTime'>
    readonly updatedAt: FieldRef<"PTOBalance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PTOBalance findUnique
   */
  export type PTOBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
    /**
     * Filter, which PTOBalance to fetch.
     */
    where: PTOBalanceWhereUniqueInput
  }

  /**
   * PTOBalance findUniqueOrThrow
   */
  export type PTOBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
    /**
     * Filter, which PTOBalance to fetch.
     */
    where: PTOBalanceWhereUniqueInput
  }

  /**
   * PTOBalance findFirst
   */
  export type PTOBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
    /**
     * Filter, which PTOBalance to fetch.
     */
    where?: PTOBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PTOBalances to fetch.
     */
    orderBy?: PTOBalanceOrderByWithRelationInput | PTOBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PTOBalances.
     */
    cursor?: PTOBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PTOBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PTOBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PTOBalances.
     */
    distinct?: PTOBalanceScalarFieldEnum | PTOBalanceScalarFieldEnum[]
  }

  /**
   * PTOBalance findFirstOrThrow
   */
  export type PTOBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
    /**
     * Filter, which PTOBalance to fetch.
     */
    where?: PTOBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PTOBalances to fetch.
     */
    orderBy?: PTOBalanceOrderByWithRelationInput | PTOBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PTOBalances.
     */
    cursor?: PTOBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PTOBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PTOBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PTOBalances.
     */
    distinct?: PTOBalanceScalarFieldEnum | PTOBalanceScalarFieldEnum[]
  }

  /**
   * PTOBalance findMany
   */
  export type PTOBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
    /**
     * Filter, which PTOBalances to fetch.
     */
    where?: PTOBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PTOBalances to fetch.
     */
    orderBy?: PTOBalanceOrderByWithRelationInput | PTOBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PTOBalances.
     */
    cursor?: PTOBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PTOBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PTOBalances.
     */
    skip?: number
    distinct?: PTOBalanceScalarFieldEnum | PTOBalanceScalarFieldEnum[]
  }

  /**
   * PTOBalance create
   */
  export type PTOBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a PTOBalance.
     */
    data: XOR<PTOBalanceCreateInput, PTOBalanceUncheckedCreateInput>
  }

  /**
   * PTOBalance createMany
   */
  export type PTOBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PTOBalances.
     */
    data: PTOBalanceCreateManyInput | PTOBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PTOBalance createManyAndReturn
   */
  export type PTOBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * The data used to create many PTOBalances.
     */
    data: PTOBalanceCreateManyInput | PTOBalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PTOBalance update
   */
  export type PTOBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a PTOBalance.
     */
    data: XOR<PTOBalanceUpdateInput, PTOBalanceUncheckedUpdateInput>
    /**
     * Choose, which PTOBalance to update.
     */
    where: PTOBalanceWhereUniqueInput
  }

  /**
   * PTOBalance updateMany
   */
  export type PTOBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PTOBalances.
     */
    data: XOR<PTOBalanceUpdateManyMutationInput, PTOBalanceUncheckedUpdateManyInput>
    /**
     * Filter which PTOBalances to update
     */
    where?: PTOBalanceWhereInput
    /**
     * Limit how many PTOBalances to update.
     */
    limit?: number
  }

  /**
   * PTOBalance updateManyAndReturn
   */
  export type PTOBalanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * The data used to update PTOBalances.
     */
    data: XOR<PTOBalanceUpdateManyMutationInput, PTOBalanceUncheckedUpdateManyInput>
    /**
     * Filter which PTOBalances to update
     */
    where?: PTOBalanceWhereInput
    /**
     * Limit how many PTOBalances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PTOBalance upsert
   */
  export type PTOBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the PTOBalance to update in case it exists.
     */
    where: PTOBalanceWhereUniqueInput
    /**
     * In case the PTOBalance found by the `where` argument doesn't exist, create a new PTOBalance with this data.
     */
    create: XOR<PTOBalanceCreateInput, PTOBalanceUncheckedCreateInput>
    /**
     * In case the PTOBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PTOBalanceUpdateInput, PTOBalanceUncheckedUpdateInput>
  }

  /**
   * PTOBalance delete
   */
  export type PTOBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
    /**
     * Filter which PTOBalance to delete.
     */
    where: PTOBalanceWhereUniqueInput
  }

  /**
   * PTOBalance deleteMany
   */
  export type PTOBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PTOBalances to delete
     */
    where?: PTOBalanceWhereInput
    /**
     * Limit how many PTOBalances to delete.
     */
    limit?: number
  }

  /**
   * PTOBalance without action
   */
  export type PTOBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PTOBalance
     */
    select?: PTOBalanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PTOBalance
     */
    omit?: PTOBalanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PTOBalanceInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const RoleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    permissions: 'permissions',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoleScalarFieldEnum = (typeof RoleScalarFieldEnum)[keyof typeof RoleScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const TaskScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    status: 'status',
    projectId: 'projectId',
    assigneeId: 'assigneeId',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    slug: 'slug',
    summary: 'summary',
    type: 'type',
    status: 'status',
    tags: 'tags',
    parentId: 'parentId',
    authorId: 'authorId',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    publishedAt: 'publishedAt',
    viewCount: 'viewCount',
    lastViewedAt: 'lastViewedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const DocumentRevisionScalarFieldEnum: {
    id: 'id',
    documentId: 'documentId',
    version: 'version',
    title: 'title',
    content: 'content',
    summary: 'summary',
    changeLog: 'changeLog',
    authorId: 'authorId',
    tenantId: 'tenantId',
    createdAt: 'createdAt'
  };

  export type DocumentRevisionScalarFieldEnum = (typeof DocumentRevisionScalarFieldEnum)[keyof typeof DocumentRevisionScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    price: 'price',
    stock: 'stock',
    category: 'category',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const SaleScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    quantity: 'quantity',
    total: 'total',
    soldBy: 'soldBy',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type SaleScalarFieldEnum = (typeof SaleScalarFieldEnum)[keyof typeof SaleScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    accountNumber: 'accountNumber',
    bankName: 'bankName',
    accountType: 'accountType',
    currency: 'currency',
    currentBalance: 'currentBalance',
    isActive: 'isActive',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const TransactionCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    icon: 'icon',
    color: 'color',
    description: 'description',
    isActive: 'isActive',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TransactionCategoryScalarFieldEnum = (typeof TransactionCategoryScalarFieldEnum)[keyof typeof TransactionCategoryScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    description: 'description',
    amount: 'amount',
    type: 'type',
    status: 'status',
    paymentMethod: 'paymentMethod',
    reference: 'reference',
    externalId: 'externalId',
    accountId: 'accountId',
    categoryId: 'categoryId',
    customerName: 'customerName',
    supplierName: 'supplierName',
    employeeName: 'employeeName',
    projectName: 'projectName',
    items: 'items',
    notes: 'notes',
    receiptUrl: 'receiptUrl',
    mpPaymentId: 'mpPaymentId',
    mpStatus: 'mpStatus',
    mpPaymentType: 'mpPaymentType',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    payrollId: 'payrollId'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const BankBalanceScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    balanceDate: 'balanceDate',
    openingBalance: 'openingBalance',
    closingBalance: 'closingBalance',
    totalIncome: 'totalIncome',
    totalExpenses: 'totalExpenses',
    transactionCount: 'transactionCount',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BankBalanceScalarFieldEnum = (typeof BankBalanceScalarFieldEnum)[keyof typeof BankBalanceScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    username: 'username',
    firstName: 'firstName',
    lastName: 'lastName',
    password: 'password',
    isActive: 'isActive',
    roleId: 'roleId',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const MagicTokenScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    purpose: 'purpose',
    tokenHash: 'tokenHash',
    expiresAt: 'expiresAt',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MagicTokenScalarFieldEnum = (typeof MagicTokenScalarFieldEnum)[keyof typeof MagicTokenScalarFieldEnum]


  export const AuditTrailScalarFieldEnum: {
    id: 'id',
    tableName: 'tableName',
    recordId: 'recordId',
    operation: 'operation',
    beforeData: 'beforeData',
    afterData: 'afterData',
    userId: 'userId',
    tenantId: 'tenantId',
    timestamp: 'timestamp',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent'
  };

  export type AuditTrailScalarFieldEnum = (typeof AuditTrailScalarFieldEnum)[keyof typeof AuditTrailScalarFieldEnum]


  export const NotificationTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    type: 'type',
    subject: 'subject',
    content: 'content',
    variables: 'variables',
    isActive: 'isActive',
    createdBy: 'createdBy',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationTemplateScalarFieldEnum = (typeof NotificationTemplateScalarFieldEnum)[keyof typeof NotificationTemplateScalarFieldEnum]


  export const NotificationRuleScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    trigger: 'trigger',
    conditions: 'conditions',
    isActive: 'isActive',
    templateId: 'templateId',
    recipients: 'recipients',
    delay: 'delay',
    createdBy: 'createdBy',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationRuleScalarFieldEnum = (typeof NotificationRuleScalarFieldEnum)[keyof typeof NotificationRuleScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    type: 'type',
    status: 'status',
    subject: 'subject',
    content: 'content',
    recipientId: 'recipientId',
    templateId: 'templateId',
    ruleId: 'ruleId',
    entityType: 'entityType',
    entityId: 'entityId',
    metadata: 'metadata',
    scheduledAt: 'scheduledAt',
    sentAt: 'sentAt',
    failedAt: 'failedAt',
    errorMessage: 'errorMessage',
    readAt: 'readAt',
    tenantId: 'tenantId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const PayrollScalarFieldEnum: {
    id: 'id',
    runDate: 'runDate',
    payPeriodStart: 'payPeriodStart',
    payPeriodEnd: 'payPeriodEnd',
    status: 'status',
    totalGrossPay: 'totalGrossPay',
    totalDeductions: 'totalDeductions',
    totalNetPay: 'totalNetPay',
    notes: 'notes',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    processedBy: 'processedBy',
    processedAt: 'processedAt',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


  export const PayrollEntryScalarFieldEnum: {
    id: 'id',
    payrollId: 'payrollId',
    employeeId: 'employeeId',
    baseSalary: 'baseSalary',
    hoursWorked: 'hoursWorked',
    overtimeHours: 'overtimeHours',
    bonusAmount: 'bonusAmount',
    allowances: 'allowances',
    grossPay: 'grossPay',
    taxDeductions: 'taxDeductions',
    socialSecurity: 'socialSecurity',
    otherDeductions: 'otherDeductions',
    netPay: 'netPay',
    notes: 'notes',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollEntryScalarFieldEnum = (typeof PayrollEntryScalarFieldEnum)[keyof typeof PayrollEntryScalarFieldEnum]


  export const SalaryAdjustmentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    adjustmentType: 'adjustmentType',
    previousAmount: 'previousAmount',
    newAmount: 'newAmount',
    effectiveDate: 'effectiveDate',
    reason: 'reason',
    notes: 'notes',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SalaryAdjustmentScalarFieldEnum = (typeof SalaryAdjustmentScalarFieldEnum)[keyof typeof SalaryAdjustmentScalarFieldEnum]


  export const EmployeeExpenseScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    description: 'description',
    amount: 'amount',
    category: 'category',
    expenseDate: 'expenseDate',
    receiptUrl: 'receiptUrl',
    status: 'status',
    submittedAt: 'submittedAt',
    reviewedBy: 'reviewedBy',
    reviewedAt: 'reviewedAt',
    reimbursedAt: 'reimbursedAt',
    reimbursementTransactionId: 'reimbursementTransactionId',
    notes: 'notes',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeExpenseScalarFieldEnum = (typeof EmployeeExpenseScalarFieldEnum)[keyof typeof EmployeeExpenseScalarFieldEnum]


  export const PTORequestScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    startDate: 'startDate',
    endDate: 'endDate',
    totalDays: 'totalDays',
    status: 'status',
    reason: 'reason',
    submittedAt: 'submittedAt',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    rejectedAt: 'rejectedAt',
    cancelledAt: 'cancelledAt',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PTORequestScalarFieldEnum = (typeof PTORequestScalarFieldEnum)[keyof typeof PTORequestScalarFieldEnum]


  export const PTOBalanceScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    year: 'year',
    totalDays: 'totalDays',
    usedDays: 'usedDays',
    carryOverDays: 'carryOverDays',
    tenantId: 'tenantId',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    deletedBy: 'deletedBy',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PTOBalanceScalarFieldEnum = (typeof PTOBalanceScalarFieldEnum)[keyof typeof PTOBalanceScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'DocumentType'
   */
  export type EnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType'>
    


  /**
   * Reference to a field of type 'DocumentType[]'
   */
  export type ListEnumDocumentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentType[]'>
    


  /**
   * Reference to a field of type 'DocumentStatus'
   */
  export type EnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus'>
    


  /**
   * Reference to a field of type 'DocumentStatus[]'
   */
  export type ListEnumDocumentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AuditOperation'
   */
  export type EnumAuditOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditOperation'>
    


  /**
   * Reference to a field of type 'AuditOperation[]'
   */
  export type ListEnumAuditOperationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuditOperation[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'RuleTrigger'
   */
  export type EnumRuleTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RuleTrigger'>
    


  /**
   * Reference to a field of type 'RuleTrigger[]'
   */
  export type ListEnumRuleTriggerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RuleTrigger[]'>
    


  /**
   * Reference to a field of type 'NotificationStatus'
   */
  export type EnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus'>
    


  /**
   * Reference to a field of type 'NotificationStatus[]'
   */
  export type ListEnumNotificationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationStatus[]'>
    


  /**
   * Reference to a field of type 'PayrollStatus'
   */
  export type EnumPayrollStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollStatus'>
    


  /**
   * Reference to a field of type 'PayrollStatus[]'
   */
  export type ListEnumPayrollStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PayrollStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'SalaryAdjustmentType'
   */
  export type EnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalaryAdjustmentType'>
    


  /**
   * Reference to a field of type 'SalaryAdjustmentType[]'
   */
  export type ListEnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SalaryAdjustmentType[]'>
    


  /**
   * Reference to a field of type 'ExpenseStatus'
   */
  export type EnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus'>
    


  /**
   * Reference to a field of type 'ExpenseStatus[]'
   */
  export type ListEnumExpenseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExpenseStatus[]'>
    


  /**
   * Reference to a field of type 'PTOStatus'
   */
  export type EnumPTOStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PTOStatus'>
    


  /**
   * Reference to a field of type 'PTOStatus[]'
   */
  export type ListEnumPTOStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PTOStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type RoleWhereInput = {
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    id?: StringFilter<"Role"> | string
    name?: StringFilter<"Role"> | string
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: StringNullableListFilter<"Role">
    tenantId?: StringNullableFilter<"Role"> | string | null
    isDeleted?: BoolFilter<"Role"> | boolean
    deletedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    deletedBy?: StringNullableFilter<"Role"> | string | null
    createdBy?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }

  export type RoleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
  }

  export type RoleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: RoleWhereInput | RoleWhereInput[]
    OR?: RoleWhereInput[]
    NOT?: RoleWhereInput | RoleWhereInput[]
    description?: StringNullableFilter<"Role"> | string | null
    permissions?: StringNullableListFilter<"Role">
    tenantId?: StringNullableFilter<"Role"> | string | null
    isDeleted?: BoolFilter<"Role"> | boolean
    deletedAt?: DateTimeNullableFilter<"Role"> | Date | string | null
    deletedBy?: StringNullableFilter<"Role"> | string | null
    createdBy?: StringNullableFilter<"Role"> | string | null
    createdAt?: DateTimeFilter<"Role"> | Date | string
    updatedAt?: DateTimeFilter<"Role"> | Date | string
    users?: UserListRelationFilter
  }, "id" | "name">

  export type RoleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    permissions?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoleCountOrderByAggregateInput
    _max?: RoleMaxOrderByAggregateInput
    _min?: RoleMinOrderByAggregateInput
  }

  export type RoleScalarWhereWithAggregatesInput = {
    AND?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    OR?: RoleScalarWhereWithAggregatesInput[]
    NOT?: RoleScalarWhereWithAggregatesInput | RoleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Role"> | string
    name?: StringWithAggregatesFilter<"Role"> | string
    description?: StringNullableWithAggregatesFilter<"Role"> | string | null
    permissions?: StringNullableListFilter<"Role">
    tenantId?: StringNullableWithAggregatesFilter<"Role"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Role"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Role"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Role"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Role"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    tenantId?: StringNullableFilter<"Project"> | string | null
    isDeleted?: BoolFilter<"Project"> | boolean
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    deletedBy?: StringNullableFilter<"Project"> | string | null
    createdBy?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    tasks?: TaskListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tasks?: TaskOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    name?: StringFilter<"Project"> | string
    description?: StringNullableFilter<"Project"> | string | null
    tenantId?: StringNullableFilter<"Project"> | string | null
    isDeleted?: BoolFilter<"Project"> | boolean
    deletedAt?: DateTimeNullableFilter<"Project"> | Date | string | null
    deletedBy?: StringNullableFilter<"Project"> | string | null
    createdBy?: StringNullableFilter<"Project"> | string | null
    createdAt?: DateTimeFilter<"Project"> | Date | string
    updatedAt?: DateTimeFilter<"Project"> | Date | string
    tasks?: TaskListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    name?: StringWithAggregatesFilter<"Project"> | string
    description?: StringNullableWithAggregatesFilter<"Project"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"Project"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Project"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Project"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type TaskWhereInput = {
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    projectId?: StringFilter<"Task"> | string
    assigneeId?: StringNullableFilter<"Task"> | string | null
    tenantId?: StringNullableFilter<"Task"> | string | null
    isDeleted?: BoolFilter<"Task"> | boolean
    deletedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    deletedBy?: StringNullableFilter<"Task"> | string | null
    createdBy?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type TaskOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    projectId?: SortOrder
    assigneeId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    project?: ProjectOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
  }

  export type TaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TaskWhereInput | TaskWhereInput[]
    OR?: TaskWhereInput[]
    NOT?: TaskWhereInput | TaskWhereInput[]
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    projectId?: StringFilter<"Task"> | string
    assigneeId?: StringNullableFilter<"Task"> | string | null
    tenantId?: StringNullableFilter<"Task"> | string | null
    isDeleted?: BoolFilter<"Task"> | boolean
    deletedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    deletedBy?: StringNullableFilter<"Task"> | string | null
    createdBy?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type TaskOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    projectId?: SortOrder
    assigneeId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TaskCountOrderByAggregateInput
    _max?: TaskMaxOrderByAggregateInput
    _min?: TaskMinOrderByAggregateInput
  }

  export type TaskScalarWhereWithAggregatesInput = {
    AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    OR?: TaskScalarWhereWithAggregatesInput[]
    NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Task"> | string
    title?: StringWithAggregatesFilter<"Task"> | string
    description?: StringNullableWithAggregatesFilter<"Task"> | string | null
    status?: EnumTaskStatusWithAggregatesFilter<"Task"> | $Enums.TaskStatus
    projectId?: StringWithAggregatesFilter<"Task"> | string
    assigneeId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"Task"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Task"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Task"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Task"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Task"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    content?: StringFilter<"Document"> | string
    slug?: StringFilter<"Document"> | string
    summary?: StringNullableFilter<"Document"> | string | null
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    tags?: StringNullableListFilter<"Document">
    parentId?: StringNullableFilter<"Document"> | string | null
    authorId?: StringFilter<"Document"> | string
    tenantId?: StringNullableFilter<"Document"> | string | null
    isDeleted?: BoolFilter<"Document"> | boolean
    deletedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    deletedBy?: StringNullableFilter<"Document"> | string | null
    createdBy?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    viewCount?: IntFilter<"Document"> | number
    lastViewedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    parent?: XOR<DocumentNullableScalarRelationFilter, DocumentWhereInput> | null
    children?: DocumentListRelationFilter
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    revisions?: DocumentRevisionListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    summary?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    parentId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    parent?: DocumentOrderByWithRelationInput
    children?: DocumentOrderByRelationAggregateInput
    author?: UserOrderByWithRelationInput
    revisions?: DocumentRevisionOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    title?: StringFilter<"Document"> | string
    content?: StringFilter<"Document"> | string
    summary?: StringNullableFilter<"Document"> | string | null
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    tags?: StringNullableListFilter<"Document">
    parentId?: StringNullableFilter<"Document"> | string | null
    authorId?: StringFilter<"Document"> | string
    tenantId?: StringNullableFilter<"Document"> | string | null
    isDeleted?: BoolFilter<"Document"> | boolean
    deletedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    deletedBy?: StringNullableFilter<"Document"> | string | null
    createdBy?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    viewCount?: IntFilter<"Document"> | number
    lastViewedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    parent?: XOR<DocumentNullableScalarRelationFilter, DocumentWhereInput> | null
    children?: DocumentListRelationFilter
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
    revisions?: DocumentRevisionListRelationFilter
  }, "id" | "slug">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    summary?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    parentId?: SortOrderInput | SortOrder
    authorId?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrderInput | SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    title?: StringWithAggregatesFilter<"Document"> | string
    content?: StringWithAggregatesFilter<"Document"> | string
    slug?: StringWithAggregatesFilter<"Document"> | string
    summary?: StringNullableWithAggregatesFilter<"Document"> | string | null
    type?: EnumDocumentTypeWithAggregatesFilter<"Document"> | $Enums.DocumentType
    status?: EnumDocumentStatusWithAggregatesFilter<"Document"> | $Enums.DocumentStatus
    tags?: StringNullableListFilter<"Document">
    parentId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    authorId?: StringWithAggregatesFilter<"Document"> | string
    tenantId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Document"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    publishedAt?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
    viewCount?: IntWithAggregatesFilter<"Document"> | number
    lastViewedAt?: DateTimeNullableWithAggregatesFilter<"Document"> | Date | string | null
  }

  export type DocumentRevisionWhereInput = {
    AND?: DocumentRevisionWhereInput | DocumentRevisionWhereInput[]
    OR?: DocumentRevisionWhereInput[]
    NOT?: DocumentRevisionWhereInput | DocumentRevisionWhereInput[]
    id?: StringFilter<"DocumentRevision"> | string
    documentId?: StringFilter<"DocumentRevision"> | string
    version?: IntFilter<"DocumentRevision"> | number
    title?: StringFilter<"DocumentRevision"> | string
    content?: StringFilter<"DocumentRevision"> | string
    summary?: StringNullableFilter<"DocumentRevision"> | string | null
    changeLog?: StringNullableFilter<"DocumentRevision"> | string | null
    authorId?: StringFilter<"DocumentRevision"> | string
    tenantId?: StringNullableFilter<"DocumentRevision"> | string | null
    createdAt?: DateTimeFilter<"DocumentRevision"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DocumentRevisionOrderByWithRelationInput = {
    id?: SortOrder
    documentId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    changeLog?: SortOrderInput | SortOrder
    authorId?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    document?: DocumentOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type DocumentRevisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    documentId_version?: DocumentRevisionDocumentIdVersionCompoundUniqueInput
    AND?: DocumentRevisionWhereInput | DocumentRevisionWhereInput[]
    OR?: DocumentRevisionWhereInput[]
    NOT?: DocumentRevisionWhereInput | DocumentRevisionWhereInput[]
    documentId?: StringFilter<"DocumentRevision"> | string
    version?: IntFilter<"DocumentRevision"> | number
    title?: StringFilter<"DocumentRevision"> | string
    content?: StringFilter<"DocumentRevision"> | string
    summary?: StringNullableFilter<"DocumentRevision"> | string | null
    changeLog?: StringNullableFilter<"DocumentRevision"> | string | null
    authorId?: StringFilter<"DocumentRevision"> | string
    tenantId?: StringNullableFilter<"DocumentRevision"> | string | null
    createdAt?: DateTimeFilter<"DocumentRevision"> | Date | string
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "documentId_version">

  export type DocumentRevisionOrderByWithAggregationInput = {
    id?: SortOrder
    documentId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrderInput | SortOrder
    changeLog?: SortOrderInput | SortOrder
    authorId?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DocumentRevisionCountOrderByAggregateInput
    _avg?: DocumentRevisionAvgOrderByAggregateInput
    _max?: DocumentRevisionMaxOrderByAggregateInput
    _min?: DocumentRevisionMinOrderByAggregateInput
    _sum?: DocumentRevisionSumOrderByAggregateInput
  }

  export type DocumentRevisionScalarWhereWithAggregatesInput = {
    AND?: DocumentRevisionScalarWhereWithAggregatesInput | DocumentRevisionScalarWhereWithAggregatesInput[]
    OR?: DocumentRevisionScalarWhereWithAggregatesInput[]
    NOT?: DocumentRevisionScalarWhereWithAggregatesInput | DocumentRevisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentRevision"> | string
    documentId?: StringWithAggregatesFilter<"DocumentRevision"> | string
    version?: IntWithAggregatesFilter<"DocumentRevision"> | number
    title?: StringWithAggregatesFilter<"DocumentRevision"> | string
    content?: StringWithAggregatesFilter<"DocumentRevision"> | string
    summary?: StringNullableWithAggregatesFilter<"DocumentRevision"> | string | null
    changeLog?: StringNullableWithAggregatesFilter<"DocumentRevision"> | string | null
    authorId?: StringWithAggregatesFilter<"DocumentRevision"> | string
    tenantId?: StringNullableWithAggregatesFilter<"DocumentRevision"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentRevision"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    category?: StringNullableFilter<"Product"> | string | null
    tenantId?: StringNullableFilter<"Product"> | string | null
    isDeleted?: BoolFilter<"Product"> | boolean
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deletedBy?: StringNullableFilter<"Product"> | string | null
    createdBy?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    sales?: SaleListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    sales?: SaleOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    name?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    price?: FloatFilter<"Product"> | number
    stock?: IntFilter<"Product"> | number
    category?: StringNullableFilter<"Product"> | string | null
    tenantId?: StringNullableFilter<"Product"> | string | null
    isDeleted?: BoolFilter<"Product"> | boolean
    deletedAt?: DateTimeNullableFilter<"Product"> | Date | string | null
    deletedBy?: StringNullableFilter<"Product"> | string | null
    createdBy?: StringNullableFilter<"Product"> | string | null
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    sales?: SaleListRelationFilter
  }, "id">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    name?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    price?: FloatWithAggregatesFilter<"Product"> | number
    stock?: IntWithAggregatesFilter<"Product"> | number
    category?: StringNullableWithAggregatesFilter<"Product"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"Product"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Product"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Product"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Product"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type SaleWhereInput = {
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    id?: StringFilter<"Sale"> | string
    productId?: StringFilter<"Sale"> | string
    quantity?: IntFilter<"Sale"> | number
    total?: FloatFilter<"Sale"> | number
    soldBy?: StringFilter<"Sale"> | string
    tenantId?: StringNullableFilter<"Sale"> | string | null
    isDeleted?: BoolFilter<"Sale"> | boolean
    deletedAt?: DateTimeNullableFilter<"Sale"> | Date | string | null
    deletedBy?: StringNullableFilter<"Sale"> | string | null
    createdBy?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SaleOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    soldBy?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    seller?: UserOrderByWithRelationInput
  }

  export type SaleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SaleWhereInput | SaleWhereInput[]
    OR?: SaleWhereInput[]
    NOT?: SaleWhereInput | SaleWhereInput[]
    productId?: StringFilter<"Sale"> | string
    quantity?: IntFilter<"Sale"> | number
    total?: FloatFilter<"Sale"> | number
    soldBy?: StringFilter<"Sale"> | string
    tenantId?: StringNullableFilter<"Sale"> | string | null
    isDeleted?: BoolFilter<"Sale"> | boolean
    deletedAt?: DateTimeNullableFilter<"Sale"> | Date | string | null
    deletedBy?: StringNullableFilter<"Sale"> | string | null
    createdBy?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    seller?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SaleOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    soldBy?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SaleCountOrderByAggregateInput
    _avg?: SaleAvgOrderByAggregateInput
    _max?: SaleMaxOrderByAggregateInput
    _min?: SaleMinOrderByAggregateInput
    _sum?: SaleSumOrderByAggregateInput
  }

  export type SaleScalarWhereWithAggregatesInput = {
    AND?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    OR?: SaleScalarWhereWithAggregatesInput[]
    NOT?: SaleScalarWhereWithAggregatesInput | SaleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sale"> | string
    productId?: StringWithAggregatesFilter<"Sale"> | string
    quantity?: IntWithAggregatesFilter<"Sale"> | number
    total?: FloatWithAggregatesFilter<"Sale"> | number
    soldBy?: StringWithAggregatesFilter<"Sale"> | string
    tenantId?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Sale"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Sale"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Sale"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Sale"> | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    name?: StringFilter<"BankAccount"> | string
    accountNumber?: StringNullableFilter<"BankAccount"> | string | null
    bankName?: StringNullableFilter<"BankAccount"> | string | null
    accountType?: StringNullableFilter<"BankAccount"> | string | null
    currency?: StringFilter<"BankAccount"> | string
    currentBalance?: FloatFilter<"BankAccount"> | number
    isActive?: BoolFilter<"BankAccount"> | boolean
    tenantId?: StringNullableFilter<"BankAccount"> | string | null
    isDeleted?: BoolFilter<"BankAccount"> | boolean
    deletedAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    deletedBy?: StringNullableFilter<"BankAccount"> | string | null
    createdBy?: StringNullableFilter<"BankAccount"> | string | null
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    transactions?: TransactionListRelationFilter
    balanceHistory?: BankBalanceListRelationFilter
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountType?: SortOrderInput | SortOrder
    currency?: SortOrder
    currentBalance?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
    balanceHistory?: BankBalanceOrderByRelationAggregateInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    name?: StringFilter<"BankAccount"> | string
    accountNumber?: StringNullableFilter<"BankAccount"> | string | null
    bankName?: StringNullableFilter<"BankAccount"> | string | null
    accountType?: StringNullableFilter<"BankAccount"> | string | null
    currency?: StringFilter<"BankAccount"> | string
    currentBalance?: FloatFilter<"BankAccount"> | number
    isActive?: BoolFilter<"BankAccount"> | boolean
    tenantId?: StringNullableFilter<"BankAccount"> | string | null
    isDeleted?: BoolFilter<"BankAccount"> | boolean
    deletedAt?: DateTimeNullableFilter<"BankAccount"> | Date | string | null
    deletedBy?: StringNullableFilter<"BankAccount"> | string | null
    createdBy?: StringNullableFilter<"BankAccount"> | string | null
    createdAt?: DateTimeFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeFilter<"BankAccount"> | Date | string
    transactions?: TransactionListRelationFilter
    balanceHistory?: BankBalanceListRelationFilter
  }, "id">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrderInput | SortOrder
    bankName?: SortOrderInput | SortOrder
    accountType?: SortOrderInput | SortOrder
    currency?: SortOrder
    currentBalance?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankAccount"> | string
    name?: StringWithAggregatesFilter<"BankAccount"> | string
    accountNumber?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    bankName?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    accountType?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    currency?: StringWithAggregatesFilter<"BankAccount"> | string
    currentBalance?: FloatWithAggregatesFilter<"BankAccount"> | number
    isActive?: BoolWithAggregatesFilter<"BankAccount"> | boolean
    tenantId?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"BankAccount"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BankAccount"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
  }

  export type TransactionCategoryWhereInput = {
    AND?: TransactionCategoryWhereInput | TransactionCategoryWhereInput[]
    OR?: TransactionCategoryWhereInput[]
    NOT?: TransactionCategoryWhereInput | TransactionCategoryWhereInput[]
    id?: StringFilter<"TransactionCategory"> | string
    name?: StringFilter<"TransactionCategory"> | string
    icon?: StringNullableFilter<"TransactionCategory"> | string | null
    color?: StringNullableFilter<"TransactionCategory"> | string | null
    description?: StringNullableFilter<"TransactionCategory"> | string | null
    isActive?: BoolFilter<"TransactionCategory"> | boolean
    tenantId?: StringNullableFilter<"TransactionCategory"> | string | null
    isDeleted?: BoolFilter<"TransactionCategory"> | boolean
    deletedAt?: DateTimeNullableFilter<"TransactionCategory"> | Date | string | null
    deletedBy?: StringNullableFilter<"TransactionCategory"> | string | null
    createdBy?: StringNullableFilter<"TransactionCategory"> | string | null
    createdAt?: DateTimeFilter<"TransactionCategory"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionCategory"> | Date | string
    transactions?: TransactionListRelationFilter
  }

  export type TransactionCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type TransactionCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: TransactionCategoryWhereInput | TransactionCategoryWhereInput[]
    OR?: TransactionCategoryWhereInput[]
    NOT?: TransactionCategoryWhereInput | TransactionCategoryWhereInput[]
    icon?: StringNullableFilter<"TransactionCategory"> | string | null
    color?: StringNullableFilter<"TransactionCategory"> | string | null
    description?: StringNullableFilter<"TransactionCategory"> | string | null
    isActive?: BoolFilter<"TransactionCategory"> | boolean
    tenantId?: StringNullableFilter<"TransactionCategory"> | string | null
    isDeleted?: BoolFilter<"TransactionCategory"> | boolean
    deletedAt?: DateTimeNullableFilter<"TransactionCategory"> | Date | string | null
    deletedBy?: StringNullableFilter<"TransactionCategory"> | string | null
    createdBy?: StringNullableFilter<"TransactionCategory"> | string | null
    createdAt?: DateTimeFilter<"TransactionCategory"> | Date | string
    updatedAt?: DateTimeFilter<"TransactionCategory"> | Date | string
    transactions?: TransactionListRelationFilter
  }, "id" | "name">

  export type TransactionCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    isActive?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TransactionCategoryCountOrderByAggregateInput
    _max?: TransactionCategoryMaxOrderByAggregateInput
    _min?: TransactionCategoryMinOrderByAggregateInput
  }

  export type TransactionCategoryScalarWhereWithAggregatesInput = {
    AND?: TransactionCategoryScalarWhereWithAggregatesInput | TransactionCategoryScalarWhereWithAggregatesInput[]
    OR?: TransactionCategoryScalarWhereWithAggregatesInput[]
    NOT?: TransactionCategoryScalarWhereWithAggregatesInput | TransactionCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionCategory"> | string
    name?: StringWithAggregatesFilter<"TransactionCategory"> | string
    icon?: StringNullableWithAggregatesFilter<"TransactionCategory"> | string | null
    color?: StringNullableWithAggregatesFilter<"TransactionCategory"> | string | null
    description?: StringNullableWithAggregatesFilter<"TransactionCategory"> | string | null
    isActive?: BoolWithAggregatesFilter<"TransactionCategory"> | boolean
    tenantId?: StringNullableWithAggregatesFilter<"TransactionCategory"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"TransactionCategory"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"TransactionCategory"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"TransactionCategory"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"TransactionCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TransactionCategory"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TransactionCategory"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    description?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"Transaction"> | string | null
    externalId?: StringNullableFilter<"Transaction"> | string | null
    accountId?: StringFilter<"Transaction"> | string
    categoryId?: StringNullableFilter<"Transaction"> | string | null
    customerName?: StringNullableFilter<"Transaction"> | string | null
    supplierName?: StringNullableFilter<"Transaction"> | string | null
    employeeName?: StringNullableFilter<"Transaction"> | string | null
    projectName?: StringNullableFilter<"Transaction"> | string | null
    items?: JsonNullableFilter<"Transaction">
    notes?: StringNullableFilter<"Transaction"> | string | null
    receiptUrl?: StringNullableFilter<"Transaction"> | string | null
    mpPaymentId?: StringNullableFilter<"Transaction"> | string | null
    mpStatus?: StringNullableFilter<"Transaction"> | string | null
    mpPaymentType?: StringNullableFilter<"Transaction"> | string | null
    tenantId?: StringNullableFilter<"Transaction"> | string | null
    isDeleted?: BoolFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    deletedBy?: StringNullableFilter<"Transaction"> | string | null
    createdBy?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    payrollId?: StringNullableFilter<"Transaction"> | string | null
    account?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
    category?: XOR<TransactionCategoryNullableScalarRelationFilter, TransactionCategoryWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    payroll?: XOR<PayrollNullableScalarRelationFilter, PayrollWhereInput> | null
    expenseReimbursement?: XOR<EmployeeExpenseNullableScalarRelationFilter, EmployeeExpenseWhereInput> | null
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    accountId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    supplierName?: SortOrderInput | SortOrder
    employeeName?: SortOrderInput | SortOrder
    projectName?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    mpPaymentId?: SortOrderInput | SortOrder
    mpStatus?: SortOrderInput | SortOrder
    mpPaymentType?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payrollId?: SortOrderInput | SortOrder
    account?: BankAccountOrderByWithRelationInput
    category?: TransactionCategoryOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    payroll?: PayrollOrderByWithRelationInput
    expenseReimbursement?: EmployeeExpenseOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reference?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    description?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    externalId?: StringNullableFilter<"Transaction"> | string | null
    accountId?: StringFilter<"Transaction"> | string
    categoryId?: StringNullableFilter<"Transaction"> | string | null
    customerName?: StringNullableFilter<"Transaction"> | string | null
    supplierName?: StringNullableFilter<"Transaction"> | string | null
    employeeName?: StringNullableFilter<"Transaction"> | string | null
    projectName?: StringNullableFilter<"Transaction"> | string | null
    items?: JsonNullableFilter<"Transaction">
    notes?: StringNullableFilter<"Transaction"> | string | null
    receiptUrl?: StringNullableFilter<"Transaction"> | string | null
    mpPaymentId?: StringNullableFilter<"Transaction"> | string | null
    mpStatus?: StringNullableFilter<"Transaction"> | string | null
    mpPaymentType?: StringNullableFilter<"Transaction"> | string | null
    tenantId?: StringNullableFilter<"Transaction"> | string | null
    isDeleted?: BoolFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    deletedBy?: StringNullableFilter<"Transaction"> | string | null
    createdBy?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    payrollId?: StringNullableFilter<"Transaction"> | string | null
    account?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
    category?: XOR<TransactionCategoryNullableScalarRelationFilter, TransactionCategoryWhereInput> | null
    creator?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    payroll?: XOR<PayrollNullableScalarRelationFilter, PayrollWhereInput> | null
    expenseReimbursement?: XOR<EmployeeExpenseNullableScalarRelationFilter, EmployeeExpenseWhereInput> | null
  }, "id" | "reference">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    accountId?: SortOrder
    categoryId?: SortOrderInput | SortOrder
    customerName?: SortOrderInput | SortOrder
    supplierName?: SortOrderInput | SortOrder
    employeeName?: SortOrderInput | SortOrder
    projectName?: SortOrderInput | SortOrder
    items?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    mpPaymentId?: SortOrderInput | SortOrder
    mpStatus?: SortOrderInput | SortOrder
    mpPaymentType?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payrollId?: SortOrderInput | SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    description?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: FloatWithAggregatesFilter<"Transaction"> | number
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusWithAggregatesFilter<"Transaction"> | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Transaction"> | $Enums.PaymentMethod
    reference?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    accountId?: StringWithAggregatesFilter<"Transaction"> | string
    categoryId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    customerName?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    supplierName?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    employeeName?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    projectName?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    items?: JsonNullableWithAggregatesFilter<"Transaction">
    notes?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    receiptUrl?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    mpPaymentId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    mpStatus?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    mpPaymentType?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Transaction"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    payrollId?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
  }

  export type BankBalanceWhereInput = {
    AND?: BankBalanceWhereInput | BankBalanceWhereInput[]
    OR?: BankBalanceWhereInput[]
    NOT?: BankBalanceWhereInput | BankBalanceWhereInput[]
    id?: StringFilter<"BankBalance"> | string
    accountId?: StringFilter<"BankBalance"> | string
    balanceDate?: DateTimeFilter<"BankBalance"> | Date | string
    openingBalance?: FloatFilter<"BankBalance"> | number
    closingBalance?: FloatFilter<"BankBalance"> | number
    totalIncome?: FloatFilter<"BankBalance"> | number
    totalExpenses?: FloatFilter<"BankBalance"> | number
    transactionCount?: IntFilter<"BankBalance"> | number
    tenantId?: StringNullableFilter<"BankBalance"> | string | null
    createdAt?: DateTimeFilter<"BankBalance"> | Date | string
    updatedAt?: DateTimeFilter<"BankBalance"> | Date | string
    account?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
  }

  export type BankBalanceOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    balanceDate?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    transactionCount?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: BankAccountOrderByWithRelationInput
  }

  export type BankBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    balanceDate?: Date | string
    AND?: BankBalanceWhereInput | BankBalanceWhereInput[]
    OR?: BankBalanceWhereInput[]
    NOT?: BankBalanceWhereInput | BankBalanceWhereInput[]
    accountId?: StringFilter<"BankBalance"> | string
    openingBalance?: FloatFilter<"BankBalance"> | number
    closingBalance?: FloatFilter<"BankBalance"> | number
    totalIncome?: FloatFilter<"BankBalance"> | number
    totalExpenses?: FloatFilter<"BankBalance"> | number
    transactionCount?: IntFilter<"BankBalance"> | number
    tenantId?: StringNullableFilter<"BankBalance"> | string | null
    createdAt?: DateTimeFilter<"BankBalance"> | Date | string
    updatedAt?: DateTimeFilter<"BankBalance"> | Date | string
    account?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
  }, "id" | "balanceDate">

  export type BankBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    balanceDate?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    transactionCount?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BankBalanceCountOrderByAggregateInput
    _avg?: BankBalanceAvgOrderByAggregateInput
    _max?: BankBalanceMaxOrderByAggregateInput
    _min?: BankBalanceMinOrderByAggregateInput
    _sum?: BankBalanceSumOrderByAggregateInput
  }

  export type BankBalanceScalarWhereWithAggregatesInput = {
    AND?: BankBalanceScalarWhereWithAggregatesInput | BankBalanceScalarWhereWithAggregatesInput[]
    OR?: BankBalanceScalarWhereWithAggregatesInput[]
    NOT?: BankBalanceScalarWhereWithAggregatesInput | BankBalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankBalance"> | string
    accountId?: StringWithAggregatesFilter<"BankBalance"> | string
    balanceDate?: DateTimeWithAggregatesFilter<"BankBalance"> | Date | string
    openingBalance?: FloatWithAggregatesFilter<"BankBalance"> | number
    closingBalance?: FloatWithAggregatesFilter<"BankBalance"> | number
    totalIncome?: FloatWithAggregatesFilter<"BankBalance"> | number
    totalExpenses?: FloatWithAggregatesFilter<"BankBalance"> | number
    transactionCount?: IntWithAggregatesFilter<"BankBalance"> | number
    tenantId?: StringNullableWithAggregatesFilter<"BankBalance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BankBalance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BankBalance"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    roleId?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedBy?: StringNullableFilter<"User"> | string | null
    createdBy?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    tasks?: TaskListRelationFilter
    documents?: DocumentListRelationFilter
    documentRevisions?: DocumentRevisionListRelationFilter
    sales?: SaleListRelationFilter
    transactions?: TransactionListRelationFilter
    auditTrails?: AuditTrailListRelationFilter
    notificationTemplatesCreated?: NotificationTemplateListRelationFilter
    notificationRulesCreated?: NotificationRuleListRelationFilter
    notifications?: NotificationListRelationFilter
    magicTokens?: MagicTokenListRelationFilter
    payrollsApproved?: PayrollListRelationFilter
    payrollsProcessed?: PayrollListRelationFilter
    payrollEntries?: PayrollEntryListRelationFilter
    salaryAdjustments?: SalaryAdjustmentListRelationFilter
    salaryAdjustmentsApproved?: SalaryAdjustmentListRelationFilter
    employeeExpenses?: EmployeeExpenseListRelationFilter
    expenseReviews?: EmployeeExpenseListRelationFilter
    ptoRequests?: PTORequestListRelationFilter
    ptoApprovals?: PTORequestListRelationFilter
    ptoBalances?: PTOBalanceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    roleId?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    role?: RoleOrderByWithRelationInput
    tasks?: TaskOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    documentRevisions?: DocumentRevisionOrderByRelationAggregateInput
    sales?: SaleOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    auditTrails?: AuditTrailOrderByRelationAggregateInput
    notificationTemplatesCreated?: NotificationTemplateOrderByRelationAggregateInput
    notificationRulesCreated?: NotificationRuleOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    magicTokens?: MagicTokenOrderByRelationAggregateInput
    payrollsApproved?: PayrollOrderByRelationAggregateInput
    payrollsProcessed?: PayrollOrderByRelationAggregateInput
    payrollEntries?: PayrollEntryOrderByRelationAggregateInput
    salaryAdjustments?: SalaryAdjustmentOrderByRelationAggregateInput
    salaryAdjustmentsApproved?: SalaryAdjustmentOrderByRelationAggregateInput
    employeeExpenses?: EmployeeExpenseOrderByRelationAggregateInput
    expenseReviews?: EmployeeExpenseOrderByRelationAggregateInput
    ptoRequests?: PTORequestOrderByRelationAggregateInput
    ptoApprovals?: PTORequestOrderByRelationAggregateInput
    ptoBalances?: PTOBalanceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    username?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    roleId?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedBy?: StringNullableFilter<"User"> | string | null
    createdBy?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    role?: XOR<RoleScalarRelationFilter, RoleWhereInput>
    tasks?: TaskListRelationFilter
    documents?: DocumentListRelationFilter
    documentRevisions?: DocumentRevisionListRelationFilter
    sales?: SaleListRelationFilter
    transactions?: TransactionListRelationFilter
    auditTrails?: AuditTrailListRelationFilter
    notificationTemplatesCreated?: NotificationTemplateListRelationFilter
    notificationRulesCreated?: NotificationRuleListRelationFilter
    notifications?: NotificationListRelationFilter
    magicTokens?: MagicTokenListRelationFilter
    payrollsApproved?: PayrollListRelationFilter
    payrollsProcessed?: PayrollListRelationFilter
    payrollEntries?: PayrollEntryListRelationFilter
    salaryAdjustments?: SalaryAdjustmentListRelationFilter
    salaryAdjustmentsApproved?: SalaryAdjustmentListRelationFilter
    employeeExpenses?: EmployeeExpenseListRelationFilter
    expenseReviews?: EmployeeExpenseListRelationFilter
    ptoRequests?: PTORequestListRelationFilter
    ptoApprovals?: PTORequestListRelationFilter
    ptoBalances?: PTOBalanceListRelationFilter
  }, "id" | "email" | "username">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    roleId?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    username?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    roleId?: StringWithAggregatesFilter<"User"> | string
    tenantId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type MagicTokenWhereInput = {
    AND?: MagicTokenWhereInput | MagicTokenWhereInput[]
    OR?: MagicTokenWhereInput[]
    NOT?: MagicTokenWhereInput | MagicTokenWhereInput[]
    id?: StringFilter<"MagicToken"> | string
    userId?: StringFilter<"MagicToken"> | string
    purpose?: StringFilter<"MagicToken"> | string
    tokenHash?: StringFilter<"MagicToken"> | string
    expiresAt?: DateTimeFilter<"MagicToken"> | Date | string
    tenantId?: StringNullableFilter<"MagicToken"> | string | null
    isDeleted?: BoolFilter<"MagicToken"> | boolean
    deletedAt?: DateTimeNullableFilter<"MagicToken"> | Date | string | null
    deletedBy?: StringNullableFilter<"MagicToken"> | string | null
    createdBy?: StringNullableFilter<"MagicToken"> | string | null
    createdAt?: DateTimeFilter<"MagicToken"> | Date | string
    updatedAt?: DateTimeFilter<"MagicToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MagicTokenOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    purpose?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type MagicTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MagicTokenWhereInput | MagicTokenWhereInput[]
    OR?: MagicTokenWhereInput[]
    NOT?: MagicTokenWhereInput | MagicTokenWhereInput[]
    userId?: StringFilter<"MagicToken"> | string
    purpose?: StringFilter<"MagicToken"> | string
    tokenHash?: StringFilter<"MagicToken"> | string
    expiresAt?: DateTimeFilter<"MagicToken"> | Date | string
    tenantId?: StringNullableFilter<"MagicToken"> | string | null
    isDeleted?: BoolFilter<"MagicToken"> | boolean
    deletedAt?: DateTimeNullableFilter<"MagicToken"> | Date | string | null
    deletedBy?: StringNullableFilter<"MagicToken"> | string | null
    createdBy?: StringNullableFilter<"MagicToken"> | string | null
    createdAt?: DateTimeFilter<"MagicToken"> | Date | string
    updatedAt?: DateTimeFilter<"MagicToken"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MagicTokenOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    purpose?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MagicTokenCountOrderByAggregateInput
    _max?: MagicTokenMaxOrderByAggregateInput
    _min?: MagicTokenMinOrderByAggregateInput
  }

  export type MagicTokenScalarWhereWithAggregatesInput = {
    AND?: MagicTokenScalarWhereWithAggregatesInput | MagicTokenScalarWhereWithAggregatesInput[]
    OR?: MagicTokenScalarWhereWithAggregatesInput[]
    NOT?: MagicTokenScalarWhereWithAggregatesInput | MagicTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MagicToken"> | string
    userId?: StringWithAggregatesFilter<"MagicToken"> | string
    purpose?: StringWithAggregatesFilter<"MagicToken"> | string
    tokenHash?: StringWithAggregatesFilter<"MagicToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"MagicToken"> | Date | string
    tenantId?: StringNullableWithAggregatesFilter<"MagicToken"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"MagicToken"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"MagicToken"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"MagicToken"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"MagicToken"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MagicToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MagicToken"> | Date | string
  }

  export type AuditTrailWhereInput = {
    AND?: AuditTrailWhereInput | AuditTrailWhereInput[]
    OR?: AuditTrailWhereInput[]
    NOT?: AuditTrailWhereInput | AuditTrailWhereInput[]
    id?: StringFilter<"AuditTrail"> | string
    tableName?: StringFilter<"AuditTrail"> | string
    recordId?: StringFilter<"AuditTrail"> | string
    operation?: EnumAuditOperationFilter<"AuditTrail"> | $Enums.AuditOperation
    beforeData?: JsonNullableFilter<"AuditTrail">
    afterData?: JsonNullableFilter<"AuditTrail">
    userId?: StringNullableFilter<"AuditTrail"> | string | null
    tenantId?: StringNullableFilter<"AuditTrail"> | string | null
    timestamp?: DateTimeFilter<"AuditTrail"> | Date | string
    ipAddress?: StringNullableFilter<"AuditTrail"> | string | null
    userAgent?: StringNullableFilter<"AuditTrail"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type AuditTrailOrderByWithRelationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    beforeData?: SortOrderInput | SortOrder
    afterData?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditTrailWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditTrailWhereInput | AuditTrailWhereInput[]
    OR?: AuditTrailWhereInput[]
    NOT?: AuditTrailWhereInput | AuditTrailWhereInput[]
    tableName?: StringFilter<"AuditTrail"> | string
    recordId?: StringFilter<"AuditTrail"> | string
    operation?: EnumAuditOperationFilter<"AuditTrail"> | $Enums.AuditOperation
    beforeData?: JsonNullableFilter<"AuditTrail">
    afterData?: JsonNullableFilter<"AuditTrail">
    userId?: StringNullableFilter<"AuditTrail"> | string | null
    tenantId?: StringNullableFilter<"AuditTrail"> | string | null
    timestamp?: DateTimeFilter<"AuditTrail"> | Date | string
    ipAddress?: StringNullableFilter<"AuditTrail"> | string | null
    userAgent?: StringNullableFilter<"AuditTrail"> | string | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditTrailOrderByWithAggregationInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    beforeData?: SortOrderInput | SortOrder
    afterData?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    _count?: AuditTrailCountOrderByAggregateInput
    _max?: AuditTrailMaxOrderByAggregateInput
    _min?: AuditTrailMinOrderByAggregateInput
  }

  export type AuditTrailScalarWhereWithAggregatesInput = {
    AND?: AuditTrailScalarWhereWithAggregatesInput | AuditTrailScalarWhereWithAggregatesInput[]
    OR?: AuditTrailScalarWhereWithAggregatesInput[]
    NOT?: AuditTrailScalarWhereWithAggregatesInput | AuditTrailScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditTrail"> | string
    tableName?: StringWithAggregatesFilter<"AuditTrail"> | string
    recordId?: StringWithAggregatesFilter<"AuditTrail"> | string
    operation?: EnumAuditOperationWithAggregatesFilter<"AuditTrail"> | $Enums.AuditOperation
    beforeData?: JsonNullableWithAggregatesFilter<"AuditTrail">
    afterData?: JsonNullableWithAggregatesFilter<"AuditTrail">
    userId?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditTrail"> | Date | string
    ipAddress?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditTrail"> | string | null
  }

  export type NotificationTemplateWhereInput = {
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    OR?: NotificationTemplateWhereInput[]
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    id?: StringFilter<"NotificationTemplate"> | string
    name?: StringFilter<"NotificationTemplate"> | string
    description?: StringNullableFilter<"NotificationTemplate"> | string | null
    type?: EnumNotificationTypeFilter<"NotificationTemplate"> | $Enums.NotificationType
    subject?: StringNullableFilter<"NotificationTemplate"> | string | null
    content?: StringFilter<"NotificationTemplate"> | string
    variables?: StringNullableListFilter<"NotificationTemplate">
    isActive?: BoolFilter<"NotificationTemplate"> | boolean
    createdBy?: StringFilter<"NotificationTemplate"> | string
    tenantId?: StringNullableFilter<"NotificationTemplate"> | string | null
    isDeleted?: BoolFilter<"NotificationTemplate"> | boolean
    deletedAt?: DateTimeNullableFilter<"NotificationTemplate"> | Date | string | null
    deletedBy?: StringNullableFilter<"NotificationTemplate"> | string | null
    createdAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    rules?: NotificationRuleListRelationFilter
    notifications?: NotificationListRelationFilter
  }

  export type NotificationTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    variables?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    rules?: NotificationRuleOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type NotificationTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    OR?: NotificationTemplateWhereInput[]
    NOT?: NotificationTemplateWhereInput | NotificationTemplateWhereInput[]
    description?: StringNullableFilter<"NotificationTemplate"> | string | null
    type?: EnumNotificationTypeFilter<"NotificationTemplate"> | $Enums.NotificationType
    subject?: StringNullableFilter<"NotificationTemplate"> | string | null
    content?: StringFilter<"NotificationTemplate"> | string
    variables?: StringNullableListFilter<"NotificationTemplate">
    isActive?: BoolFilter<"NotificationTemplate"> | boolean
    createdBy?: StringFilter<"NotificationTemplate"> | string
    tenantId?: StringNullableFilter<"NotificationTemplate"> | string | null
    isDeleted?: BoolFilter<"NotificationTemplate"> | boolean
    deletedAt?: DateTimeNullableFilter<"NotificationTemplate"> | Date | string | null
    deletedBy?: StringNullableFilter<"NotificationTemplate"> | string | null
    createdAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    rules?: NotificationRuleListRelationFilter
    notifications?: NotificationListRelationFilter
  }, "id" | "name">

  export type NotificationTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    type?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    variables?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationTemplateCountOrderByAggregateInput
    _max?: NotificationTemplateMaxOrderByAggregateInput
    _min?: NotificationTemplateMinOrderByAggregateInput
  }

  export type NotificationTemplateScalarWhereWithAggregatesInput = {
    AND?: NotificationTemplateScalarWhereWithAggregatesInput | NotificationTemplateScalarWhereWithAggregatesInput[]
    OR?: NotificationTemplateScalarWhereWithAggregatesInput[]
    NOT?: NotificationTemplateScalarWhereWithAggregatesInput | NotificationTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    name?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"NotificationTemplate"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"NotificationTemplate"> | $Enums.NotificationType
    subject?: StringNullableWithAggregatesFilter<"NotificationTemplate"> | string | null
    content?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    variables?: StringNullableListFilter<"NotificationTemplate">
    isActive?: BoolWithAggregatesFilter<"NotificationTemplate"> | boolean
    createdBy?: StringWithAggregatesFilter<"NotificationTemplate"> | string
    tenantId?: StringNullableWithAggregatesFilter<"NotificationTemplate"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"NotificationTemplate"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"NotificationTemplate"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"NotificationTemplate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationTemplate"> | Date | string
  }

  export type NotificationRuleWhereInput = {
    AND?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    OR?: NotificationRuleWhereInput[]
    NOT?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    id?: StringFilter<"NotificationRule"> | string
    name?: StringFilter<"NotificationRule"> | string
    description?: StringNullableFilter<"NotificationRule"> | string | null
    trigger?: EnumRuleTriggerFilter<"NotificationRule"> | $Enums.RuleTrigger
    conditions?: JsonFilter<"NotificationRule">
    isActive?: BoolFilter<"NotificationRule"> | boolean
    templateId?: StringFilter<"NotificationRule"> | string
    recipients?: JsonFilter<"NotificationRule">
    delay?: IntNullableFilter<"NotificationRule"> | number | null
    createdBy?: StringFilter<"NotificationRule"> | string
    tenantId?: StringNullableFilter<"NotificationRule"> | string | null
    isDeleted?: BoolFilter<"NotificationRule"> | boolean
    deletedAt?: DateTimeNullableFilter<"NotificationRule"> | Date | string | null
    deletedBy?: StringNullableFilter<"NotificationRule"> | string | null
    createdAt?: DateTimeFilter<"NotificationRule"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationRule"> | Date | string
    template?: XOR<NotificationTemplateScalarRelationFilter, NotificationTemplateWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }

  export type NotificationRuleOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    trigger?: SortOrder
    conditions?: SortOrder
    isActive?: SortOrder
    templateId?: SortOrder
    recipients?: SortOrder
    delay?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    template?: NotificationTemplateOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    notifications?: NotificationOrderByRelationAggregateInput
  }

  export type NotificationRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    OR?: NotificationRuleWhereInput[]
    NOT?: NotificationRuleWhereInput | NotificationRuleWhereInput[]
    name?: StringFilter<"NotificationRule"> | string
    description?: StringNullableFilter<"NotificationRule"> | string | null
    trigger?: EnumRuleTriggerFilter<"NotificationRule"> | $Enums.RuleTrigger
    conditions?: JsonFilter<"NotificationRule">
    isActive?: BoolFilter<"NotificationRule"> | boolean
    templateId?: StringFilter<"NotificationRule"> | string
    recipients?: JsonFilter<"NotificationRule">
    delay?: IntNullableFilter<"NotificationRule"> | number | null
    createdBy?: StringFilter<"NotificationRule"> | string
    tenantId?: StringNullableFilter<"NotificationRule"> | string | null
    isDeleted?: BoolFilter<"NotificationRule"> | boolean
    deletedAt?: DateTimeNullableFilter<"NotificationRule"> | Date | string | null
    deletedBy?: StringNullableFilter<"NotificationRule"> | string | null
    createdAt?: DateTimeFilter<"NotificationRule"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationRule"> | Date | string
    template?: XOR<NotificationTemplateScalarRelationFilter, NotificationTemplateWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    notifications?: NotificationListRelationFilter
  }, "id">

  export type NotificationRuleOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    trigger?: SortOrder
    conditions?: SortOrder
    isActive?: SortOrder
    templateId?: SortOrder
    recipients?: SortOrder
    delay?: SortOrderInput | SortOrder
    createdBy?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationRuleCountOrderByAggregateInput
    _avg?: NotificationRuleAvgOrderByAggregateInput
    _max?: NotificationRuleMaxOrderByAggregateInput
    _min?: NotificationRuleMinOrderByAggregateInput
    _sum?: NotificationRuleSumOrderByAggregateInput
  }

  export type NotificationRuleScalarWhereWithAggregatesInput = {
    AND?: NotificationRuleScalarWhereWithAggregatesInput | NotificationRuleScalarWhereWithAggregatesInput[]
    OR?: NotificationRuleScalarWhereWithAggregatesInput[]
    NOT?: NotificationRuleScalarWhereWithAggregatesInput | NotificationRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationRule"> | string
    name?: StringWithAggregatesFilter<"NotificationRule"> | string
    description?: StringNullableWithAggregatesFilter<"NotificationRule"> | string | null
    trigger?: EnumRuleTriggerWithAggregatesFilter<"NotificationRule"> | $Enums.RuleTrigger
    conditions?: JsonWithAggregatesFilter<"NotificationRule">
    isActive?: BoolWithAggregatesFilter<"NotificationRule"> | boolean
    templateId?: StringWithAggregatesFilter<"NotificationRule"> | string
    recipients?: JsonWithAggregatesFilter<"NotificationRule">
    delay?: IntNullableWithAggregatesFilter<"NotificationRule"> | number | null
    createdBy?: StringWithAggregatesFilter<"NotificationRule"> | string
    tenantId?: StringNullableWithAggregatesFilter<"NotificationRule"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"NotificationRule"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"NotificationRule"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"NotificationRule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationRule"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    subject?: StringNullableFilter<"Notification"> | string | null
    content?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    templateId?: StringNullableFilter<"Notification"> | string | null
    ruleId?: StringNullableFilter<"Notification"> | string | null
    entityType?: StringNullableFilter<"Notification"> | string | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    scheduledAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    errorMessage?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    tenantId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<NotificationTemplateNullableScalarRelationFilter, NotificationTemplateWhereInput> | null
    rule?: XOR<NotificationRuleNullableScalarRelationFilter, NotificationRuleWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    recipientId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    ruleId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    recipient?: UserOrderByWithRelationInput
    template?: NotificationTemplateOrderByWithRelationInput
    rule?: NotificationRuleOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    subject?: StringNullableFilter<"Notification"> | string | null
    content?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    templateId?: StringNullableFilter<"Notification"> | string | null
    ruleId?: StringNullableFilter<"Notification"> | string | null
    entityType?: StringNullableFilter<"Notification"> | string | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    scheduledAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    errorMessage?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    tenantId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
    recipient?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<NotificationTemplateNullableScalarRelationFilter, NotificationTemplateWhereInput> | null
    rule?: XOR<NotificationRuleNullableScalarRelationFilter, NotificationRuleWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrderInput | SortOrder
    content?: SortOrder
    recipientId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    ruleId?: SortOrderInput | SortOrder
    entityType?: SortOrderInput | SortOrder
    entityId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    scheduledAt?: SortOrderInput | SortOrder
    sentAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    readAt?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusWithAggregatesFilter<"Notification"> | $Enums.NotificationStatus
    subject?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    content?: StringWithAggregatesFilter<"Notification"> | string
    recipientId?: StringWithAggregatesFilter<"Notification"> | string
    templateId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    ruleId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    entityType?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    entityId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Notification">
    scheduledAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    errorMessage?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    readAt?: DateTimeNullableWithAggregatesFilter<"Notification"> | Date | string | null
    tenantId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type PayrollWhereInput = {
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    id?: StringFilter<"Payroll"> | string
    runDate?: DateTimeFilter<"Payroll"> | Date | string
    payPeriodStart?: DateTimeFilter<"Payroll"> | Date | string
    payPeriodEnd?: DateTimeFilter<"Payroll"> | Date | string
    status?: EnumPayrollStatusFilter<"Payroll"> | $Enums.PayrollStatus
    totalGrossPay?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Payroll"> | string | null
    approvedBy?: StringNullableFilter<"Payroll"> | string | null
    approvedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    processedBy?: StringNullableFilter<"Payroll"> | string | null
    processedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    tenantId?: StringNullableFilter<"Payroll"> | string | null
    isDeleted?: BoolFilter<"Payroll"> | boolean
    deletedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    deletedBy?: StringNullableFilter<"Payroll"> | string | null
    createdBy?: StringNullableFilter<"Payroll"> | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    processor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    payrollEntries?: PayrollEntryListRelationFilter
    transactions?: TransactionListRelationFilter
  }

  export type PayrollOrderByWithRelationInput = {
    id?: SortOrder
    runDate?: SortOrder
    payPeriodStart?: SortOrder
    payPeriodEnd?: SortOrder
    status?: SortOrder
    totalGrossPay?: SortOrder
    totalDeductions?: SortOrder
    totalNetPay?: SortOrder
    notes?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    approver?: UserOrderByWithRelationInput
    processor?: UserOrderByWithRelationInput
    payrollEntries?: PayrollEntryOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
  }

  export type PayrollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    runDate?: DateTimeFilter<"Payroll"> | Date | string
    payPeriodStart?: DateTimeFilter<"Payroll"> | Date | string
    payPeriodEnd?: DateTimeFilter<"Payroll"> | Date | string
    status?: EnumPayrollStatusFilter<"Payroll"> | $Enums.PayrollStatus
    totalGrossPay?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Payroll"> | string | null
    approvedBy?: StringNullableFilter<"Payroll"> | string | null
    approvedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    processedBy?: StringNullableFilter<"Payroll"> | string | null
    processedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    tenantId?: StringNullableFilter<"Payroll"> | string | null
    isDeleted?: BoolFilter<"Payroll"> | boolean
    deletedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    deletedBy?: StringNullableFilter<"Payroll"> | string | null
    createdBy?: StringNullableFilter<"Payroll"> | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    processor?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    payrollEntries?: PayrollEntryListRelationFilter
    transactions?: TransactionListRelationFilter
  }, "id">

  export type PayrollOrderByWithAggregationInput = {
    id?: SortOrder
    runDate?: SortOrder
    payPeriodStart?: SortOrder
    payPeriodEnd?: SortOrder
    status?: SortOrder
    totalGrossPay?: SortOrder
    totalDeductions?: SortOrder
    totalNetPay?: SortOrder
    notes?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    processedBy?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollCountOrderByAggregateInput
    _avg?: PayrollAvgOrderByAggregateInput
    _max?: PayrollMaxOrderByAggregateInput
    _min?: PayrollMinOrderByAggregateInput
    _sum?: PayrollSumOrderByAggregateInput
  }

  export type PayrollScalarWhereWithAggregatesInput = {
    AND?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    OR?: PayrollScalarWhereWithAggregatesInput[]
    NOT?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payroll"> | string
    runDate?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    payPeriodStart?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    payPeriodEnd?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    status?: EnumPayrollStatusWithAggregatesFilter<"Payroll"> | $Enums.PayrollStatus
    totalGrossPay?: DecimalWithAggregatesFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalWithAggregatesFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalWithAggregatesFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
    processedBy?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
    tenantId?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Payroll"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Payroll"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
  }

  export type PayrollEntryWhereInput = {
    AND?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    OR?: PayrollEntryWhereInput[]
    NOT?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    id?: StringFilter<"PayrollEntry"> | string
    payrollId?: StringFilter<"PayrollEntry"> | string
    employeeId?: StringFilter<"PayrollEntry"> | string
    baseSalary?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    hoursWorked?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    allowances?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    otherDeductions?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PayrollEntry"> | string | null
    tenantId?: StringNullableFilter<"PayrollEntry"> | string | null
    isDeleted?: BoolFilter<"PayrollEntry"> | boolean
    deletedAt?: DateTimeNullableFilter<"PayrollEntry"> | Date | string | null
    deletedBy?: StringNullableFilter<"PayrollEntry"> | string | null
    createdBy?: StringNullableFilter<"PayrollEntry"> | string | null
    createdAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    payroll?: XOR<PayrollScalarRelationFilter, PayrollWhereInput>
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PayrollEntryOrderByWithRelationInput = {
    id?: SortOrder
    payrollId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    hoursWorked?: SortOrderInput | SortOrder
    overtimeHours?: SortOrderInput | SortOrder
    bonusAmount?: SortOrderInput | SortOrder
    allowances?: SortOrderInput | SortOrder
    grossPay?: SortOrder
    taxDeductions?: SortOrder
    socialSecurity?: SortOrder
    otherDeductions?: SortOrderInput | SortOrder
    netPay?: SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payroll?: PayrollOrderByWithRelationInput
    employee?: UserOrderByWithRelationInput
  }

  export type PayrollEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    payrollId_employeeId?: PayrollEntryPayrollIdEmployeeIdCompoundUniqueInput
    AND?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    OR?: PayrollEntryWhereInput[]
    NOT?: PayrollEntryWhereInput | PayrollEntryWhereInput[]
    payrollId?: StringFilter<"PayrollEntry"> | string
    employeeId?: StringFilter<"PayrollEntry"> | string
    baseSalary?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    hoursWorked?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    allowances?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    otherDeductions?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PayrollEntry"> | string | null
    tenantId?: StringNullableFilter<"PayrollEntry"> | string | null
    isDeleted?: BoolFilter<"PayrollEntry"> | boolean
    deletedAt?: DateTimeNullableFilter<"PayrollEntry"> | Date | string | null
    deletedBy?: StringNullableFilter<"PayrollEntry"> | string | null
    createdBy?: StringNullableFilter<"PayrollEntry"> | string | null
    createdAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    payroll?: XOR<PayrollScalarRelationFilter, PayrollWhereInput>
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "payrollId_employeeId">

  export type PayrollEntryOrderByWithAggregationInput = {
    id?: SortOrder
    payrollId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    hoursWorked?: SortOrderInput | SortOrder
    overtimeHours?: SortOrderInput | SortOrder
    bonusAmount?: SortOrderInput | SortOrder
    allowances?: SortOrderInput | SortOrder
    grossPay?: SortOrder
    taxDeductions?: SortOrder
    socialSecurity?: SortOrder
    otherDeductions?: SortOrderInput | SortOrder
    netPay?: SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollEntryCountOrderByAggregateInput
    _avg?: PayrollEntryAvgOrderByAggregateInput
    _max?: PayrollEntryMaxOrderByAggregateInput
    _min?: PayrollEntryMinOrderByAggregateInput
    _sum?: PayrollEntrySumOrderByAggregateInput
  }

  export type PayrollEntryScalarWhereWithAggregatesInput = {
    AND?: PayrollEntryScalarWhereWithAggregatesInput | PayrollEntryScalarWhereWithAggregatesInput[]
    OR?: PayrollEntryScalarWhereWithAggregatesInput[]
    NOT?: PayrollEntryScalarWhereWithAggregatesInput | PayrollEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayrollEntry"> | string
    payrollId?: StringWithAggregatesFilter<"PayrollEntry"> | string
    employeeId?: StringWithAggregatesFilter<"PayrollEntry"> | string
    baseSalary?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    hoursWorked?: DecimalNullableWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: DecimalNullableWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: DecimalNullableWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    allowances?: DecimalNullableWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    otherDeductions?: DecimalNullableWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalWithAggregatesFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableWithAggregatesFilter<"PayrollEntry"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"PayrollEntry"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"PayrollEntry"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PayrollEntry"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"PayrollEntry"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"PayrollEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PayrollEntry"> | Date | string
  }

  export type SalaryAdjustmentWhereInput = {
    AND?: SalaryAdjustmentWhereInput | SalaryAdjustmentWhereInput[]
    OR?: SalaryAdjustmentWhereInput[]
    NOT?: SalaryAdjustmentWhereInput | SalaryAdjustmentWhereInput[]
    id?: StringFilter<"SalaryAdjustment"> | string
    employeeId?: StringFilter<"SalaryAdjustment"> | string
    adjustmentType?: EnumSalaryAdjustmentTypeFilter<"SalaryAdjustment"> | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFilter<"SalaryAdjustment"> | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFilter<"SalaryAdjustment"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFilter<"SalaryAdjustment"> | Date | string
    reason?: StringFilter<"SalaryAdjustment"> | string
    notes?: StringNullableFilter<"SalaryAdjustment"> | string | null
    approvedBy?: StringNullableFilter<"SalaryAdjustment"> | string | null
    approvedAt?: DateTimeNullableFilter<"SalaryAdjustment"> | Date | string | null
    tenantId?: StringNullableFilter<"SalaryAdjustment"> | string | null
    isDeleted?: BoolFilter<"SalaryAdjustment"> | boolean
    deletedAt?: DateTimeNullableFilter<"SalaryAdjustment"> | Date | string | null
    deletedBy?: StringNullableFilter<"SalaryAdjustment"> | string | null
    createdBy?: StringNullableFilter<"SalaryAdjustment"> | string | null
    createdAt?: DateTimeFilter<"SalaryAdjustment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryAdjustment"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type SalaryAdjustmentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    adjustmentType?: SortOrder
    previousAmount?: SortOrder
    newAmount?: SortOrder
    effectiveDate?: SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type SalaryAdjustmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SalaryAdjustmentWhereInput | SalaryAdjustmentWhereInput[]
    OR?: SalaryAdjustmentWhereInput[]
    NOT?: SalaryAdjustmentWhereInput | SalaryAdjustmentWhereInput[]
    employeeId?: StringFilter<"SalaryAdjustment"> | string
    adjustmentType?: EnumSalaryAdjustmentTypeFilter<"SalaryAdjustment"> | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFilter<"SalaryAdjustment"> | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFilter<"SalaryAdjustment"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFilter<"SalaryAdjustment"> | Date | string
    reason?: StringFilter<"SalaryAdjustment"> | string
    notes?: StringNullableFilter<"SalaryAdjustment"> | string | null
    approvedBy?: StringNullableFilter<"SalaryAdjustment"> | string | null
    approvedAt?: DateTimeNullableFilter<"SalaryAdjustment"> | Date | string | null
    tenantId?: StringNullableFilter<"SalaryAdjustment"> | string | null
    isDeleted?: BoolFilter<"SalaryAdjustment"> | boolean
    deletedAt?: DateTimeNullableFilter<"SalaryAdjustment"> | Date | string | null
    deletedBy?: StringNullableFilter<"SalaryAdjustment"> | string | null
    createdBy?: StringNullableFilter<"SalaryAdjustment"> | string | null
    createdAt?: DateTimeFilter<"SalaryAdjustment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryAdjustment"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type SalaryAdjustmentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    adjustmentType?: SortOrder
    previousAmount?: SortOrder
    newAmount?: SortOrder
    effectiveDate?: SortOrder
    reason?: SortOrder
    notes?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SalaryAdjustmentCountOrderByAggregateInput
    _avg?: SalaryAdjustmentAvgOrderByAggregateInput
    _max?: SalaryAdjustmentMaxOrderByAggregateInput
    _min?: SalaryAdjustmentMinOrderByAggregateInput
    _sum?: SalaryAdjustmentSumOrderByAggregateInput
  }

  export type SalaryAdjustmentScalarWhereWithAggregatesInput = {
    AND?: SalaryAdjustmentScalarWhereWithAggregatesInput | SalaryAdjustmentScalarWhereWithAggregatesInput[]
    OR?: SalaryAdjustmentScalarWhereWithAggregatesInput[]
    NOT?: SalaryAdjustmentScalarWhereWithAggregatesInput | SalaryAdjustmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SalaryAdjustment"> | string
    employeeId?: StringWithAggregatesFilter<"SalaryAdjustment"> | string
    adjustmentType?: EnumSalaryAdjustmentTypeWithAggregatesFilter<"SalaryAdjustment"> | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalWithAggregatesFilter<"SalaryAdjustment"> | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalWithAggregatesFilter<"SalaryAdjustment"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeWithAggregatesFilter<"SalaryAdjustment"> | Date | string
    reason?: StringWithAggregatesFilter<"SalaryAdjustment"> | string
    notes?: StringNullableWithAggregatesFilter<"SalaryAdjustment"> | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"SalaryAdjustment"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"SalaryAdjustment"> | Date | string | null
    tenantId?: StringNullableWithAggregatesFilter<"SalaryAdjustment"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"SalaryAdjustment"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"SalaryAdjustment"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"SalaryAdjustment"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"SalaryAdjustment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SalaryAdjustment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SalaryAdjustment"> | Date | string
  }

  export type EmployeeExpenseWhereInput = {
    AND?: EmployeeExpenseWhereInput | EmployeeExpenseWhereInput[]
    OR?: EmployeeExpenseWhereInput[]
    NOT?: EmployeeExpenseWhereInput | EmployeeExpenseWhereInput[]
    id?: StringFilter<"EmployeeExpense"> | string
    employeeId?: StringFilter<"EmployeeExpense"> | string
    description?: StringFilter<"EmployeeExpense"> | string
    amount?: DecimalFilter<"EmployeeExpense"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"EmployeeExpense"> | string
    expenseDate?: DateTimeFilter<"EmployeeExpense"> | Date | string
    receiptUrl?: StringNullableFilter<"EmployeeExpense"> | string | null
    status?: EnumExpenseStatusFilter<"EmployeeExpense"> | $Enums.ExpenseStatus
    submittedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    reviewedBy?: StringNullableFilter<"EmployeeExpense"> | string | null
    reviewedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    reimbursedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    reimbursementTransactionId?: StringNullableFilter<"EmployeeExpense"> | string | null
    notes?: StringNullableFilter<"EmployeeExpense"> | string | null
    tenantId?: StringNullableFilter<"EmployeeExpense"> | string | null
    isDeleted?: BoolFilter<"EmployeeExpense"> | boolean
    deletedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    deletedBy?: StringNullableFilter<"EmployeeExpense"> | string | null
    createdBy?: StringNullableFilter<"EmployeeExpense"> | string | null
    createdAt?: DateTimeFilter<"EmployeeExpense"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeExpense"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reimbursementTransaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }

  export type EmployeeExpenseOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    expenseDate?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reimbursedAt?: SortOrderInput | SortOrder
    reimbursementTransactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: UserOrderByWithRelationInput
    reviewer?: UserOrderByWithRelationInput
    reimbursementTransaction?: TransactionOrderByWithRelationInput
  }

  export type EmployeeExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reimbursementTransactionId?: string
    AND?: EmployeeExpenseWhereInput | EmployeeExpenseWhereInput[]
    OR?: EmployeeExpenseWhereInput[]
    NOT?: EmployeeExpenseWhereInput | EmployeeExpenseWhereInput[]
    employeeId?: StringFilter<"EmployeeExpense"> | string
    description?: StringFilter<"EmployeeExpense"> | string
    amount?: DecimalFilter<"EmployeeExpense"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"EmployeeExpense"> | string
    expenseDate?: DateTimeFilter<"EmployeeExpense"> | Date | string
    receiptUrl?: StringNullableFilter<"EmployeeExpense"> | string | null
    status?: EnumExpenseStatusFilter<"EmployeeExpense"> | $Enums.ExpenseStatus
    submittedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    reviewedBy?: StringNullableFilter<"EmployeeExpense"> | string | null
    reviewedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    reimbursedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    notes?: StringNullableFilter<"EmployeeExpense"> | string | null
    tenantId?: StringNullableFilter<"EmployeeExpense"> | string | null
    isDeleted?: BoolFilter<"EmployeeExpense"> | boolean
    deletedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    deletedBy?: StringNullableFilter<"EmployeeExpense"> | string | null
    createdBy?: StringNullableFilter<"EmployeeExpense"> | string | null
    createdAt?: DateTimeFilter<"EmployeeExpense"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeExpense"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    reviewer?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    reimbursementTransaction?: XOR<TransactionNullableScalarRelationFilter, TransactionWhereInput> | null
  }, "id" | "reimbursementTransactionId">

  export type EmployeeExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    expenseDate?: SortOrder
    receiptUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrderInput | SortOrder
    reviewedBy?: SortOrderInput | SortOrder
    reviewedAt?: SortOrderInput | SortOrder
    reimbursedAt?: SortOrderInput | SortOrder
    reimbursementTransactionId?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeExpenseCountOrderByAggregateInput
    _avg?: EmployeeExpenseAvgOrderByAggregateInput
    _max?: EmployeeExpenseMaxOrderByAggregateInput
    _min?: EmployeeExpenseMinOrderByAggregateInput
    _sum?: EmployeeExpenseSumOrderByAggregateInput
  }

  export type EmployeeExpenseScalarWhereWithAggregatesInput = {
    AND?: EmployeeExpenseScalarWhereWithAggregatesInput | EmployeeExpenseScalarWhereWithAggregatesInput[]
    OR?: EmployeeExpenseScalarWhereWithAggregatesInput[]
    NOT?: EmployeeExpenseScalarWhereWithAggregatesInput | EmployeeExpenseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeExpense"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeExpense"> | string
    description?: StringWithAggregatesFilter<"EmployeeExpense"> | string
    amount?: DecimalWithAggregatesFilter<"EmployeeExpense"> | Decimal | DecimalJsLike | number | string
    category?: StringWithAggregatesFilter<"EmployeeExpense"> | string
    expenseDate?: DateTimeWithAggregatesFilter<"EmployeeExpense"> | Date | string
    receiptUrl?: StringNullableWithAggregatesFilter<"EmployeeExpense"> | string | null
    status?: EnumExpenseStatusWithAggregatesFilter<"EmployeeExpense"> | $Enums.ExpenseStatus
    submittedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeExpense"> | Date | string | null
    reviewedBy?: StringNullableWithAggregatesFilter<"EmployeeExpense"> | string | null
    reviewedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeExpense"> | Date | string | null
    reimbursedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeExpense"> | Date | string | null
    reimbursementTransactionId?: StringNullableWithAggregatesFilter<"EmployeeExpense"> | string | null
    notes?: StringNullableWithAggregatesFilter<"EmployeeExpense"> | string | null
    tenantId?: StringNullableWithAggregatesFilter<"EmployeeExpense"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"EmployeeExpense"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"EmployeeExpense"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"EmployeeExpense"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"EmployeeExpense"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeExpense"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeExpense"> | Date | string
  }

  export type PTORequestWhereInput = {
    AND?: PTORequestWhereInput | PTORequestWhereInput[]
    OR?: PTORequestWhereInput[]
    NOT?: PTORequestWhereInput | PTORequestWhereInput[]
    id?: StringFilter<"PTORequest"> | string
    employeeId?: StringFilter<"PTORequest"> | string
    startDate?: DateTimeFilter<"PTORequest"> | Date | string
    endDate?: DateTimeFilter<"PTORequest"> | Date | string
    totalDays?: DecimalFilter<"PTORequest"> | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFilter<"PTORequest"> | $Enums.PTOStatus
    reason?: StringNullableFilter<"PTORequest"> | string | null
    submittedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    approvedBy?: StringNullableFilter<"PTORequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    tenantId?: StringNullableFilter<"PTORequest"> | string | null
    isDeleted?: BoolFilter<"PTORequest"> | boolean
    deletedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    deletedBy?: StringNullableFilter<"PTORequest"> | string | null
    createdBy?: StringNullableFilter<"PTORequest"> | string | null
    createdAt?: DateTimeFilter<"PTORequest"> | Date | string
    updatedAt?: DateTimeFilter<"PTORequest"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type PTORequestOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: UserOrderByWithRelationInput
    approver?: UserOrderByWithRelationInput
  }

  export type PTORequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PTORequestWhereInput | PTORequestWhereInput[]
    OR?: PTORequestWhereInput[]
    NOT?: PTORequestWhereInput | PTORequestWhereInput[]
    employeeId?: StringFilter<"PTORequest"> | string
    startDate?: DateTimeFilter<"PTORequest"> | Date | string
    endDate?: DateTimeFilter<"PTORequest"> | Date | string
    totalDays?: DecimalFilter<"PTORequest"> | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFilter<"PTORequest"> | $Enums.PTOStatus
    reason?: StringNullableFilter<"PTORequest"> | string | null
    submittedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    approvedBy?: StringNullableFilter<"PTORequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    tenantId?: StringNullableFilter<"PTORequest"> | string | null
    isDeleted?: BoolFilter<"PTORequest"> | boolean
    deletedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    deletedBy?: StringNullableFilter<"PTORequest"> | string | null
    createdBy?: StringNullableFilter<"PTORequest"> | string | null
    createdAt?: DateTimeFilter<"PTORequest"> | Date | string
    updatedAt?: DateTimeFilter<"PTORequest"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
    approver?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type PTORequestOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    submittedAt?: SortOrderInput | SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PTORequestCountOrderByAggregateInput
    _avg?: PTORequestAvgOrderByAggregateInput
    _max?: PTORequestMaxOrderByAggregateInput
    _min?: PTORequestMinOrderByAggregateInput
    _sum?: PTORequestSumOrderByAggregateInput
  }

  export type PTORequestScalarWhereWithAggregatesInput = {
    AND?: PTORequestScalarWhereWithAggregatesInput | PTORequestScalarWhereWithAggregatesInput[]
    OR?: PTORequestScalarWhereWithAggregatesInput[]
    NOT?: PTORequestScalarWhereWithAggregatesInput | PTORequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PTORequest"> | string
    employeeId?: StringWithAggregatesFilter<"PTORequest"> | string
    startDate?: DateTimeWithAggregatesFilter<"PTORequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"PTORequest"> | Date | string
    totalDays?: DecimalWithAggregatesFilter<"PTORequest"> | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusWithAggregatesFilter<"PTORequest"> | $Enums.PTOStatus
    reason?: StringNullableWithAggregatesFilter<"PTORequest"> | string | null
    submittedAt?: DateTimeNullableWithAggregatesFilter<"PTORequest"> | Date | string | null
    approvedBy?: StringNullableWithAggregatesFilter<"PTORequest"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PTORequest"> | Date | string | null
    rejectedAt?: DateTimeNullableWithAggregatesFilter<"PTORequest"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"PTORequest"> | Date | string | null
    tenantId?: StringNullableWithAggregatesFilter<"PTORequest"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"PTORequest"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PTORequest"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"PTORequest"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"PTORequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PTORequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PTORequest"> | Date | string
  }

  export type PTOBalanceWhereInput = {
    AND?: PTOBalanceWhereInput | PTOBalanceWhereInput[]
    OR?: PTOBalanceWhereInput[]
    NOT?: PTOBalanceWhereInput | PTOBalanceWhereInput[]
    id?: StringFilter<"PTOBalance"> | string
    employeeId?: StringFilter<"PTOBalance"> | string
    year?: IntFilter<"PTOBalance"> | number
    totalDays?: DecimalFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    tenantId?: StringNullableFilter<"PTOBalance"> | string | null
    isDeleted?: BoolFilter<"PTOBalance"> | boolean
    deletedAt?: DateTimeNullableFilter<"PTOBalance"> | Date | string | null
    deletedBy?: StringNullableFilter<"PTOBalance"> | string | null
    createdBy?: StringNullableFilter<"PTOBalance"> | string | null
    createdAt?: DateTimeFilter<"PTOBalance"> | Date | string
    updatedAt?: DateTimeFilter<"PTOBalance"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type PTOBalanceOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    carryOverDays?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    employee?: UserOrderByWithRelationInput
  }

  export type PTOBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId?: string
    employeeId_year?: PTOBalanceEmployeeIdYearCompoundUniqueInput
    AND?: PTOBalanceWhereInput | PTOBalanceWhereInput[]
    OR?: PTOBalanceWhereInput[]
    NOT?: PTOBalanceWhereInput | PTOBalanceWhereInput[]
    year?: IntFilter<"PTOBalance"> | number
    totalDays?: DecimalFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    tenantId?: StringNullableFilter<"PTOBalance"> | string | null
    isDeleted?: BoolFilter<"PTOBalance"> | boolean
    deletedAt?: DateTimeNullableFilter<"PTOBalance"> | Date | string | null
    deletedBy?: StringNullableFilter<"PTOBalance"> | string | null
    createdBy?: StringNullableFilter<"PTOBalance"> | string | null
    createdAt?: DateTimeFilter<"PTOBalance"> | Date | string
    updatedAt?: DateTimeFilter<"PTOBalance"> | Date | string
    employee?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "employeeId" | "employeeId_year">

  export type PTOBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    carryOverDays?: SortOrder
    tenantId?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deletedBy?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PTOBalanceCountOrderByAggregateInput
    _avg?: PTOBalanceAvgOrderByAggregateInput
    _max?: PTOBalanceMaxOrderByAggregateInput
    _min?: PTOBalanceMinOrderByAggregateInput
    _sum?: PTOBalanceSumOrderByAggregateInput
  }

  export type PTOBalanceScalarWhereWithAggregatesInput = {
    AND?: PTOBalanceScalarWhereWithAggregatesInput | PTOBalanceScalarWhereWithAggregatesInput[]
    OR?: PTOBalanceScalarWhereWithAggregatesInput[]
    NOT?: PTOBalanceScalarWhereWithAggregatesInput | PTOBalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PTOBalance"> | string
    employeeId?: StringWithAggregatesFilter<"PTOBalance"> | string
    year?: IntWithAggregatesFilter<"PTOBalance"> | number
    totalDays?: DecimalWithAggregatesFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalWithAggregatesFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalWithAggregatesFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    tenantId?: StringNullableWithAggregatesFilter<"PTOBalance"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"PTOBalance"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PTOBalance"> | Date | string | null
    deletedBy?: StringNullableWithAggregatesFilter<"PTOBalance"> | string | null
    createdBy?: StringNullableWithAggregatesFilter<"PTOBalance"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PTOBalance"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PTOBalance"> | Date | string
  }

  export type RoleCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: RoleCreatepermissionsInput | string[]
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutRoleInput
  }

  export type RoleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: RoleCreatepermissionsInput | string[]
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutRoleInput
  }

  export type RoleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutRoleNestedInput
  }

  export type RoleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutRoleNestedInput
  }

  export type RoleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: RoleCreatepermissionsInput | string[]
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    name: string
    description?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
    assignee?: UserCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    projectId: string
    assigneeId?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
    assignee?: UserUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    projectId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    projectId: string
    assigneeId?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    projectId?: StringFieldUpdateOperationsInput | string
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    parent?: DocumentCreateNestedOneWithoutChildrenInput
    children?: DocumentCreateNestedManyWithoutParentInput
    author: UserCreateNestedOneWithoutDocumentsInput
    revisions?: DocumentRevisionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    parentId?: string | null
    authorId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    children?: DocumentUncheckedCreateNestedManyWithoutParentInput
    revisions?: DocumentRevisionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DocumentUpdateOneWithoutChildrenNestedInput
    children?: DocumentUpdateManyWithoutParentNestedInput
    author?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    revisions?: DocumentRevisionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: DocumentUncheckedUpdateManyWithoutParentNestedInput
    revisions?: DocumentRevisionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    parentId?: string | null
    authorId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentRevisionCreateInput = {
    id?: string
    version: number
    title: string
    content: string
    summary?: string | null
    changeLog?: string | null
    tenantId?: string | null
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutRevisionsInput
    author: UserCreateNestedOneWithoutDocumentRevisionsInput
  }

  export type DocumentRevisionUncheckedCreateInput = {
    id?: string
    documentId: string
    version: number
    title: string
    content: string
    summary?: string | null
    changeLog?: string | null
    authorId: string
    tenantId?: string | null
    createdAt?: Date | string
  }

  export type DocumentRevisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutRevisionsNestedInput
    author?: UserUpdateOneRequiredWithoutDocumentRevisionsNestedInput
  }

  export type DocumentRevisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRevisionCreateManyInput = {
    id?: string
    documentId: string
    version: number
    title: string
    content: string
    summary?: string | null
    changeLog?: string | null
    authorId: string
    tenantId?: string | null
    createdAt?: Date | string
  }

  export type DocumentRevisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRevisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sales?: SaleUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sales?: SaleUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateInput = {
    id?: string
    quantity: number
    total: number
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutSalesInput
    seller: UserCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateInput = {
    id?: string
    productId: string
    quantity: number
    total: number
    soldBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type SaleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSalesNestedInput
    seller?: UserUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    soldBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyInput = {
    id?: string
    productId: string
    quantity: number
    total: number
    soldBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type SaleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    soldBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    id?: string
    name: string
    accountNumber?: string | null
    bankName?: string | null
    accountType?: string | null
    currency?: string
    currentBalance?: number
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutAccountInput
    balanceHistory?: BankBalanceCreateNestedManyWithoutAccountInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: string
    name: string
    accountNumber?: string | null
    bankName?: string | null
    accountType?: string | null
    currency?: string
    currentBalance?: number
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
    balanceHistory?: BankBalanceUncheckedCreateNestedManyWithoutAccountInput
  }

  export type BankAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
    balanceHistory?: BankBalanceUpdateManyWithoutAccountNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
    balanceHistory?: BankBalanceUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type BankAccountCreateManyInput = {
    id?: string
    name: string
    accountNumber?: string | null
    bankName?: string | null
    accountType?: string | null
    currency?: string
    currentBalance?: number
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCategoryCreateInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    description?: string | null
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutCategoryInput
  }

  export type TransactionCategoryUncheckedCreateInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    description?: string | null
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type TransactionCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutCategoryNestedInput
  }

  export type TransactionCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type TransactionCategoryCreateManyInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    description?: string | null
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: BankAccountCreateNestedOneWithoutTransactionsInput
    category?: TransactionCategoryCreateNestedOneWithoutTransactionsInput
    creator?: UserCreateNestedOneWithoutTransactionsInput
    payroll?: PayrollCreateNestedOneWithoutTransactionsInput
    expenseReimbursement?: EmployeeExpenseCreateNestedOneWithoutReimbursementTransactionInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    accountId: string
    categoryId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollId?: string | null
    expenseReimbursement?: EmployeeExpenseUncheckedCreateNestedOneWithoutReimbursementTransactionInput
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: BankAccountUpdateOneRequiredWithoutTransactionsNestedInput
    category?: TransactionCategoryUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneWithoutTransactionsNestedInput
    payroll?: PayrollUpdateOneWithoutTransactionsNestedInput
    expenseReimbursement?: EmployeeExpenseUpdateOneWithoutReimbursementTransactionNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseReimbursement?: EmployeeExpenseUncheckedUpdateOneWithoutReimbursementTransactionNestedInput
  }

  export type TransactionCreateManyInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    accountId: string
    categoryId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollId?: string | null
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BankBalanceCreateInput = {
    id?: string
    balanceDate: Date | string
    openingBalance?: number
    closingBalance?: number
    totalIncome?: number
    totalExpenses?: number
    transactionCount?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: BankAccountCreateNestedOneWithoutBalanceHistoryInput
  }

  export type BankBalanceUncheckedCreateInput = {
    id?: string
    accountId: string
    balanceDate: Date | string
    openingBalance?: number
    closingBalance?: number
    totalIncome?: number
    totalExpenses?: number
    transactionCount?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankBalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    balanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: FloatFieldUpdateOperationsInput | number
    closingBalance?: FloatFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: BankAccountUpdateOneRequiredWithoutBalanceHistoryNestedInput
  }

  export type BankBalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    balanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: FloatFieldUpdateOperationsInput | number
    closingBalance?: FloatFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankBalanceCreateManyInput = {
    id?: string
    accountId: string
    balanceDate: Date | string
    openingBalance?: number
    closingBalance?: number
    totalIncome?: number
    totalExpenses?: number
    transactionCount?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankBalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    balanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: FloatFieldUpdateOperationsInput | number
    closingBalance?: FloatFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankBalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    balanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: FloatFieldUpdateOperationsInput | number
    closingBalance?: FloatFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicTokenCreateInput = {
    id?: string
    purpose: string
    tokenHash: string
    expiresAt: Date | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMagicTokensInput
  }

  export type MagicTokenUncheckedCreateInput = {
    id?: string
    userId: string
    purpose: string
    tokenHash: string
    expiresAt: Date | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MagicTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMagicTokensNestedInput
  }

  export type MagicTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicTokenCreateManyInput = {
    id?: string
    userId: string
    purpose: string
    tokenHash: string
    expiresAt: Date | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MagicTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditTrailCreateInput = {
    id?: string
    tableName: string
    recordId: string
    operation: $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
    user?: UserCreateNestedOneWithoutAuditTrailsInput
  }

  export type AuditTrailUncheckedCreateInput = {
    id?: string
    tableName: string
    recordId: string
    operation: $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    tenantId?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditTrailUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumAuditOperationFieldUpdateOperationsInput | $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAuditTrailsNestedInput
  }

  export type AuditTrailUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumAuditOperationFieldUpdateOperationsInput | $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditTrailCreateManyInput = {
    id?: string
    tableName: string
    recordId: string
    operation: $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    userId?: string | null
    tenantId?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditTrailUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumAuditOperationFieldUpdateOperationsInput | $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditTrailUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumAuditOperationFieldUpdateOperationsInput | $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationTemplateCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    subject?: string | null
    content: string
    variables?: NotificationTemplateCreatevariablesInput | string[]
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutNotificationTemplatesCreatedInput
    rules?: NotificationRuleCreateNestedManyWithoutTemplateInput
    notifications?: NotificationCreateNestedManyWithoutTemplateInput
  }

  export type NotificationTemplateUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    subject?: string | null
    content: string
    variables?: NotificationTemplateCreatevariablesInput | string[]
    isActive?: boolean
    createdBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: NotificationRuleUncheckedCreateNestedManyWithoutTemplateInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type NotificationTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutNotificationTemplatesCreatedNestedInput
    rules?: NotificationRuleUpdateManyWithoutTemplateNestedInput
    notifications?: NotificationUpdateManyWithoutTemplateNestedInput
  }

  export type NotificationTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: NotificationRuleUncheckedUpdateManyWithoutTemplateNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type NotificationTemplateCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    subject?: string | null
    content: string
    variables?: NotificationTemplateCreatevariablesInput | string[]
    isActive?: boolean
    createdBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRuleCreateInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: NotificationTemplateCreateNestedOneWithoutRulesInput
    creator: UserCreateNestedOneWithoutNotificationRulesCreatedInput
    notifications?: NotificationCreateNestedManyWithoutRuleInput
  }

  export type NotificationRuleUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    templateId: string
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    createdBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutRuleInput
  }

  export type NotificationRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: NotificationTemplateUpdateOneRequiredWithoutRulesNestedInput
    creator?: UserUpdateOneRequiredWithoutNotificationRulesCreatedNestedInput
    notifications?: NotificationUpdateManyWithoutRuleNestedInput
  }

  export type NotificationRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type NotificationRuleCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    templateId: string
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    createdBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
    template?: NotificationTemplateCreateNestedOneWithoutNotificationsInput
    rule?: NotificationRuleCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    recipientId: string
    templateId?: string | null
    ruleId?: string | null
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    template?: NotificationTemplateUpdateOneWithoutNotificationsNestedInput
    rule?: NotificationRuleUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    recipientId: string
    templateId?: string | null
    ruleId?: string | null
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedAt?: Date | string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutPayrollsApprovedInput
    processor?: UserCreateNestedOneWithoutPayrollsProcessedInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutPayrollInput
    transactions?: TransactionCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUncheckedCreateInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutPayrollInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutPayrollsApprovedNestedInput
    processor?: UserUpdateOneWithoutPayrollsProcessedNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutPayrollNestedInput
    transactions?: TransactionUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutPayrollNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollCreateManyInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryCreateInput = {
    id?: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hoursWorked?: Decimal | DecimalJsLike | number | string | null
    overtimeHours?: Decimal | DecimalJsLike | number | string | null
    bonusAmount?: Decimal | DecimalJsLike | number | string | null
    allowances?: Decimal | DecimalJsLike | number | string | null
    grossPay: Decimal | DecimalJsLike | number | string
    taxDeductions: Decimal | DecimalJsLike | number | string
    socialSecurity: Decimal | DecimalJsLike | number | string
    otherDeductions?: Decimal | DecimalJsLike | number | string | null
    netPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payroll: PayrollCreateNestedOneWithoutPayrollEntriesInput
    employee: UserCreateNestedOneWithoutPayrollEntriesInput
  }

  export type PayrollEntryUncheckedCreateInput = {
    id?: string
    payrollId: string
    employeeId: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hoursWorked?: Decimal | DecimalJsLike | number | string | null
    overtimeHours?: Decimal | DecimalJsLike | number | string | null
    bonusAmount?: Decimal | DecimalJsLike | number | string | null
    allowances?: Decimal | DecimalJsLike | number | string | null
    grossPay: Decimal | DecimalJsLike | number | string
    taxDeductions: Decimal | DecimalJsLike | number | string
    socialSecurity: Decimal | DecimalJsLike | number | string
    otherDeductions?: Decimal | DecimalJsLike | number | string | null
    netPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hoursWorked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allowances?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payroll?: PayrollUpdateOneRequiredWithoutPayrollEntriesNestedInput
    employee?: UserUpdateOneRequiredWithoutPayrollEntriesNestedInput
  }

  export type PayrollEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payrollId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hoursWorked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allowances?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryCreateManyInput = {
    id?: string
    payrollId: string
    employeeId: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hoursWorked?: Decimal | DecimalJsLike | number | string | null
    overtimeHours?: Decimal | DecimalJsLike | number | string | null
    bonusAmount?: Decimal | DecimalJsLike | number | string | null
    allowances?: Decimal | DecimalJsLike | number | string | null
    grossPay: Decimal | DecimalJsLike | number | string
    taxDeductions: Decimal | DecimalJsLike | number | string
    socialSecurity: Decimal | DecimalJsLike | number | string
    otherDeductions?: Decimal | DecimalJsLike | number | string | null
    netPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hoursWorked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allowances?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    payrollId?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hoursWorked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allowances?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryAdjustmentCreateInput = {
    id?: string
    adjustmentType: $Enums.SalaryAdjustmentType
    previousAmount: Decimal | DecimalJsLike | number | string
    newAmount: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    reason: string
    notes?: string | null
    approvedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutSalaryAdjustmentsInput
    approver?: UserCreateNestedOneWithoutSalaryAdjustmentsApprovedInput
  }

  export type SalaryAdjustmentUncheckedCreateInput = {
    id?: string
    employeeId: string
    adjustmentType: $Enums.SalaryAdjustmentType
    previousAmount: Decimal | DecimalJsLike | number | string
    newAmount: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    reason: string
    notes?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryAdjustmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumSalaryAdjustmentTypeFieldUpdateOperationsInput | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutSalaryAdjustmentsNestedInput
    approver?: UserUpdateOneWithoutSalaryAdjustmentsApprovedNestedInput
  }

  export type SalaryAdjustmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumSalaryAdjustmentTypeFieldUpdateOperationsInput | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryAdjustmentCreateManyInput = {
    id?: string
    employeeId: string
    adjustmentType: $Enums.SalaryAdjustmentType
    previousAmount: Decimal | DecimalJsLike | number | string
    newAmount: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    reason: string
    notes?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryAdjustmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumSalaryAdjustmentTypeFieldUpdateOperationsInput | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryAdjustmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumSalaryAdjustmentTypeFieldUpdateOperationsInput | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeExpenseCreateInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutEmployeeExpensesInput
    reviewer?: UserCreateNestedOneWithoutExpenseReviewsInput
    reimbursementTransaction?: TransactionCreateNestedOneWithoutExpenseReimbursementInput
  }

  export type EmployeeExpenseUncheckedCreateInput = {
    id?: string
    employeeId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    reimbursementTransactionId?: string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeExpenseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutEmployeeExpensesNestedInput
    reviewer?: UserUpdateOneWithoutExpenseReviewsNestedInput
    reimbursementTransaction?: TransactionUpdateOneWithoutExpenseReimbursementNestedInput
  }

  export type EmployeeExpenseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeExpenseCreateManyInput = {
    id?: string
    employeeId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    reimbursementTransactionId?: string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeExpenseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeExpenseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTORequestCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    status?: $Enums.PTOStatus
    reason?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    cancelledAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutPtoRequestsInput
    approver?: UserCreateNestedOneWithoutPtoApprovalsInput
  }

  export type PTORequestUncheckedCreateInput = {
    id?: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    status?: $Enums.PTOStatus
    reason?: string | null
    submittedAt?: Date | string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    cancelledAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTORequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFieldUpdateOperationsInput | $Enums.PTOStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutPtoRequestsNestedInput
    approver?: UserUpdateOneWithoutPtoApprovalsNestedInput
  }

  export type PTORequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFieldUpdateOperationsInput | $Enums.PTOStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTORequestCreateManyInput = {
    id?: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    status?: $Enums.PTOStatus
    reason?: string | null
    submittedAt?: Date | string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    cancelledAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTORequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFieldUpdateOperationsInput | $Enums.PTOStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTORequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFieldUpdateOperationsInput | $Enums.PTOStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTOBalanceCreateInput = {
    id?: string
    year: number
    totalDays: Decimal | DecimalJsLike | number | string
    usedDays?: Decimal | DecimalJsLike | number | string
    carryOverDays?: Decimal | DecimalJsLike | number | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutPtoBalancesInput
  }

  export type PTOBalanceUncheckedCreateInput = {
    id?: string
    employeeId: string
    year: number
    totalDays: Decimal | DecimalJsLike | number | string
    usedDays?: Decimal | DecimalJsLike | number | string
    carryOverDays?: Decimal | DecimalJsLike | number | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTOBalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutPtoBalancesNestedInput
  }

  export type PTOBalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTOBalanceCreateManyInput = {
    id?: string
    employeeId: string
    year: number
    totalDays: Decimal | DecimalJsLike | number | string
    usedDays?: Decimal | DecimalJsLike | number | string
    carryOverDays?: Decimal | DecimalJsLike | number | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTOBalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTOBalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    permissions?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type TaskListRelationFilter = {
    every?: TaskWhereInput
    some?: TaskWhereInput
    none?: TaskWhereInput
  }

  export type TaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type TaskCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    assigneeId?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    assigneeId?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TaskMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    projectId?: SortOrder
    assigneeId?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type EnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type EnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DocumentNullableScalarRelationFilter = {
    is?: DocumentWhereInput | null
    isNot?: DocumentWhereInput | null
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type DocumentRevisionListRelationFilter = {
    every?: DocumentRevisionWhereInput
    some?: DocumentRevisionWhereInput
    none?: DocumentRevisionWhereInput
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentRevisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    status?: SortOrder
    tags?: SortOrder
    parentId?: SortOrder
    authorId?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    authorId?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    slug?: SortOrder
    summary?: SortOrder
    type?: SortOrder
    status?: SortOrder
    parentId?: SortOrder
    authorId?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    publishedAt?: SortOrder
    viewCount?: SortOrder
    lastViewedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    viewCount?: SortOrder
  }

  export type EnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type EnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type DocumentRevisionDocumentIdVersionCompoundUniqueInput = {
    documentId: string
    version: number
  }

  export type DocumentRevisionCountOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    changeLog?: SortOrder
    authorId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentRevisionAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type DocumentRevisionMaxOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    changeLog?: SortOrder
    authorId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentRevisionMinOrderByAggregateInput = {
    id?: SortOrder
    documentId?: SortOrder
    version?: SortOrder
    title?: SortOrder
    content?: SortOrder
    summary?: SortOrder
    changeLog?: SortOrder
    authorId?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentRevisionSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SaleListRelationFilter = {
    every?: SaleWhereInput
    some?: SaleWhereInput
    none?: SaleWhereInput
  }

  export type SaleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    price?: SortOrder
    stock?: SortOrder
    category?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type SaleCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    soldBy?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleAvgOrderByAggregateInput = {
    quantity?: SortOrder
    total?: SortOrder
  }

  export type SaleMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    soldBy?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    quantity?: SortOrder
    total?: SortOrder
    soldBy?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type SaleSumOrderByAggregateInput = {
    quantity?: SortOrder
    total?: SortOrder
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type BankBalanceListRelationFilter = {
    every?: BankBalanceWhereInput
    some?: BankBalanceWhereInput
    none?: BankBalanceWhereInput
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    accountType?: SortOrder
    currency?: SortOrder
    currentBalance?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    currentBalance?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    accountType?: SortOrder
    currency?: SortOrder
    currentBalance?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    accountNumber?: SortOrder
    bankName?: SortOrder
    accountType?: SortOrder
    currency?: SortOrder
    currentBalance?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    currentBalance?: SortOrder
  }

  export type TransactionCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TransactionCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    description?: SortOrder
    isActive?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type BankAccountScalarRelationFilter = {
    is?: BankAccountWhereInput
    isNot?: BankAccountWhereInput
  }

  export type TransactionCategoryNullableScalarRelationFilter = {
    is?: TransactionCategoryWhereInput | null
    isNot?: TransactionCategoryWhereInput | null
  }

  export type PayrollNullableScalarRelationFilter = {
    is?: PayrollWhereInput | null
    isNot?: PayrollWhereInput | null
  }

  export type EmployeeExpenseNullableScalarRelationFilter = {
    is?: EmployeeExpenseWhereInput | null
    isNot?: EmployeeExpenseWhereInput | null
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    externalId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrder
    customerName?: SortOrder
    supplierName?: SortOrder
    employeeName?: SortOrder
    projectName?: SortOrder
    items?: SortOrder
    notes?: SortOrder
    receiptUrl?: SortOrder
    mpPaymentId?: SortOrder
    mpStatus?: SortOrder
    mpPaymentType?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payrollId?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    externalId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrder
    customerName?: SortOrder
    supplierName?: SortOrder
    employeeName?: SortOrder
    projectName?: SortOrder
    notes?: SortOrder
    receiptUrl?: SortOrder
    mpPaymentId?: SortOrder
    mpStatus?: SortOrder
    mpPaymentType?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payrollId?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    type?: SortOrder
    status?: SortOrder
    paymentMethod?: SortOrder
    reference?: SortOrder
    externalId?: SortOrder
    accountId?: SortOrder
    categoryId?: SortOrder
    customerName?: SortOrder
    supplierName?: SortOrder
    employeeName?: SortOrder
    projectName?: SortOrder
    notes?: SortOrder
    receiptUrl?: SortOrder
    mpPaymentId?: SortOrder
    mpStatus?: SortOrder
    mpPaymentType?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    payrollId?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BankBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    balanceDate?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    transactionCount?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankBalanceAvgOrderByAggregateInput = {
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    transactionCount?: SortOrder
  }

  export type BankBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    balanceDate?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    transactionCount?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    balanceDate?: SortOrder
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    transactionCount?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BankBalanceSumOrderByAggregateInput = {
    openingBalance?: SortOrder
    closingBalance?: SortOrder
    totalIncome?: SortOrder
    totalExpenses?: SortOrder
    transactionCount?: SortOrder
  }

  export type RoleScalarRelationFilter = {
    is?: RoleWhereInput
    isNot?: RoleWhereInput
  }

  export type AuditTrailListRelationFilter = {
    every?: AuditTrailWhereInput
    some?: AuditTrailWhereInput
    none?: AuditTrailWhereInput
  }

  export type NotificationTemplateListRelationFilter = {
    every?: NotificationTemplateWhereInput
    some?: NotificationTemplateWhereInput
    none?: NotificationTemplateWhereInput
  }

  export type NotificationRuleListRelationFilter = {
    every?: NotificationRuleWhereInput
    some?: NotificationRuleWhereInput
    none?: NotificationRuleWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type MagicTokenListRelationFilter = {
    every?: MagicTokenWhereInput
    some?: MagicTokenWhereInput
    none?: MagicTokenWhereInput
  }

  export type PayrollListRelationFilter = {
    every?: PayrollWhereInput
    some?: PayrollWhereInput
    none?: PayrollWhereInput
  }

  export type PayrollEntryListRelationFilter = {
    every?: PayrollEntryWhereInput
    some?: PayrollEntryWhereInput
    none?: PayrollEntryWhereInput
  }

  export type SalaryAdjustmentListRelationFilter = {
    every?: SalaryAdjustmentWhereInput
    some?: SalaryAdjustmentWhereInput
    none?: SalaryAdjustmentWhereInput
  }

  export type EmployeeExpenseListRelationFilter = {
    every?: EmployeeExpenseWhereInput
    some?: EmployeeExpenseWhereInput
    none?: EmployeeExpenseWhereInput
  }

  export type PTORequestListRelationFilter = {
    every?: PTORequestWhereInput
    some?: PTORequestWhereInput
    none?: PTORequestWhereInput
  }

  export type PTOBalanceListRelationFilter = {
    every?: PTOBalanceWhereInput
    some?: PTOBalanceWhereInput
    none?: PTOBalanceWhereInput
  }

  export type AuditTrailOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MagicTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SalaryAdjustmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PTORequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PTOBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    roleId?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    roleId?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    username?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    password?: SortOrder
    isActive?: SortOrder
    roleId?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MagicTokenCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    purpose?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MagicTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    purpose?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MagicTokenMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    purpose?: SortOrder
    tokenHash?: SortOrder
    expiresAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAuditOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditOperation | EnumAuditOperationFieldRefInput<$PrismaModel>
    in?: $Enums.AuditOperation[] | ListEnumAuditOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditOperation[] | ListEnumAuditOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditOperationFilter<$PrismaModel> | $Enums.AuditOperation
  }

  export type AuditTrailCountOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    beforeData?: SortOrder
    afterData?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AuditTrailMaxOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type AuditTrailMinOrderByAggregateInput = {
    id?: SortOrder
    tableName?: SortOrder
    recordId?: SortOrder
    operation?: SortOrder
    userId?: SortOrder
    tenantId?: SortOrder
    timestamp?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
  }

  export type EnumAuditOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditOperation | EnumAuditOperationFieldRefInput<$PrismaModel>
    in?: $Enums.AuditOperation[] | ListEnumAuditOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditOperation[] | ListEnumAuditOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditOperationWithAggregatesFilter<$PrismaModel> | $Enums.AuditOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditOperationFilter<$PrismaModel>
    _max?: NestedEnumAuditOperationFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    variables?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    type?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumRuleTriggerFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleTrigger | EnumRuleTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.RuleTrigger[] | ListEnumRuleTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleTrigger[] | ListEnumRuleTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleTriggerFilter<$PrismaModel> | $Enums.RuleTrigger
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NotificationTemplateScalarRelationFilter = {
    is?: NotificationTemplateWhereInput
    isNot?: NotificationTemplateWhereInput
  }

  export type NotificationRuleCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    conditions?: SortOrder
    isActive?: SortOrder
    templateId?: SortOrder
    recipients?: SortOrder
    delay?: SortOrder
    createdBy?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationRuleAvgOrderByAggregateInput = {
    delay?: SortOrder
  }

  export type NotificationRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    isActive?: SortOrder
    templateId?: SortOrder
    delay?: SortOrder
    createdBy?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationRuleMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    trigger?: SortOrder
    isActive?: SortOrder
    templateId?: SortOrder
    delay?: SortOrder
    createdBy?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationRuleSumOrderByAggregateInput = {
    delay?: SortOrder
  }

  export type EnumRuleTriggerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleTrigger | EnumRuleTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.RuleTrigger[] | ListEnumRuleTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleTrigger[] | ListEnumRuleTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleTriggerWithAggregatesFilter<$PrismaModel> | $Enums.RuleTrigger
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRuleTriggerFilter<$PrismaModel>
    _max?: NestedEnumRuleTriggerFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NotificationTemplateNullableScalarRelationFilter = {
    is?: NotificationTemplateWhereInput | null
    isNot?: NotificationTemplateWhereInput | null
  }

  export type NotificationRuleNullableScalarRelationFilter = {
    is?: NotificationRuleWhereInput | null
    isNot?: NotificationRuleWhereInput | null
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    recipientId?: SortOrder
    templateId?: SortOrder
    ruleId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    metadata?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    readAt?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    recipientId?: SortOrder
    templateId?: SortOrder
    ruleId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    readAt?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    status?: SortOrder
    subject?: SortOrder
    content?: SortOrder
    recipientId?: SortOrder
    templateId?: SortOrder
    ruleId?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    scheduledAt?: SortOrder
    sentAt?: SortOrder
    failedAt?: SortOrder
    errorMessage?: SortOrder
    readAt?: SortOrder
    tenantId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type EnumPayrollStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollStatusFilter<$PrismaModel> | $Enums.PayrollStatus
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type PayrollCountOrderByAggregateInput = {
    id?: SortOrder
    runDate?: SortOrder
    payPeriodStart?: SortOrder
    payPeriodEnd?: SortOrder
    status?: SortOrder
    totalGrossPay?: SortOrder
    totalDeductions?: SortOrder
    totalNetPay?: SortOrder
    notes?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollAvgOrderByAggregateInput = {
    totalGrossPay?: SortOrder
    totalDeductions?: SortOrder
    totalNetPay?: SortOrder
  }

  export type PayrollMaxOrderByAggregateInput = {
    id?: SortOrder
    runDate?: SortOrder
    payPeriodStart?: SortOrder
    payPeriodEnd?: SortOrder
    status?: SortOrder
    totalGrossPay?: SortOrder
    totalDeductions?: SortOrder
    totalNetPay?: SortOrder
    notes?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollMinOrderByAggregateInput = {
    id?: SortOrder
    runDate?: SortOrder
    payPeriodStart?: SortOrder
    payPeriodEnd?: SortOrder
    status?: SortOrder
    totalGrossPay?: SortOrder
    totalDeductions?: SortOrder
    totalNetPay?: SortOrder
    notes?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    processedBy?: SortOrder
    processedAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollSumOrderByAggregateInput = {
    totalGrossPay?: SortOrder
    totalDeductions?: SortOrder
    totalNetPay?: SortOrder
  }

  export type EnumPayrollStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayrollStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollStatusFilter<$PrismaModel>
    _max?: NestedEnumPayrollStatusFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type PayrollScalarRelationFilter = {
    is?: PayrollWhereInput
    isNot?: PayrollWhereInput
  }

  export type PayrollEntryPayrollIdEmployeeIdCompoundUniqueInput = {
    payrollId: string
    employeeId: string
  }

  export type PayrollEntryCountOrderByAggregateInput = {
    id?: SortOrder
    payrollId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    bonusAmount?: SortOrder
    allowances?: SortOrder
    grossPay?: SortOrder
    taxDeductions?: SortOrder
    socialSecurity?: SortOrder
    otherDeductions?: SortOrder
    netPay?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollEntryAvgOrderByAggregateInput = {
    baseSalary?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    bonusAmount?: SortOrder
    allowances?: SortOrder
    grossPay?: SortOrder
    taxDeductions?: SortOrder
    socialSecurity?: SortOrder
    otherDeductions?: SortOrder
    netPay?: SortOrder
  }

  export type PayrollEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    payrollId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    bonusAmount?: SortOrder
    allowances?: SortOrder
    grossPay?: SortOrder
    taxDeductions?: SortOrder
    socialSecurity?: SortOrder
    otherDeductions?: SortOrder
    netPay?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollEntryMinOrderByAggregateInput = {
    id?: SortOrder
    payrollId?: SortOrder
    employeeId?: SortOrder
    baseSalary?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    bonusAmount?: SortOrder
    allowances?: SortOrder
    grossPay?: SortOrder
    taxDeductions?: SortOrder
    socialSecurity?: SortOrder
    otherDeductions?: SortOrder
    netPay?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollEntrySumOrderByAggregateInput = {
    baseSalary?: SortOrder
    hoursWorked?: SortOrder
    overtimeHours?: SortOrder
    bonusAmount?: SortOrder
    allowances?: SortOrder
    grossPay?: SortOrder
    taxDeductions?: SortOrder
    socialSecurity?: SortOrder
    otherDeductions?: SortOrder
    netPay?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumSalaryAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryAdjustmentType | EnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryAdjustmentType[] | ListEnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryAdjustmentType[] | ListEnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryAdjustmentTypeFilter<$PrismaModel> | $Enums.SalaryAdjustmentType
  }

  export type SalaryAdjustmentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    adjustmentType?: SortOrder
    previousAmount?: SortOrder
    newAmount?: SortOrder
    effectiveDate?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryAdjustmentAvgOrderByAggregateInput = {
    previousAmount?: SortOrder
    newAmount?: SortOrder
  }

  export type SalaryAdjustmentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    adjustmentType?: SortOrder
    previousAmount?: SortOrder
    newAmount?: SortOrder
    effectiveDate?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryAdjustmentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    adjustmentType?: SortOrder
    previousAmount?: SortOrder
    newAmount?: SortOrder
    effectiveDate?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SalaryAdjustmentSumOrderByAggregateInput = {
    previousAmount?: SortOrder
    newAmount?: SortOrder
  }

  export type EnumSalaryAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryAdjustmentType | EnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryAdjustmentType[] | ListEnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryAdjustmentType[] | ListEnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.SalaryAdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalaryAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumSalaryAdjustmentTypeFilter<$PrismaModel>
  }

  export type EnumExpenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusFilter<$PrismaModel> | $Enums.ExpenseStatus
  }

  export type TransactionNullableScalarRelationFilter = {
    is?: TransactionWhereInput | null
    isNot?: TransactionWhereInput | null
  }

  export type EmployeeExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    expenseDate?: SortOrder
    receiptUrl?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reimbursedAt?: SortOrder
    reimbursementTransactionId?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeExpenseAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EmployeeExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    expenseDate?: SortOrder
    receiptUrl?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reimbursedAt?: SortOrder
    reimbursementTransactionId?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    category?: SortOrder
    expenseDate?: SortOrder
    receiptUrl?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    reviewedBy?: SortOrder
    reviewedAt?: SortOrder
    reimbursedAt?: SortOrder
    reimbursementTransactionId?: SortOrder
    notes?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeExpenseSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumExpenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseStatusFilter<$PrismaModel>
    _max?: NestedEnumExpenseStatusFilter<$PrismaModel>
  }

  export type EnumPTOStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PTOStatus | EnumPTOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PTOStatus[] | ListEnumPTOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PTOStatus[] | ListEnumPTOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPTOStatusFilter<$PrismaModel> | $Enums.PTOStatus
  }

  export type PTORequestCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    cancelledAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PTORequestAvgOrderByAggregateInput = {
    totalDays?: SortOrder
  }

  export type PTORequestMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    cancelledAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PTORequestMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    submittedAt?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    rejectedAt?: SortOrder
    cancelledAt?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PTORequestSumOrderByAggregateInput = {
    totalDays?: SortOrder
  }

  export type EnumPTOStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PTOStatus | EnumPTOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PTOStatus[] | ListEnumPTOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PTOStatus[] | ListEnumPTOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPTOStatusWithAggregatesFilter<$PrismaModel> | $Enums.PTOStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPTOStatusFilter<$PrismaModel>
    _max?: NestedEnumPTOStatusFilter<$PrismaModel>
  }

  export type PTOBalanceEmployeeIdYearCompoundUniqueInput = {
    employeeId: string
    year: number
  }

  export type PTOBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    carryOverDays?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PTOBalanceAvgOrderByAggregateInput = {
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    carryOverDays?: SortOrder
  }

  export type PTOBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    carryOverDays?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PTOBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    carryOverDays?: SortOrder
    tenantId?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    deletedBy?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PTOBalanceSumOrderByAggregateInput = {
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    carryOverDays?: SortOrder
  }

  export type RoleCreatepermissionsInput = {
    set: string[]
  }

  export type UserCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutRoleInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type RoleUpdatepermissionsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutRoleNestedInput = {
    create?: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput> | UserCreateWithoutRoleInput[] | UserUncheckedCreateWithoutRoleInput[]
    connectOrCreate?: UserCreateOrConnectWithoutRoleInput | UserCreateOrConnectWithoutRoleInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutRoleInput | UserUpsertWithWhereUniqueWithoutRoleInput[]
    createMany?: UserCreateManyRoleInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutRoleInput | UserUpdateWithWhereUniqueWithoutRoleInput[]
    updateMany?: UserUpdateManyWithWhereWithoutRoleInput | UserUpdateManyWithWhereWithoutRoleInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type TaskCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type TaskUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput> | TaskCreateWithoutProjectInput[] | TaskUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutProjectInput | TaskCreateOrConnectWithoutProjectInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutProjectInput | TaskUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: TaskCreateManyProjectInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutProjectInput | TaskUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutProjectInput | TaskUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutTasksInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTasksInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type ProjectUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutTasksInput
    upsert?: ProjectUpsertWithoutTasksInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutTasksInput, ProjectUpdateWithoutTasksInput>, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateOneWithoutTasksNestedInput = {
    create?: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    connectOrCreate?: UserCreateOrConnectWithoutTasksInput
    upsert?: UserUpsertWithoutTasksInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTasksInput, UserUpdateWithoutTasksInput>, UserUncheckedUpdateWithoutTasksInput>
  }

  export type DocumentCreatetagsInput = {
    set: string[]
  }

  export type DocumentCreateNestedOneWithoutChildrenInput = {
    create?: XOR<DocumentCreateWithoutChildrenInput, DocumentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutChildrenInput
    connect?: DocumentWhereUniqueInput
  }

  export type DocumentCreateNestedManyWithoutParentInput = {
    create?: XOR<DocumentCreateWithoutParentInput, DocumentUncheckedCreateWithoutParentInput> | DocumentCreateWithoutParentInput[] | DocumentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutParentInput | DocumentCreateOrConnectWithoutParentInput[]
    createMany?: DocumentCreateManyParentInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentRevisionCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentRevisionCreateWithoutDocumentInput, DocumentRevisionUncheckedCreateWithoutDocumentInput> | DocumentRevisionCreateWithoutDocumentInput[] | DocumentRevisionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentRevisionCreateOrConnectWithoutDocumentInput | DocumentRevisionCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentRevisionCreateManyDocumentInputEnvelope
    connect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<DocumentCreateWithoutParentInput, DocumentUncheckedCreateWithoutParentInput> | DocumentCreateWithoutParentInput[] | DocumentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutParentInput | DocumentCreateOrConnectWithoutParentInput[]
    createMany?: DocumentCreateManyParentInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentRevisionUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<DocumentRevisionCreateWithoutDocumentInput, DocumentRevisionUncheckedCreateWithoutDocumentInput> | DocumentRevisionCreateWithoutDocumentInput[] | DocumentRevisionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentRevisionCreateOrConnectWithoutDocumentInput | DocumentRevisionCreateOrConnectWithoutDocumentInput[]
    createMany?: DocumentRevisionCreateManyDocumentInputEnvelope
    connect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
  }

  export type EnumDocumentTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentType
  }

  export type EnumDocumentStatusFieldUpdateOperationsInput = {
    set?: $Enums.DocumentStatus
  }

  export type DocumentUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DocumentUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<DocumentCreateWithoutChildrenInput, DocumentUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutChildrenInput
    upsert?: DocumentUpsertWithoutChildrenInput
    disconnect?: DocumentWhereInput | boolean
    delete?: DocumentWhereInput | boolean
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutChildrenInput, DocumentUpdateWithoutChildrenInput>, DocumentUncheckedUpdateWithoutChildrenInput>
  }

  export type DocumentUpdateManyWithoutParentNestedInput = {
    create?: XOR<DocumentCreateWithoutParentInput, DocumentUncheckedCreateWithoutParentInput> | DocumentCreateWithoutParentInput[] | DocumentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutParentInput | DocumentCreateOrConnectWithoutParentInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutParentInput | DocumentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DocumentCreateManyParentInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutParentInput | DocumentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutParentInput | DocumentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentsInput
    upsert?: UserUpsertWithoutDocumentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentsInput, UserUpdateWithoutDocumentsInput>, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type DocumentRevisionUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentRevisionCreateWithoutDocumentInput, DocumentRevisionUncheckedCreateWithoutDocumentInput> | DocumentRevisionCreateWithoutDocumentInput[] | DocumentRevisionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentRevisionCreateOrConnectWithoutDocumentInput | DocumentRevisionCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentRevisionUpsertWithWhereUniqueWithoutDocumentInput | DocumentRevisionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentRevisionCreateManyDocumentInputEnvelope
    set?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    disconnect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    delete?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    connect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    update?: DocumentRevisionUpdateWithWhereUniqueWithoutDocumentInput | DocumentRevisionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentRevisionUpdateManyWithWhereWithoutDocumentInput | DocumentRevisionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentRevisionScalarWhereInput | DocumentRevisionScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<DocumentCreateWithoutParentInput, DocumentUncheckedCreateWithoutParentInput> | DocumentCreateWithoutParentInput[] | DocumentUncheckedCreateWithoutParentInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutParentInput | DocumentCreateOrConnectWithoutParentInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutParentInput | DocumentUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: DocumentCreateManyParentInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutParentInput | DocumentUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutParentInput | DocumentUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentRevisionUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<DocumentRevisionCreateWithoutDocumentInput, DocumentRevisionUncheckedCreateWithoutDocumentInput> | DocumentRevisionCreateWithoutDocumentInput[] | DocumentRevisionUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: DocumentRevisionCreateOrConnectWithoutDocumentInput | DocumentRevisionCreateOrConnectWithoutDocumentInput[]
    upsert?: DocumentRevisionUpsertWithWhereUniqueWithoutDocumentInput | DocumentRevisionUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: DocumentRevisionCreateManyDocumentInputEnvelope
    set?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    disconnect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    delete?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    connect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    update?: DocumentRevisionUpdateWithWhereUniqueWithoutDocumentInput | DocumentRevisionUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: DocumentRevisionUpdateManyWithWhereWithoutDocumentInput | DocumentRevisionUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: DocumentRevisionScalarWhereInput | DocumentRevisionScalarWhereInput[]
  }

  export type DocumentCreateNestedOneWithoutRevisionsInput = {
    create?: XOR<DocumentCreateWithoutRevisionsInput, DocumentUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutRevisionsInput
    connect?: DocumentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDocumentRevisionsInput = {
    create?: XOR<UserCreateWithoutDocumentRevisionsInput, UserUncheckedCreateWithoutDocumentRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentRevisionsInput
    connect?: UserWhereUniqueInput
  }

  export type DocumentUpdateOneRequiredWithoutRevisionsNestedInput = {
    create?: XOR<DocumentCreateWithoutRevisionsInput, DocumentUncheckedCreateWithoutRevisionsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutRevisionsInput
    upsert?: DocumentUpsertWithoutRevisionsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutRevisionsInput, DocumentUpdateWithoutRevisionsInput>, DocumentUncheckedUpdateWithoutRevisionsInput>
  }

  export type UserUpdateOneRequiredWithoutDocumentRevisionsNestedInput = {
    create?: XOR<UserCreateWithoutDocumentRevisionsInput, UserUncheckedCreateWithoutDocumentRevisionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDocumentRevisionsInput
    upsert?: UserUpsertWithoutDocumentRevisionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDocumentRevisionsInput, UserUpdateWithoutDocumentRevisionsInput>, UserUncheckedUpdateWithoutDocumentRevisionsInput>
  }

  export type SaleCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleCreateWithoutProductInput, SaleUncheckedCreateWithoutProductInput> | SaleCreateWithoutProductInput[] | SaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutProductInput | SaleCreateOrConnectWithoutProductInput[]
    createMany?: SaleCreateManyProductInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<SaleCreateWithoutProductInput, SaleUncheckedCreateWithoutProductInput> | SaleCreateWithoutProductInput[] | SaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutProductInput | SaleCreateOrConnectWithoutProductInput[]
    createMany?: SaleCreateManyProductInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type SaleUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleCreateWithoutProductInput, SaleUncheckedCreateWithoutProductInput> | SaleCreateWithoutProductInput[] | SaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutProductInput | SaleCreateOrConnectWithoutProductInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutProductInput | SaleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleCreateManyProductInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutProductInput | SaleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutProductInput | SaleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<SaleCreateWithoutProductInput, SaleUncheckedCreateWithoutProductInput> | SaleCreateWithoutProductInput[] | SaleUncheckedCreateWithoutProductInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutProductInput | SaleCreateOrConnectWithoutProductInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutProductInput | SaleUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: SaleCreateManyProductInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutProductInput | SaleUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutProductInput | SaleUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutSalesInput = {
    create?: XOR<ProductCreateWithoutSalesInput, ProductUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSalesInput
    connect?: ProductWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSalesInput = {
    create?: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesInput
    connect?: UserWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<ProductCreateWithoutSalesInput, ProductUncheckedCreateWithoutSalesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutSalesInput
    upsert?: ProductUpsertWithoutSalesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutSalesInput, ProductUpdateWithoutSalesInput>, ProductUncheckedUpdateWithoutSalesInput>
  }

  export type UserUpdateOneRequiredWithoutSalesNestedInput = {
    create?: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalesInput
    upsert?: UserUpsertWithoutSalesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalesInput, UserUpdateWithoutSalesInput>, UserUncheckedUpdateWithoutSalesInput>
  }

  export type TransactionCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BankBalanceCreateNestedManyWithoutAccountInput = {
    create?: XOR<BankBalanceCreateWithoutAccountInput, BankBalanceUncheckedCreateWithoutAccountInput> | BankBalanceCreateWithoutAccountInput[] | BankBalanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankBalanceCreateOrConnectWithoutAccountInput | BankBalanceCreateOrConnectWithoutAccountInput[]
    createMany?: BankBalanceCreateManyAccountInputEnvelope
    connect?: BankBalanceWhereUniqueInput | BankBalanceWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type BankBalanceUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<BankBalanceCreateWithoutAccountInput, BankBalanceUncheckedCreateWithoutAccountInput> | BankBalanceCreateWithoutAccountInput[] | BankBalanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankBalanceCreateOrConnectWithoutAccountInput | BankBalanceCreateOrConnectWithoutAccountInput[]
    createMany?: BankBalanceCreateManyAccountInputEnvelope
    connect?: BankBalanceWhereUniqueInput | BankBalanceWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BankBalanceUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BankBalanceCreateWithoutAccountInput, BankBalanceUncheckedCreateWithoutAccountInput> | BankBalanceCreateWithoutAccountInput[] | BankBalanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankBalanceCreateOrConnectWithoutAccountInput | BankBalanceCreateOrConnectWithoutAccountInput[]
    upsert?: BankBalanceUpsertWithWhereUniqueWithoutAccountInput | BankBalanceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BankBalanceCreateManyAccountInputEnvelope
    set?: BankBalanceWhereUniqueInput | BankBalanceWhereUniqueInput[]
    disconnect?: BankBalanceWhereUniqueInput | BankBalanceWhereUniqueInput[]
    delete?: BankBalanceWhereUniqueInput | BankBalanceWhereUniqueInput[]
    connect?: BankBalanceWhereUniqueInput | BankBalanceWhereUniqueInput[]
    update?: BankBalanceUpdateWithWhereUniqueWithoutAccountInput | BankBalanceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BankBalanceUpdateManyWithWhereWithoutAccountInput | BankBalanceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BankBalanceScalarWhereInput | BankBalanceScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput> | TransactionCreateWithoutAccountInput[] | TransactionUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutAccountInput | TransactionCreateOrConnectWithoutAccountInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutAccountInput | TransactionUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: TransactionCreateManyAccountInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutAccountInput | TransactionUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutAccountInput | TransactionUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BankBalanceUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<BankBalanceCreateWithoutAccountInput, BankBalanceUncheckedCreateWithoutAccountInput> | BankBalanceCreateWithoutAccountInput[] | BankBalanceUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: BankBalanceCreateOrConnectWithoutAccountInput | BankBalanceCreateOrConnectWithoutAccountInput[]
    upsert?: BankBalanceUpsertWithWhereUniqueWithoutAccountInput | BankBalanceUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: BankBalanceCreateManyAccountInputEnvelope
    set?: BankBalanceWhereUniqueInput | BankBalanceWhereUniqueInput[]
    disconnect?: BankBalanceWhereUniqueInput | BankBalanceWhereUniqueInput[]
    delete?: BankBalanceWhereUniqueInput | BankBalanceWhereUniqueInput[]
    connect?: BankBalanceWhereUniqueInput | BankBalanceWhereUniqueInput[]
    update?: BankBalanceUpdateWithWhereUniqueWithoutAccountInput | BankBalanceUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: BankBalanceUpdateManyWithWhereWithoutAccountInput | BankBalanceUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: BankBalanceScalarWhereInput | BankBalanceScalarWhereInput[]
  }

  export type TransactionCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type TransactionUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCategoryInput | TransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCategoryInput | TransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCategoryInput | TransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput> | TransactionCreateWithoutCategoryInput[] | TransactionUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCategoryInput | TransactionCreateOrConnectWithoutCategoryInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCategoryInput | TransactionUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: TransactionCreateManyCategoryInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCategoryInput | TransactionUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCategoryInput | TransactionUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type BankAccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutTransactionsInput
    connect?: BankAccountWhereUniqueInput
  }

  export type TransactionCategoryCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<TransactionCategoryCreateWithoutTransactionsInput, TransactionCategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TransactionCategoryCreateOrConnectWithoutTransactionsInput
    connect?: TransactionCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type PayrollCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<PayrollCreateWithoutTransactionsInput, PayrollUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PayrollCreateOrConnectWithoutTransactionsInput
    connect?: PayrollWhereUniqueInput
  }

  export type EmployeeExpenseCreateNestedOneWithoutReimbursementTransactionInput = {
    create?: XOR<EmployeeExpenseCreateWithoutReimbursementTransactionInput, EmployeeExpenseUncheckedCreateWithoutReimbursementTransactionInput>
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutReimbursementTransactionInput
    connect?: EmployeeExpenseWhereUniqueInput
  }

  export type EmployeeExpenseUncheckedCreateNestedOneWithoutReimbursementTransactionInput = {
    create?: XOR<EmployeeExpenseCreateWithoutReimbursementTransactionInput, EmployeeExpenseUncheckedCreateWithoutReimbursementTransactionInput>
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutReimbursementTransactionInput
    connect?: EmployeeExpenseWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type BankAccountUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutTransactionsInput
    upsert?: BankAccountUpsertWithoutTransactionsInput
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutTransactionsInput, BankAccountUpdateWithoutTransactionsInput>, BankAccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionCategoryUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<TransactionCategoryCreateWithoutTransactionsInput, TransactionCategoryUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: TransactionCategoryCreateOrConnectWithoutTransactionsInput
    upsert?: TransactionCategoryUpsertWithoutTransactionsInput
    disconnect?: TransactionCategoryWhereInput | boolean
    delete?: TransactionCategoryWhereInput | boolean
    connect?: TransactionCategoryWhereUniqueInput
    update?: XOR<XOR<TransactionCategoryUpdateToOneWithWhereWithoutTransactionsInput, TransactionCategoryUpdateWithoutTransactionsInput>, TransactionCategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type PayrollUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<PayrollCreateWithoutTransactionsInput, PayrollUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PayrollCreateOrConnectWithoutTransactionsInput
    upsert?: PayrollUpsertWithoutTransactionsInput
    disconnect?: PayrollWhereInput | boolean
    delete?: PayrollWhereInput | boolean
    connect?: PayrollWhereUniqueInput
    update?: XOR<XOR<PayrollUpdateToOneWithWhereWithoutTransactionsInput, PayrollUpdateWithoutTransactionsInput>, PayrollUncheckedUpdateWithoutTransactionsInput>
  }

  export type EmployeeExpenseUpdateOneWithoutReimbursementTransactionNestedInput = {
    create?: XOR<EmployeeExpenseCreateWithoutReimbursementTransactionInput, EmployeeExpenseUncheckedCreateWithoutReimbursementTransactionInput>
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutReimbursementTransactionInput
    upsert?: EmployeeExpenseUpsertWithoutReimbursementTransactionInput
    disconnect?: EmployeeExpenseWhereInput | boolean
    delete?: EmployeeExpenseWhereInput | boolean
    connect?: EmployeeExpenseWhereUniqueInput
    update?: XOR<XOR<EmployeeExpenseUpdateToOneWithWhereWithoutReimbursementTransactionInput, EmployeeExpenseUpdateWithoutReimbursementTransactionInput>, EmployeeExpenseUncheckedUpdateWithoutReimbursementTransactionInput>
  }

  export type EmployeeExpenseUncheckedUpdateOneWithoutReimbursementTransactionNestedInput = {
    create?: XOR<EmployeeExpenseCreateWithoutReimbursementTransactionInput, EmployeeExpenseUncheckedCreateWithoutReimbursementTransactionInput>
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutReimbursementTransactionInput
    upsert?: EmployeeExpenseUpsertWithoutReimbursementTransactionInput
    disconnect?: EmployeeExpenseWhereInput | boolean
    delete?: EmployeeExpenseWhereInput | boolean
    connect?: EmployeeExpenseWhereUniqueInput
    update?: XOR<XOR<EmployeeExpenseUpdateToOneWithWhereWithoutReimbursementTransactionInput, EmployeeExpenseUpdateWithoutReimbursementTransactionInput>, EmployeeExpenseUncheckedUpdateWithoutReimbursementTransactionInput>
  }

  export type BankAccountCreateNestedOneWithoutBalanceHistoryInput = {
    create?: XOR<BankAccountCreateWithoutBalanceHistoryInput, BankAccountUncheckedCreateWithoutBalanceHistoryInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutBalanceHistoryInput
    connect?: BankAccountWhereUniqueInput
  }

  export type BankAccountUpdateOneRequiredWithoutBalanceHistoryNestedInput = {
    create?: XOR<BankAccountCreateWithoutBalanceHistoryInput, BankAccountUncheckedCreateWithoutBalanceHistoryInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutBalanceHistoryInput
    upsert?: BankAccountUpsertWithoutBalanceHistoryInput
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutBalanceHistoryInput, BankAccountUpdateWithoutBalanceHistoryInput>, BankAccountUncheckedUpdateWithoutBalanceHistoryInput>
  }

  export type RoleCreateNestedOneWithoutUsersInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    connect?: RoleWhereUniqueInput
  }

  export type TaskCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutAuthorInput = {
    create?: XOR<DocumentCreateWithoutAuthorInput, DocumentUncheckedCreateWithoutAuthorInput> | DocumentCreateWithoutAuthorInput[] | DocumentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutAuthorInput | DocumentCreateOrConnectWithoutAuthorInput[]
    createMany?: DocumentCreateManyAuthorInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentRevisionCreateNestedManyWithoutAuthorInput = {
    create?: XOR<DocumentRevisionCreateWithoutAuthorInput, DocumentRevisionUncheckedCreateWithoutAuthorInput> | DocumentRevisionCreateWithoutAuthorInput[] | DocumentRevisionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: DocumentRevisionCreateOrConnectWithoutAuthorInput | DocumentRevisionCreateOrConnectWithoutAuthorInput[]
    createMany?: DocumentRevisionCreateManyAuthorInputEnvelope
    connect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
  }

  export type SaleCreateNestedManyWithoutSellerInput = {
    create?: XOR<SaleCreateWithoutSellerInput, SaleUncheckedCreateWithoutSellerInput> | SaleCreateWithoutSellerInput[] | SaleUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutSellerInput | SaleCreateOrConnectWithoutSellerInput[]
    createMany?: SaleCreateManySellerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type AuditTrailCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput> | AuditTrailCreateWithoutUserInput[] | AuditTrailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUserInput | AuditTrailCreateOrConnectWithoutUserInput[]
    createMany?: AuditTrailCreateManyUserInputEnvelope
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
  }

  export type NotificationTemplateCreateNestedManyWithoutCreatorInput = {
    create?: XOR<NotificationTemplateCreateWithoutCreatorInput, NotificationTemplateUncheckedCreateWithoutCreatorInput> | NotificationTemplateCreateWithoutCreatorInput[] | NotificationTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutCreatorInput | NotificationTemplateCreateOrConnectWithoutCreatorInput[]
    createMany?: NotificationTemplateCreateManyCreatorInputEnvelope
    connect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
  }

  export type NotificationRuleCreateNestedManyWithoutCreatorInput = {
    create?: XOR<NotificationRuleCreateWithoutCreatorInput, NotificationRuleUncheckedCreateWithoutCreatorInput> | NotificationRuleCreateWithoutCreatorInput[] | NotificationRuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutCreatorInput | NotificationRuleCreateOrConnectWithoutCreatorInput[]
    createMany?: NotificationRuleCreateManyCreatorInputEnvelope
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MagicTokenCreateNestedManyWithoutUserInput = {
    create?: XOR<MagicTokenCreateWithoutUserInput, MagicTokenUncheckedCreateWithoutUserInput> | MagicTokenCreateWithoutUserInput[] | MagicTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MagicTokenCreateOrConnectWithoutUserInput | MagicTokenCreateOrConnectWithoutUserInput[]
    createMany?: MagicTokenCreateManyUserInputEnvelope
    connect?: MagicTokenWhereUniqueInput | MagicTokenWhereUniqueInput[]
  }

  export type PayrollCreateNestedManyWithoutApproverInput = {
    create?: XOR<PayrollCreateWithoutApproverInput, PayrollUncheckedCreateWithoutApproverInput> | PayrollCreateWithoutApproverInput[] | PayrollUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutApproverInput | PayrollCreateOrConnectWithoutApproverInput[]
    createMany?: PayrollCreateManyApproverInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PayrollCreateNestedManyWithoutProcessorInput = {
    create?: XOR<PayrollCreateWithoutProcessorInput, PayrollUncheckedCreateWithoutProcessorInput> | PayrollCreateWithoutProcessorInput[] | PayrollUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutProcessorInput | PayrollCreateOrConnectWithoutProcessorInput[]
    createMany?: PayrollCreateManyProcessorInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PayrollEntryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type SalaryAdjustmentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryAdjustmentCreateWithoutEmployeeInput, SalaryAdjustmentUncheckedCreateWithoutEmployeeInput> | SalaryAdjustmentCreateWithoutEmployeeInput[] | SalaryAdjustmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryAdjustmentCreateOrConnectWithoutEmployeeInput | SalaryAdjustmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryAdjustmentCreateManyEmployeeInputEnvelope
    connect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
  }

  export type SalaryAdjustmentCreateNestedManyWithoutApproverInput = {
    create?: XOR<SalaryAdjustmentCreateWithoutApproverInput, SalaryAdjustmentUncheckedCreateWithoutApproverInput> | SalaryAdjustmentCreateWithoutApproverInput[] | SalaryAdjustmentUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: SalaryAdjustmentCreateOrConnectWithoutApproverInput | SalaryAdjustmentCreateOrConnectWithoutApproverInput[]
    createMany?: SalaryAdjustmentCreateManyApproverInputEnvelope
    connect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
  }

  export type EmployeeExpenseCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeExpenseCreateWithoutEmployeeInput, EmployeeExpenseUncheckedCreateWithoutEmployeeInput> | EmployeeExpenseCreateWithoutEmployeeInput[] | EmployeeExpenseUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutEmployeeInput | EmployeeExpenseCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeExpenseCreateManyEmployeeInputEnvelope
    connect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
  }

  export type EmployeeExpenseCreateNestedManyWithoutReviewerInput = {
    create?: XOR<EmployeeExpenseCreateWithoutReviewerInput, EmployeeExpenseUncheckedCreateWithoutReviewerInput> | EmployeeExpenseCreateWithoutReviewerInput[] | EmployeeExpenseUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutReviewerInput | EmployeeExpenseCreateOrConnectWithoutReviewerInput[]
    createMany?: EmployeeExpenseCreateManyReviewerInputEnvelope
    connect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
  }

  export type PTORequestCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PTORequestCreateWithoutEmployeeInput, PTORequestUncheckedCreateWithoutEmployeeInput> | PTORequestCreateWithoutEmployeeInput[] | PTORequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PTORequestCreateOrConnectWithoutEmployeeInput | PTORequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: PTORequestCreateManyEmployeeInputEnvelope
    connect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
  }

  export type PTORequestCreateNestedManyWithoutApproverInput = {
    create?: XOR<PTORequestCreateWithoutApproverInput, PTORequestUncheckedCreateWithoutApproverInput> | PTORequestCreateWithoutApproverInput[] | PTORequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PTORequestCreateOrConnectWithoutApproverInput | PTORequestCreateOrConnectWithoutApproverInput[]
    createMany?: PTORequestCreateManyApproverInputEnvelope
    connect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
  }

  export type PTOBalanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PTOBalanceCreateWithoutEmployeeInput, PTOBalanceUncheckedCreateWithoutEmployeeInput> | PTOBalanceCreateWithoutEmployeeInput[] | PTOBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PTOBalanceCreateOrConnectWithoutEmployeeInput | PTOBalanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: PTOBalanceCreateManyEmployeeInputEnvelope
    connect?: PTOBalanceWhereUniqueInput | PTOBalanceWhereUniqueInput[]
  }

  export type TaskUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<DocumentCreateWithoutAuthorInput, DocumentUncheckedCreateWithoutAuthorInput> | DocumentCreateWithoutAuthorInput[] | DocumentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutAuthorInput | DocumentCreateOrConnectWithoutAuthorInput[]
    createMany?: DocumentCreateManyAuthorInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<DocumentRevisionCreateWithoutAuthorInput, DocumentRevisionUncheckedCreateWithoutAuthorInput> | DocumentRevisionCreateWithoutAuthorInput[] | DocumentRevisionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: DocumentRevisionCreateOrConnectWithoutAuthorInput | DocumentRevisionCreateOrConnectWithoutAuthorInput[]
    createMany?: DocumentRevisionCreateManyAuthorInputEnvelope
    connect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
  }

  export type SaleUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<SaleCreateWithoutSellerInput, SaleUncheckedCreateWithoutSellerInput> | SaleCreateWithoutSellerInput[] | SaleUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutSellerInput | SaleCreateOrConnectWithoutSellerInput[]
    createMany?: SaleCreateManySellerInputEnvelope
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type AuditTrailUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput> | AuditTrailCreateWithoutUserInput[] | AuditTrailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUserInput | AuditTrailCreateOrConnectWithoutUserInput[]
    createMany?: AuditTrailCreateManyUserInputEnvelope
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
  }

  export type NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<NotificationTemplateCreateWithoutCreatorInput, NotificationTemplateUncheckedCreateWithoutCreatorInput> | NotificationTemplateCreateWithoutCreatorInput[] | NotificationTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutCreatorInput | NotificationTemplateCreateOrConnectWithoutCreatorInput[]
    createMany?: NotificationTemplateCreateManyCreatorInputEnvelope
    connect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
  }

  export type NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<NotificationRuleCreateWithoutCreatorInput, NotificationRuleUncheckedCreateWithoutCreatorInput> | NotificationRuleCreateWithoutCreatorInput[] | NotificationRuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutCreatorInput | NotificationRuleCreateOrConnectWithoutCreatorInput[]
    createMany?: NotificationRuleCreateManyCreatorInputEnvelope
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRecipientInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MagicTokenUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MagicTokenCreateWithoutUserInput, MagicTokenUncheckedCreateWithoutUserInput> | MagicTokenCreateWithoutUserInput[] | MagicTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MagicTokenCreateOrConnectWithoutUserInput | MagicTokenCreateOrConnectWithoutUserInput[]
    createMany?: MagicTokenCreateManyUserInputEnvelope
    connect?: MagicTokenWhereUniqueInput | MagicTokenWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<PayrollCreateWithoutApproverInput, PayrollUncheckedCreateWithoutApproverInput> | PayrollCreateWithoutApproverInput[] | PayrollUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutApproverInput | PayrollCreateOrConnectWithoutApproverInput[]
    createMany?: PayrollCreateManyApproverInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PayrollUncheckedCreateNestedManyWithoutProcessorInput = {
    create?: XOR<PayrollCreateWithoutProcessorInput, PayrollUncheckedCreateWithoutProcessorInput> | PayrollCreateWithoutProcessorInput[] | PayrollUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutProcessorInput | PayrollCreateOrConnectWithoutProcessorInput[]
    createMany?: PayrollCreateManyProcessorInputEnvelope
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
  }

  export type PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<SalaryAdjustmentCreateWithoutEmployeeInput, SalaryAdjustmentUncheckedCreateWithoutEmployeeInput> | SalaryAdjustmentCreateWithoutEmployeeInput[] | SalaryAdjustmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryAdjustmentCreateOrConnectWithoutEmployeeInput | SalaryAdjustmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: SalaryAdjustmentCreateManyEmployeeInputEnvelope
    connect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
  }

  export type SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<SalaryAdjustmentCreateWithoutApproverInput, SalaryAdjustmentUncheckedCreateWithoutApproverInput> | SalaryAdjustmentCreateWithoutApproverInput[] | SalaryAdjustmentUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: SalaryAdjustmentCreateOrConnectWithoutApproverInput | SalaryAdjustmentCreateOrConnectWithoutApproverInput[]
    createMany?: SalaryAdjustmentCreateManyApproverInputEnvelope
    connect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
  }

  export type EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeExpenseCreateWithoutEmployeeInput, EmployeeExpenseUncheckedCreateWithoutEmployeeInput> | EmployeeExpenseCreateWithoutEmployeeInput[] | EmployeeExpenseUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutEmployeeInput | EmployeeExpenseCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeExpenseCreateManyEmployeeInputEnvelope
    connect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
  }

  export type EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput = {
    create?: XOR<EmployeeExpenseCreateWithoutReviewerInput, EmployeeExpenseUncheckedCreateWithoutReviewerInput> | EmployeeExpenseCreateWithoutReviewerInput[] | EmployeeExpenseUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutReviewerInput | EmployeeExpenseCreateOrConnectWithoutReviewerInput[]
    createMany?: EmployeeExpenseCreateManyReviewerInputEnvelope
    connect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
  }

  export type PTORequestUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PTORequestCreateWithoutEmployeeInput, PTORequestUncheckedCreateWithoutEmployeeInput> | PTORequestCreateWithoutEmployeeInput[] | PTORequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PTORequestCreateOrConnectWithoutEmployeeInput | PTORequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: PTORequestCreateManyEmployeeInputEnvelope
    connect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
  }

  export type PTORequestUncheckedCreateNestedManyWithoutApproverInput = {
    create?: XOR<PTORequestCreateWithoutApproverInput, PTORequestUncheckedCreateWithoutApproverInput> | PTORequestCreateWithoutApproverInput[] | PTORequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PTORequestCreateOrConnectWithoutApproverInput | PTORequestCreateOrConnectWithoutApproverInput[]
    createMany?: PTORequestCreateManyApproverInputEnvelope
    connect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
  }

  export type PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PTOBalanceCreateWithoutEmployeeInput, PTOBalanceUncheckedCreateWithoutEmployeeInput> | PTOBalanceCreateWithoutEmployeeInput[] | PTOBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PTOBalanceCreateOrConnectWithoutEmployeeInput | PTOBalanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: PTOBalanceCreateManyEmployeeInputEnvelope
    connect?: PTOBalanceWhereUniqueInput | PTOBalanceWhereUniqueInput[]
  }

  export type RoleUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    connectOrCreate?: RoleCreateOrConnectWithoutUsersInput
    upsert?: RoleUpsertWithoutUsersInput
    connect?: RoleWhereUniqueInput
    update?: XOR<XOR<RoleUpdateToOneWithWhereWithoutUsersInput, RoleUpdateWithoutUsersInput>, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type TaskUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<DocumentCreateWithoutAuthorInput, DocumentUncheckedCreateWithoutAuthorInput> | DocumentCreateWithoutAuthorInput[] | DocumentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutAuthorInput | DocumentCreateOrConnectWithoutAuthorInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutAuthorInput | DocumentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: DocumentCreateManyAuthorInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutAuthorInput | DocumentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutAuthorInput | DocumentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentRevisionUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<DocumentRevisionCreateWithoutAuthorInput, DocumentRevisionUncheckedCreateWithoutAuthorInput> | DocumentRevisionCreateWithoutAuthorInput[] | DocumentRevisionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: DocumentRevisionCreateOrConnectWithoutAuthorInput | DocumentRevisionCreateOrConnectWithoutAuthorInput[]
    upsert?: DocumentRevisionUpsertWithWhereUniqueWithoutAuthorInput | DocumentRevisionUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: DocumentRevisionCreateManyAuthorInputEnvelope
    set?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    disconnect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    delete?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    connect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    update?: DocumentRevisionUpdateWithWhereUniqueWithoutAuthorInput | DocumentRevisionUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: DocumentRevisionUpdateManyWithWhereWithoutAuthorInput | DocumentRevisionUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: DocumentRevisionScalarWhereInput | DocumentRevisionScalarWhereInput[]
  }

  export type SaleUpdateManyWithoutSellerNestedInput = {
    create?: XOR<SaleCreateWithoutSellerInput, SaleUncheckedCreateWithoutSellerInput> | SaleCreateWithoutSellerInput[] | SaleUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutSellerInput | SaleCreateOrConnectWithoutSellerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutSellerInput | SaleUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: SaleCreateManySellerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutSellerInput | SaleUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutSellerInput | SaleUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreatorInput | TransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreatorInput | TransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreatorInput | TransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AuditTrailUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput> | AuditTrailCreateWithoutUserInput[] | AuditTrailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUserInput | AuditTrailCreateOrConnectWithoutUserInput[]
    upsert?: AuditTrailUpsertWithWhereUniqueWithoutUserInput | AuditTrailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditTrailCreateManyUserInputEnvelope
    set?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    disconnect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    delete?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    update?: AuditTrailUpdateWithWhereUniqueWithoutUserInput | AuditTrailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditTrailUpdateManyWithWhereWithoutUserInput | AuditTrailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
  }

  export type NotificationTemplateUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<NotificationTemplateCreateWithoutCreatorInput, NotificationTemplateUncheckedCreateWithoutCreatorInput> | NotificationTemplateCreateWithoutCreatorInput[] | NotificationTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutCreatorInput | NotificationTemplateCreateOrConnectWithoutCreatorInput[]
    upsert?: NotificationTemplateUpsertWithWhereUniqueWithoutCreatorInput | NotificationTemplateUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: NotificationTemplateCreateManyCreatorInputEnvelope
    set?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    disconnect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    delete?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    connect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    update?: NotificationTemplateUpdateWithWhereUniqueWithoutCreatorInput | NotificationTemplateUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: NotificationTemplateUpdateManyWithWhereWithoutCreatorInput | NotificationTemplateUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: NotificationTemplateScalarWhereInput | NotificationTemplateScalarWhereInput[]
  }

  export type NotificationRuleUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<NotificationRuleCreateWithoutCreatorInput, NotificationRuleUncheckedCreateWithoutCreatorInput> | NotificationRuleCreateWithoutCreatorInput[] | NotificationRuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutCreatorInput | NotificationRuleCreateOrConnectWithoutCreatorInput[]
    upsert?: NotificationRuleUpsertWithWhereUniqueWithoutCreatorInput | NotificationRuleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: NotificationRuleCreateManyCreatorInputEnvelope
    set?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    disconnect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    delete?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    update?: NotificationRuleUpdateWithWhereUniqueWithoutCreatorInput | NotificationRuleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: NotificationRuleUpdateManyWithWhereWithoutCreatorInput | NotificationRuleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: NotificationRuleScalarWhereInput | NotificationRuleScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MagicTokenUpdateManyWithoutUserNestedInput = {
    create?: XOR<MagicTokenCreateWithoutUserInput, MagicTokenUncheckedCreateWithoutUserInput> | MagicTokenCreateWithoutUserInput[] | MagicTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MagicTokenCreateOrConnectWithoutUserInput | MagicTokenCreateOrConnectWithoutUserInput[]
    upsert?: MagicTokenUpsertWithWhereUniqueWithoutUserInput | MagicTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MagicTokenCreateManyUserInputEnvelope
    set?: MagicTokenWhereUniqueInput | MagicTokenWhereUniqueInput[]
    disconnect?: MagicTokenWhereUniqueInput | MagicTokenWhereUniqueInput[]
    delete?: MagicTokenWhereUniqueInput | MagicTokenWhereUniqueInput[]
    connect?: MagicTokenWhereUniqueInput | MagicTokenWhereUniqueInput[]
    update?: MagicTokenUpdateWithWhereUniqueWithoutUserInput | MagicTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MagicTokenUpdateManyWithWhereWithoutUserInput | MagicTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MagicTokenScalarWhereInput | MagicTokenScalarWhereInput[]
  }

  export type PayrollUpdateManyWithoutApproverNestedInput = {
    create?: XOR<PayrollCreateWithoutApproverInput, PayrollUncheckedCreateWithoutApproverInput> | PayrollCreateWithoutApproverInput[] | PayrollUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutApproverInput | PayrollCreateOrConnectWithoutApproverInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutApproverInput | PayrollUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: PayrollCreateManyApproverInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutApproverInput | PayrollUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutApproverInput | PayrollUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PayrollUpdateManyWithoutProcessorNestedInput = {
    create?: XOR<PayrollCreateWithoutProcessorInput, PayrollUncheckedCreateWithoutProcessorInput> | PayrollCreateWithoutProcessorInput[] | PayrollUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutProcessorInput | PayrollCreateOrConnectWithoutProcessorInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutProcessorInput | PayrollUpsertWithWhereUniqueWithoutProcessorInput[]
    createMany?: PayrollCreateManyProcessorInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutProcessorInput | PayrollUpdateWithWhereUniqueWithoutProcessorInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutProcessorInput | PayrollUpdateManyWithWhereWithoutProcessorInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PayrollEntryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutEmployeeInput | PayrollEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryAdjustmentCreateWithoutEmployeeInput, SalaryAdjustmentUncheckedCreateWithoutEmployeeInput> | SalaryAdjustmentCreateWithoutEmployeeInput[] | SalaryAdjustmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryAdjustmentCreateOrConnectWithoutEmployeeInput | SalaryAdjustmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryAdjustmentUpsertWithWhereUniqueWithoutEmployeeInput | SalaryAdjustmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryAdjustmentCreateManyEmployeeInputEnvelope
    set?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    disconnect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    delete?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    connect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    update?: SalaryAdjustmentUpdateWithWhereUniqueWithoutEmployeeInput | SalaryAdjustmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryAdjustmentUpdateManyWithWhereWithoutEmployeeInput | SalaryAdjustmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryAdjustmentScalarWhereInput | SalaryAdjustmentScalarWhereInput[]
  }

  export type SalaryAdjustmentUpdateManyWithoutApproverNestedInput = {
    create?: XOR<SalaryAdjustmentCreateWithoutApproverInput, SalaryAdjustmentUncheckedCreateWithoutApproverInput> | SalaryAdjustmentCreateWithoutApproverInput[] | SalaryAdjustmentUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: SalaryAdjustmentCreateOrConnectWithoutApproverInput | SalaryAdjustmentCreateOrConnectWithoutApproverInput[]
    upsert?: SalaryAdjustmentUpsertWithWhereUniqueWithoutApproverInput | SalaryAdjustmentUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: SalaryAdjustmentCreateManyApproverInputEnvelope
    set?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    disconnect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    delete?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    connect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    update?: SalaryAdjustmentUpdateWithWhereUniqueWithoutApproverInput | SalaryAdjustmentUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: SalaryAdjustmentUpdateManyWithWhereWithoutApproverInput | SalaryAdjustmentUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: SalaryAdjustmentScalarWhereInput | SalaryAdjustmentScalarWhereInput[]
  }

  export type EmployeeExpenseUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeExpenseCreateWithoutEmployeeInput, EmployeeExpenseUncheckedCreateWithoutEmployeeInput> | EmployeeExpenseCreateWithoutEmployeeInput[] | EmployeeExpenseUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutEmployeeInput | EmployeeExpenseCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeExpenseUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeExpenseUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeExpenseCreateManyEmployeeInputEnvelope
    set?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    disconnect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    delete?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    connect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    update?: EmployeeExpenseUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeExpenseUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeExpenseUpdateManyWithWhereWithoutEmployeeInput | EmployeeExpenseUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeExpenseScalarWhereInput | EmployeeExpenseScalarWhereInput[]
  }

  export type EmployeeExpenseUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<EmployeeExpenseCreateWithoutReviewerInput, EmployeeExpenseUncheckedCreateWithoutReviewerInput> | EmployeeExpenseCreateWithoutReviewerInput[] | EmployeeExpenseUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutReviewerInput | EmployeeExpenseCreateOrConnectWithoutReviewerInput[]
    upsert?: EmployeeExpenseUpsertWithWhereUniqueWithoutReviewerInput | EmployeeExpenseUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: EmployeeExpenseCreateManyReviewerInputEnvelope
    set?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    disconnect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    delete?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    connect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    update?: EmployeeExpenseUpdateWithWhereUniqueWithoutReviewerInput | EmployeeExpenseUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: EmployeeExpenseUpdateManyWithWhereWithoutReviewerInput | EmployeeExpenseUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: EmployeeExpenseScalarWhereInput | EmployeeExpenseScalarWhereInput[]
  }

  export type PTORequestUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PTORequestCreateWithoutEmployeeInput, PTORequestUncheckedCreateWithoutEmployeeInput> | PTORequestCreateWithoutEmployeeInput[] | PTORequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PTORequestCreateOrConnectWithoutEmployeeInput | PTORequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: PTORequestUpsertWithWhereUniqueWithoutEmployeeInput | PTORequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PTORequestCreateManyEmployeeInputEnvelope
    set?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    disconnect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    delete?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    connect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    update?: PTORequestUpdateWithWhereUniqueWithoutEmployeeInput | PTORequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PTORequestUpdateManyWithWhereWithoutEmployeeInput | PTORequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PTORequestScalarWhereInput | PTORequestScalarWhereInput[]
  }

  export type PTORequestUpdateManyWithoutApproverNestedInput = {
    create?: XOR<PTORequestCreateWithoutApproverInput, PTORequestUncheckedCreateWithoutApproverInput> | PTORequestCreateWithoutApproverInput[] | PTORequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PTORequestCreateOrConnectWithoutApproverInput | PTORequestCreateOrConnectWithoutApproverInput[]
    upsert?: PTORequestUpsertWithWhereUniqueWithoutApproverInput | PTORequestUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: PTORequestCreateManyApproverInputEnvelope
    set?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    disconnect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    delete?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    connect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    update?: PTORequestUpdateWithWhereUniqueWithoutApproverInput | PTORequestUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: PTORequestUpdateManyWithWhereWithoutApproverInput | PTORequestUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: PTORequestScalarWhereInput | PTORequestScalarWhereInput[]
  }

  export type PTOBalanceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PTOBalanceCreateWithoutEmployeeInput, PTOBalanceUncheckedCreateWithoutEmployeeInput> | PTOBalanceCreateWithoutEmployeeInput[] | PTOBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PTOBalanceCreateOrConnectWithoutEmployeeInput | PTOBalanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: PTOBalanceUpsertWithWhereUniqueWithoutEmployeeInput | PTOBalanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PTOBalanceCreateManyEmployeeInputEnvelope
    set?: PTOBalanceWhereUniqueInput | PTOBalanceWhereUniqueInput[]
    disconnect?: PTOBalanceWhereUniqueInput | PTOBalanceWhereUniqueInput[]
    delete?: PTOBalanceWhereUniqueInput | PTOBalanceWhereUniqueInput[]
    connect?: PTOBalanceWhereUniqueInput | PTOBalanceWhereUniqueInput[]
    update?: PTOBalanceUpdateWithWhereUniqueWithoutEmployeeInput | PTOBalanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PTOBalanceUpdateManyWithWhereWithoutEmployeeInput | PTOBalanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PTOBalanceScalarWhereInput | PTOBalanceScalarWhereInput[]
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput> | TaskCreateWithoutAssigneeInput[] | TaskUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: TaskCreateOrConnectWithoutAssigneeInput | TaskCreateOrConnectWithoutAssigneeInput[]
    upsert?: TaskUpsertWithWhereUniqueWithoutAssigneeInput | TaskUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: TaskCreateManyAssigneeInputEnvelope
    set?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    disconnect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    delete?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    connect?: TaskWhereUniqueInput | TaskWhereUniqueInput[]
    update?: TaskUpdateWithWhereUniqueWithoutAssigneeInput | TaskUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: TaskUpdateManyWithWhereWithoutAssigneeInput | TaskUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: TaskScalarWhereInput | TaskScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<DocumentCreateWithoutAuthorInput, DocumentUncheckedCreateWithoutAuthorInput> | DocumentCreateWithoutAuthorInput[] | DocumentUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutAuthorInput | DocumentCreateOrConnectWithoutAuthorInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutAuthorInput | DocumentUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: DocumentCreateManyAuthorInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutAuthorInput | DocumentUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutAuthorInput | DocumentUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<DocumentRevisionCreateWithoutAuthorInput, DocumentRevisionUncheckedCreateWithoutAuthorInput> | DocumentRevisionCreateWithoutAuthorInput[] | DocumentRevisionUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: DocumentRevisionCreateOrConnectWithoutAuthorInput | DocumentRevisionCreateOrConnectWithoutAuthorInput[]
    upsert?: DocumentRevisionUpsertWithWhereUniqueWithoutAuthorInput | DocumentRevisionUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: DocumentRevisionCreateManyAuthorInputEnvelope
    set?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    disconnect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    delete?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    connect?: DocumentRevisionWhereUniqueInput | DocumentRevisionWhereUniqueInput[]
    update?: DocumentRevisionUpdateWithWhereUniqueWithoutAuthorInput | DocumentRevisionUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: DocumentRevisionUpdateManyWithWhereWithoutAuthorInput | DocumentRevisionUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: DocumentRevisionScalarWhereInput | DocumentRevisionScalarWhereInput[]
  }

  export type SaleUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<SaleCreateWithoutSellerInput, SaleUncheckedCreateWithoutSellerInput> | SaleCreateWithoutSellerInput[] | SaleUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: SaleCreateOrConnectWithoutSellerInput | SaleCreateOrConnectWithoutSellerInput[]
    upsert?: SaleUpsertWithWhereUniqueWithoutSellerInput | SaleUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: SaleCreateManySellerInputEnvelope
    set?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    disconnect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    delete?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    connect?: SaleWhereUniqueInput | SaleWhereUniqueInput[]
    update?: SaleUpdateWithWhereUniqueWithoutSellerInput | SaleUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: SaleUpdateManyWithWhereWithoutSellerInput | SaleUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: SaleScalarWhereInput | SaleScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreatorInput | TransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreatorInput | TransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreatorInput | TransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type AuditTrailUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput> | AuditTrailCreateWithoutUserInput[] | AuditTrailUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditTrailCreateOrConnectWithoutUserInput | AuditTrailCreateOrConnectWithoutUserInput[]
    upsert?: AuditTrailUpsertWithWhereUniqueWithoutUserInput | AuditTrailUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditTrailCreateManyUserInputEnvelope
    set?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    disconnect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    delete?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    connect?: AuditTrailWhereUniqueInput | AuditTrailWhereUniqueInput[]
    update?: AuditTrailUpdateWithWhereUniqueWithoutUserInput | AuditTrailUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditTrailUpdateManyWithWhereWithoutUserInput | AuditTrailUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
  }

  export type NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<NotificationTemplateCreateWithoutCreatorInput, NotificationTemplateUncheckedCreateWithoutCreatorInput> | NotificationTemplateCreateWithoutCreatorInput[] | NotificationTemplateUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutCreatorInput | NotificationTemplateCreateOrConnectWithoutCreatorInput[]
    upsert?: NotificationTemplateUpsertWithWhereUniqueWithoutCreatorInput | NotificationTemplateUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: NotificationTemplateCreateManyCreatorInputEnvelope
    set?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    disconnect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    delete?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    connect?: NotificationTemplateWhereUniqueInput | NotificationTemplateWhereUniqueInput[]
    update?: NotificationTemplateUpdateWithWhereUniqueWithoutCreatorInput | NotificationTemplateUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: NotificationTemplateUpdateManyWithWhereWithoutCreatorInput | NotificationTemplateUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: NotificationTemplateScalarWhereInput | NotificationTemplateScalarWhereInput[]
  }

  export type NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<NotificationRuleCreateWithoutCreatorInput, NotificationRuleUncheckedCreateWithoutCreatorInput> | NotificationRuleCreateWithoutCreatorInput[] | NotificationRuleUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutCreatorInput | NotificationRuleCreateOrConnectWithoutCreatorInput[]
    upsert?: NotificationRuleUpsertWithWhereUniqueWithoutCreatorInput | NotificationRuleUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: NotificationRuleCreateManyCreatorInputEnvelope
    set?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    disconnect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    delete?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    update?: NotificationRuleUpdateWithWhereUniqueWithoutCreatorInput | NotificationRuleUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: NotificationRuleUpdateManyWithWhereWithoutCreatorInput | NotificationRuleUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: NotificationRuleScalarWhereInput | NotificationRuleScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput> | NotificationCreateWithoutRecipientInput[] | NotificationUncheckedCreateWithoutRecipientInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientInput | NotificationCreateOrConnectWithoutRecipientInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRecipientInput | NotificationUpsertWithWhereUniqueWithoutRecipientInput[]
    createMany?: NotificationCreateManyRecipientInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRecipientInput | NotificationUpdateWithWhereUniqueWithoutRecipientInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRecipientInput | NotificationUpdateManyWithWhereWithoutRecipientInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MagicTokenUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MagicTokenCreateWithoutUserInput, MagicTokenUncheckedCreateWithoutUserInput> | MagicTokenCreateWithoutUserInput[] | MagicTokenUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MagicTokenCreateOrConnectWithoutUserInput | MagicTokenCreateOrConnectWithoutUserInput[]
    upsert?: MagicTokenUpsertWithWhereUniqueWithoutUserInput | MagicTokenUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MagicTokenCreateManyUserInputEnvelope
    set?: MagicTokenWhereUniqueInput | MagicTokenWhereUniqueInput[]
    disconnect?: MagicTokenWhereUniqueInput | MagicTokenWhereUniqueInput[]
    delete?: MagicTokenWhereUniqueInput | MagicTokenWhereUniqueInput[]
    connect?: MagicTokenWhereUniqueInput | MagicTokenWhereUniqueInput[]
    update?: MagicTokenUpdateWithWhereUniqueWithoutUserInput | MagicTokenUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MagicTokenUpdateManyWithWhereWithoutUserInput | MagicTokenUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MagicTokenScalarWhereInput | MagicTokenScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<PayrollCreateWithoutApproverInput, PayrollUncheckedCreateWithoutApproverInput> | PayrollCreateWithoutApproverInput[] | PayrollUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutApproverInput | PayrollCreateOrConnectWithoutApproverInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutApproverInput | PayrollUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: PayrollCreateManyApproverInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutApproverInput | PayrollUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutApproverInput | PayrollUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PayrollUncheckedUpdateManyWithoutProcessorNestedInput = {
    create?: XOR<PayrollCreateWithoutProcessorInput, PayrollUncheckedCreateWithoutProcessorInput> | PayrollCreateWithoutProcessorInput[] | PayrollUncheckedCreateWithoutProcessorInput[]
    connectOrCreate?: PayrollCreateOrConnectWithoutProcessorInput | PayrollCreateOrConnectWithoutProcessorInput[]
    upsert?: PayrollUpsertWithWhereUniqueWithoutProcessorInput | PayrollUpsertWithWhereUniqueWithoutProcessorInput[]
    createMany?: PayrollCreateManyProcessorInputEnvelope
    set?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    disconnect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    delete?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    connect?: PayrollWhereUniqueInput | PayrollWhereUniqueInput[]
    update?: PayrollUpdateWithWhereUniqueWithoutProcessorInput | PayrollUpdateWithWhereUniqueWithoutProcessorInput[]
    updateMany?: PayrollUpdateManyWithWhereWithoutProcessorInput | PayrollUpdateManyWithWhereWithoutProcessorInput[]
    deleteMany?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
  }

  export type PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput> | PayrollEntryCreateWithoutEmployeeInput[] | PayrollEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutEmployeeInput | PayrollEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollEntryCreateManyEmployeeInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput | PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutEmployeeInput | PayrollEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<SalaryAdjustmentCreateWithoutEmployeeInput, SalaryAdjustmentUncheckedCreateWithoutEmployeeInput> | SalaryAdjustmentCreateWithoutEmployeeInput[] | SalaryAdjustmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: SalaryAdjustmentCreateOrConnectWithoutEmployeeInput | SalaryAdjustmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: SalaryAdjustmentUpsertWithWhereUniqueWithoutEmployeeInput | SalaryAdjustmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: SalaryAdjustmentCreateManyEmployeeInputEnvelope
    set?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    disconnect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    delete?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    connect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    update?: SalaryAdjustmentUpdateWithWhereUniqueWithoutEmployeeInput | SalaryAdjustmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: SalaryAdjustmentUpdateManyWithWhereWithoutEmployeeInput | SalaryAdjustmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: SalaryAdjustmentScalarWhereInput | SalaryAdjustmentScalarWhereInput[]
  }

  export type SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<SalaryAdjustmentCreateWithoutApproverInput, SalaryAdjustmentUncheckedCreateWithoutApproverInput> | SalaryAdjustmentCreateWithoutApproverInput[] | SalaryAdjustmentUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: SalaryAdjustmentCreateOrConnectWithoutApproverInput | SalaryAdjustmentCreateOrConnectWithoutApproverInput[]
    upsert?: SalaryAdjustmentUpsertWithWhereUniqueWithoutApproverInput | SalaryAdjustmentUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: SalaryAdjustmentCreateManyApproverInputEnvelope
    set?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    disconnect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    delete?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    connect?: SalaryAdjustmentWhereUniqueInput | SalaryAdjustmentWhereUniqueInput[]
    update?: SalaryAdjustmentUpdateWithWhereUniqueWithoutApproverInput | SalaryAdjustmentUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: SalaryAdjustmentUpdateManyWithWhereWithoutApproverInput | SalaryAdjustmentUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: SalaryAdjustmentScalarWhereInput | SalaryAdjustmentScalarWhereInput[]
  }

  export type EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeExpenseCreateWithoutEmployeeInput, EmployeeExpenseUncheckedCreateWithoutEmployeeInput> | EmployeeExpenseCreateWithoutEmployeeInput[] | EmployeeExpenseUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutEmployeeInput | EmployeeExpenseCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeExpenseUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeExpenseUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeExpenseCreateManyEmployeeInputEnvelope
    set?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    disconnect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    delete?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    connect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    update?: EmployeeExpenseUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeExpenseUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeExpenseUpdateManyWithWhereWithoutEmployeeInput | EmployeeExpenseUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeExpenseScalarWhereInput | EmployeeExpenseScalarWhereInput[]
  }

  export type EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput = {
    create?: XOR<EmployeeExpenseCreateWithoutReviewerInput, EmployeeExpenseUncheckedCreateWithoutReviewerInput> | EmployeeExpenseCreateWithoutReviewerInput[] | EmployeeExpenseUncheckedCreateWithoutReviewerInput[]
    connectOrCreate?: EmployeeExpenseCreateOrConnectWithoutReviewerInput | EmployeeExpenseCreateOrConnectWithoutReviewerInput[]
    upsert?: EmployeeExpenseUpsertWithWhereUniqueWithoutReviewerInput | EmployeeExpenseUpsertWithWhereUniqueWithoutReviewerInput[]
    createMany?: EmployeeExpenseCreateManyReviewerInputEnvelope
    set?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    disconnect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    delete?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    connect?: EmployeeExpenseWhereUniqueInput | EmployeeExpenseWhereUniqueInput[]
    update?: EmployeeExpenseUpdateWithWhereUniqueWithoutReviewerInput | EmployeeExpenseUpdateWithWhereUniqueWithoutReviewerInput[]
    updateMany?: EmployeeExpenseUpdateManyWithWhereWithoutReviewerInput | EmployeeExpenseUpdateManyWithWhereWithoutReviewerInput[]
    deleteMany?: EmployeeExpenseScalarWhereInput | EmployeeExpenseScalarWhereInput[]
  }

  export type PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PTORequestCreateWithoutEmployeeInput, PTORequestUncheckedCreateWithoutEmployeeInput> | PTORequestCreateWithoutEmployeeInput[] | PTORequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PTORequestCreateOrConnectWithoutEmployeeInput | PTORequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: PTORequestUpsertWithWhereUniqueWithoutEmployeeInput | PTORequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PTORequestCreateManyEmployeeInputEnvelope
    set?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    disconnect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    delete?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    connect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    update?: PTORequestUpdateWithWhereUniqueWithoutEmployeeInput | PTORequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PTORequestUpdateManyWithWhereWithoutEmployeeInput | PTORequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PTORequestScalarWhereInput | PTORequestScalarWhereInput[]
  }

  export type PTORequestUncheckedUpdateManyWithoutApproverNestedInput = {
    create?: XOR<PTORequestCreateWithoutApproverInput, PTORequestUncheckedCreateWithoutApproverInput> | PTORequestCreateWithoutApproverInput[] | PTORequestUncheckedCreateWithoutApproverInput[]
    connectOrCreate?: PTORequestCreateOrConnectWithoutApproverInput | PTORequestCreateOrConnectWithoutApproverInput[]
    upsert?: PTORequestUpsertWithWhereUniqueWithoutApproverInput | PTORequestUpsertWithWhereUniqueWithoutApproverInput[]
    createMany?: PTORequestCreateManyApproverInputEnvelope
    set?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    disconnect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    delete?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    connect?: PTORequestWhereUniqueInput | PTORequestWhereUniqueInput[]
    update?: PTORequestUpdateWithWhereUniqueWithoutApproverInput | PTORequestUpdateWithWhereUniqueWithoutApproverInput[]
    updateMany?: PTORequestUpdateManyWithWhereWithoutApproverInput | PTORequestUpdateManyWithWhereWithoutApproverInput[]
    deleteMany?: PTORequestScalarWhereInput | PTORequestScalarWhereInput[]
  }

  export type PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PTOBalanceCreateWithoutEmployeeInput, PTOBalanceUncheckedCreateWithoutEmployeeInput> | PTOBalanceCreateWithoutEmployeeInput[] | PTOBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PTOBalanceCreateOrConnectWithoutEmployeeInput | PTOBalanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: PTOBalanceUpsertWithWhereUniqueWithoutEmployeeInput | PTOBalanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PTOBalanceCreateManyEmployeeInputEnvelope
    set?: PTOBalanceWhereUniqueInput | PTOBalanceWhereUniqueInput[]
    disconnect?: PTOBalanceWhereUniqueInput | PTOBalanceWhereUniqueInput[]
    delete?: PTOBalanceWhereUniqueInput | PTOBalanceWhereUniqueInput[]
    connect?: PTOBalanceWhereUniqueInput | PTOBalanceWhereUniqueInput[]
    update?: PTOBalanceUpdateWithWhereUniqueWithoutEmployeeInput | PTOBalanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PTOBalanceUpdateManyWithWhereWithoutEmployeeInput | PTOBalanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PTOBalanceScalarWhereInput | PTOBalanceScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMagicTokensInput = {
    create?: XOR<UserCreateWithoutMagicTokensInput, UserUncheckedCreateWithoutMagicTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutMagicTokensInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMagicTokensNestedInput = {
    create?: XOR<UserCreateWithoutMagicTokensInput, UserUncheckedCreateWithoutMagicTokensInput>
    connectOrCreate?: UserCreateOrConnectWithoutMagicTokensInput
    upsert?: UserUpsertWithoutMagicTokensInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMagicTokensInput, UserUpdateWithoutMagicTokensInput>, UserUncheckedUpdateWithoutMagicTokensInput>
  }

  export type UserCreateNestedOneWithoutAuditTrailsInput = {
    create?: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditTrailsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumAuditOperationFieldUpdateOperationsInput = {
    set?: $Enums.AuditOperation
  }

  export type UserUpdateOneWithoutAuditTrailsNestedInput = {
    create?: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditTrailsInput
    upsert?: UserUpsertWithoutAuditTrailsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditTrailsInput, UserUpdateWithoutAuditTrailsInput>, UserUncheckedUpdateWithoutAuditTrailsInput>
  }

  export type NotificationTemplateCreatevariablesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutNotificationTemplatesCreatedInput = {
    create?: XOR<UserCreateWithoutNotificationTemplatesCreatedInput, UserUncheckedCreateWithoutNotificationTemplatesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationTemplatesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationRuleCreateNestedManyWithoutTemplateInput = {
    create?: XOR<NotificationRuleCreateWithoutTemplateInput, NotificationRuleUncheckedCreateWithoutTemplateInput> | NotificationRuleCreateWithoutTemplateInput[] | NotificationRuleUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutTemplateInput | NotificationRuleCreateOrConnectWithoutTemplateInput[]
    createMany?: NotificationRuleCreateManyTemplateInputEnvelope
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutTemplateInput = {
    create?: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput> | NotificationCreateWithoutTemplateInput[] | NotificationUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTemplateInput | NotificationCreateOrConnectWithoutTemplateInput[]
    createMany?: NotificationCreateManyTemplateInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationRuleUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<NotificationRuleCreateWithoutTemplateInput, NotificationRuleUncheckedCreateWithoutTemplateInput> | NotificationRuleCreateWithoutTemplateInput[] | NotificationRuleUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutTemplateInput | NotificationRuleCreateOrConnectWithoutTemplateInput[]
    createMany?: NotificationRuleCreateManyTemplateInputEnvelope
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput> | NotificationCreateWithoutTemplateInput[] | NotificationUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTemplateInput | NotificationCreateOrConnectWithoutTemplateInput[]
    createMany?: NotificationCreateManyTemplateInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type NotificationTemplateUpdatevariablesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type UserUpdateOneRequiredWithoutNotificationTemplatesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutNotificationTemplatesCreatedInput, UserUncheckedCreateWithoutNotificationTemplatesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationTemplatesCreatedInput
    upsert?: UserUpsertWithoutNotificationTemplatesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationTemplatesCreatedInput, UserUpdateWithoutNotificationTemplatesCreatedInput>, UserUncheckedUpdateWithoutNotificationTemplatesCreatedInput>
  }

  export type NotificationRuleUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<NotificationRuleCreateWithoutTemplateInput, NotificationRuleUncheckedCreateWithoutTemplateInput> | NotificationRuleCreateWithoutTemplateInput[] | NotificationRuleUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutTemplateInput | NotificationRuleCreateOrConnectWithoutTemplateInput[]
    upsert?: NotificationRuleUpsertWithWhereUniqueWithoutTemplateInput | NotificationRuleUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: NotificationRuleCreateManyTemplateInputEnvelope
    set?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    disconnect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    delete?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    update?: NotificationRuleUpdateWithWhereUniqueWithoutTemplateInput | NotificationRuleUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: NotificationRuleUpdateManyWithWhereWithoutTemplateInput | NotificationRuleUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: NotificationRuleScalarWhereInput | NotificationRuleScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput> | NotificationCreateWithoutTemplateInput[] | NotificationUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTemplateInput | NotificationCreateOrConnectWithoutTemplateInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTemplateInput | NotificationUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: NotificationCreateManyTemplateInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTemplateInput | NotificationUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTemplateInput | NotificationUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationRuleUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<NotificationRuleCreateWithoutTemplateInput, NotificationRuleUncheckedCreateWithoutTemplateInput> | NotificationRuleCreateWithoutTemplateInput[] | NotificationRuleUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutTemplateInput | NotificationRuleCreateOrConnectWithoutTemplateInput[]
    upsert?: NotificationRuleUpsertWithWhereUniqueWithoutTemplateInput | NotificationRuleUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: NotificationRuleCreateManyTemplateInputEnvelope
    set?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    disconnect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    delete?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    connect?: NotificationRuleWhereUniqueInput | NotificationRuleWhereUniqueInput[]
    update?: NotificationRuleUpdateWithWhereUniqueWithoutTemplateInput | NotificationRuleUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: NotificationRuleUpdateManyWithWhereWithoutTemplateInput | NotificationRuleUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: NotificationRuleScalarWhereInput | NotificationRuleScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput> | NotificationCreateWithoutTemplateInput[] | NotificationUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutTemplateInput | NotificationCreateOrConnectWithoutTemplateInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutTemplateInput | NotificationUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: NotificationCreateManyTemplateInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutTemplateInput | NotificationUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutTemplateInput | NotificationUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationTemplateCreateNestedOneWithoutRulesInput = {
    create?: XOR<NotificationTemplateCreateWithoutRulesInput, NotificationTemplateUncheckedCreateWithoutRulesInput>
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutRulesInput
    connect?: NotificationTemplateWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutNotificationRulesCreatedInput = {
    create?: XOR<UserCreateWithoutNotificationRulesCreatedInput, UserUncheckedCreateWithoutNotificationRulesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationRulesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationCreateNestedManyWithoutRuleInput = {
    create?: XOR<NotificationCreateWithoutRuleInput, NotificationUncheckedCreateWithoutRuleInput> | NotificationCreateWithoutRuleInput[] | NotificationUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRuleInput | NotificationCreateOrConnectWithoutRuleInput[]
    createMany?: NotificationCreateManyRuleInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutRuleInput = {
    create?: XOR<NotificationCreateWithoutRuleInput, NotificationUncheckedCreateWithoutRuleInput> | NotificationCreateWithoutRuleInput[] | NotificationUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRuleInput | NotificationCreateOrConnectWithoutRuleInput[]
    createMany?: NotificationCreateManyRuleInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type EnumRuleTriggerFieldUpdateOperationsInput = {
    set?: $Enums.RuleTrigger
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NotificationTemplateUpdateOneRequiredWithoutRulesNestedInput = {
    create?: XOR<NotificationTemplateCreateWithoutRulesInput, NotificationTemplateUncheckedCreateWithoutRulesInput>
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutRulesInput
    upsert?: NotificationTemplateUpsertWithoutRulesInput
    connect?: NotificationTemplateWhereUniqueInput
    update?: XOR<XOR<NotificationTemplateUpdateToOneWithWhereWithoutRulesInput, NotificationTemplateUpdateWithoutRulesInput>, NotificationTemplateUncheckedUpdateWithoutRulesInput>
  }

  export type UserUpdateOneRequiredWithoutNotificationRulesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutNotificationRulesCreatedInput, UserUncheckedCreateWithoutNotificationRulesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationRulesCreatedInput
    upsert?: UserUpsertWithoutNotificationRulesCreatedInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationRulesCreatedInput, UserUpdateWithoutNotificationRulesCreatedInput>, UserUncheckedUpdateWithoutNotificationRulesCreatedInput>
  }

  export type NotificationUpdateManyWithoutRuleNestedInput = {
    create?: XOR<NotificationCreateWithoutRuleInput, NotificationUncheckedCreateWithoutRuleInput> | NotificationCreateWithoutRuleInput[] | NotificationUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRuleInput | NotificationCreateOrConnectWithoutRuleInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRuleInput | NotificationUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: NotificationCreateManyRuleInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRuleInput | NotificationUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRuleInput | NotificationUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutRuleNestedInput = {
    create?: XOR<NotificationCreateWithoutRuleInput, NotificationUncheckedCreateWithoutRuleInput> | NotificationCreateWithoutRuleInput[] | NotificationUncheckedCreateWithoutRuleInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutRuleInput | NotificationCreateOrConnectWithoutRuleInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutRuleInput | NotificationUpsertWithWhereUniqueWithoutRuleInput[]
    createMany?: NotificationCreateManyRuleInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutRuleInput | NotificationUpdateWithWhereUniqueWithoutRuleInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutRuleInput | NotificationUpdateManyWithWhereWithoutRuleInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type NotificationTemplateCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<NotificationTemplateCreateWithoutNotificationsInput, NotificationTemplateUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutNotificationsInput
    connect?: NotificationTemplateWhereUniqueInput
  }

  export type NotificationRuleCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<NotificationRuleCreateWithoutNotificationsInput, NotificationRuleUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutNotificationsInput
    connect?: NotificationRuleWhereUniqueInput
  }

  export type EnumNotificationStatusFieldUpdateOperationsInput = {
    set?: $Enums.NotificationStatus
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationTemplateUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<NotificationTemplateCreateWithoutNotificationsInput, NotificationTemplateUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: NotificationTemplateCreateOrConnectWithoutNotificationsInput
    upsert?: NotificationTemplateUpsertWithoutNotificationsInput
    disconnect?: NotificationTemplateWhereInput | boolean
    delete?: NotificationTemplateWhereInput | boolean
    connect?: NotificationTemplateWhereUniqueInput
    update?: XOR<XOR<NotificationTemplateUpdateToOneWithWhereWithoutNotificationsInput, NotificationTemplateUpdateWithoutNotificationsInput>, NotificationTemplateUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationRuleUpdateOneWithoutNotificationsNestedInput = {
    create?: XOR<NotificationRuleCreateWithoutNotificationsInput, NotificationRuleUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: NotificationRuleCreateOrConnectWithoutNotificationsInput
    upsert?: NotificationRuleUpsertWithoutNotificationsInput
    disconnect?: NotificationRuleWhereInput | boolean
    delete?: NotificationRuleWhereInput | boolean
    connect?: NotificationRuleWhereUniqueInput
    update?: XOR<XOR<NotificationRuleUpdateToOneWithWhereWithoutNotificationsInput, NotificationRuleUpdateWithoutNotificationsInput>, NotificationRuleUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutPayrollsApprovedInput = {
    create?: XOR<UserCreateWithoutPayrollsApprovedInput, UserUncheckedCreateWithoutPayrollsApprovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollsApprovedInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPayrollsProcessedInput = {
    create?: XOR<UserCreateWithoutPayrollsProcessedInput, UserUncheckedCreateWithoutPayrollsProcessedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollsProcessedInput
    connect?: UserWhereUniqueInput
  }

  export type PayrollEntryCreateNestedManyWithoutPayrollInput = {
    create?: XOR<PayrollEntryCreateWithoutPayrollInput, PayrollEntryUncheckedCreateWithoutPayrollInput> | PayrollEntryCreateWithoutPayrollInput[] | PayrollEntryUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPayrollInput | PayrollEntryCreateOrConnectWithoutPayrollInput[]
    createMany?: PayrollEntryCreateManyPayrollInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutPayrollInput = {
    create?: XOR<TransactionCreateWithoutPayrollInput, TransactionUncheckedCreateWithoutPayrollInput> | TransactionCreateWithoutPayrollInput[] | TransactionUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPayrollInput | TransactionCreateOrConnectWithoutPayrollInput[]
    createMany?: TransactionCreateManyPayrollInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type PayrollEntryUncheckedCreateNestedManyWithoutPayrollInput = {
    create?: XOR<PayrollEntryCreateWithoutPayrollInput, PayrollEntryUncheckedCreateWithoutPayrollInput> | PayrollEntryCreateWithoutPayrollInput[] | PayrollEntryUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPayrollInput | PayrollEntryCreateOrConnectWithoutPayrollInput[]
    createMany?: PayrollEntryCreateManyPayrollInputEnvelope
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutPayrollInput = {
    create?: XOR<TransactionCreateWithoutPayrollInput, TransactionUncheckedCreateWithoutPayrollInput> | TransactionCreateWithoutPayrollInput[] | TransactionUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPayrollInput | TransactionCreateOrConnectWithoutPayrollInput[]
    createMany?: TransactionCreateManyPayrollInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type EnumPayrollStatusFieldUpdateOperationsInput = {
    set?: $Enums.PayrollStatus
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneWithoutPayrollsApprovedNestedInput = {
    create?: XOR<UserCreateWithoutPayrollsApprovedInput, UserUncheckedCreateWithoutPayrollsApprovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollsApprovedInput
    upsert?: UserUpsertWithoutPayrollsApprovedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPayrollsApprovedInput, UserUpdateWithoutPayrollsApprovedInput>, UserUncheckedUpdateWithoutPayrollsApprovedInput>
  }

  export type UserUpdateOneWithoutPayrollsProcessedNestedInput = {
    create?: XOR<UserCreateWithoutPayrollsProcessedInput, UserUncheckedCreateWithoutPayrollsProcessedInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollsProcessedInput
    upsert?: UserUpsertWithoutPayrollsProcessedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPayrollsProcessedInput, UserUpdateWithoutPayrollsProcessedInput>, UserUncheckedUpdateWithoutPayrollsProcessedInput>
  }

  export type PayrollEntryUpdateManyWithoutPayrollNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutPayrollInput, PayrollEntryUncheckedCreateWithoutPayrollInput> | PayrollEntryCreateWithoutPayrollInput[] | PayrollEntryUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPayrollInput | PayrollEntryCreateOrConnectWithoutPayrollInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutPayrollInput | PayrollEntryUpsertWithWhereUniqueWithoutPayrollInput[]
    createMany?: PayrollEntryCreateManyPayrollInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutPayrollInput | PayrollEntryUpdateWithWhereUniqueWithoutPayrollInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutPayrollInput | PayrollEntryUpdateManyWithWhereWithoutPayrollInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutPayrollNestedInput = {
    create?: XOR<TransactionCreateWithoutPayrollInput, TransactionUncheckedCreateWithoutPayrollInput> | TransactionCreateWithoutPayrollInput[] | TransactionUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPayrollInput | TransactionCreateOrConnectWithoutPayrollInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPayrollInput | TransactionUpsertWithWhereUniqueWithoutPayrollInput[]
    createMany?: TransactionCreateManyPayrollInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPayrollInput | TransactionUpdateWithWhereUniqueWithoutPayrollInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPayrollInput | TransactionUpdateManyWithWhereWithoutPayrollInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PayrollEntryUncheckedUpdateManyWithoutPayrollNestedInput = {
    create?: XOR<PayrollEntryCreateWithoutPayrollInput, PayrollEntryUncheckedCreateWithoutPayrollInput> | PayrollEntryCreateWithoutPayrollInput[] | PayrollEntryUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollEntryCreateOrConnectWithoutPayrollInput | PayrollEntryCreateOrConnectWithoutPayrollInput[]
    upsert?: PayrollEntryUpsertWithWhereUniqueWithoutPayrollInput | PayrollEntryUpsertWithWhereUniqueWithoutPayrollInput[]
    createMany?: PayrollEntryCreateManyPayrollInputEnvelope
    set?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    disconnect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    delete?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    connect?: PayrollEntryWhereUniqueInput | PayrollEntryWhereUniqueInput[]
    update?: PayrollEntryUpdateWithWhereUniqueWithoutPayrollInput | PayrollEntryUpdateWithWhereUniqueWithoutPayrollInput[]
    updateMany?: PayrollEntryUpdateManyWithWhereWithoutPayrollInput | PayrollEntryUpdateManyWithWhereWithoutPayrollInput[]
    deleteMany?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutPayrollNestedInput = {
    create?: XOR<TransactionCreateWithoutPayrollInput, TransactionUncheckedCreateWithoutPayrollInput> | TransactionCreateWithoutPayrollInput[] | TransactionUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutPayrollInput | TransactionCreateOrConnectWithoutPayrollInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutPayrollInput | TransactionUpsertWithWhereUniqueWithoutPayrollInput[]
    createMany?: TransactionCreateManyPayrollInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutPayrollInput | TransactionUpdateWithWhereUniqueWithoutPayrollInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutPayrollInput | TransactionUpdateManyWithWhereWithoutPayrollInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type PayrollCreateNestedOneWithoutPayrollEntriesInput = {
    create?: XOR<PayrollCreateWithoutPayrollEntriesInput, PayrollUncheckedCreateWithoutPayrollEntriesInput>
    connectOrCreate?: PayrollCreateOrConnectWithoutPayrollEntriesInput
    connect?: PayrollWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPayrollEntriesInput = {
    create?: XOR<UserCreateWithoutPayrollEntriesInput, UserUncheckedCreateWithoutPayrollEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type PayrollUpdateOneRequiredWithoutPayrollEntriesNestedInput = {
    create?: XOR<PayrollCreateWithoutPayrollEntriesInput, PayrollUncheckedCreateWithoutPayrollEntriesInput>
    connectOrCreate?: PayrollCreateOrConnectWithoutPayrollEntriesInput
    upsert?: PayrollUpsertWithoutPayrollEntriesInput
    connect?: PayrollWhereUniqueInput
    update?: XOR<XOR<PayrollUpdateToOneWithWhereWithoutPayrollEntriesInput, PayrollUpdateWithoutPayrollEntriesInput>, PayrollUncheckedUpdateWithoutPayrollEntriesInput>
  }

  export type UserUpdateOneRequiredWithoutPayrollEntriesNestedInput = {
    create?: XOR<UserCreateWithoutPayrollEntriesInput, UserUncheckedCreateWithoutPayrollEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPayrollEntriesInput
    upsert?: UserUpsertWithoutPayrollEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPayrollEntriesInput, UserUpdateWithoutPayrollEntriesInput>, UserUncheckedUpdateWithoutPayrollEntriesInput>
  }

  export type UserCreateNestedOneWithoutSalaryAdjustmentsInput = {
    create?: XOR<UserCreateWithoutSalaryAdjustmentsInput, UserUncheckedCreateWithoutSalaryAdjustmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryAdjustmentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSalaryAdjustmentsApprovedInput = {
    create?: XOR<UserCreateWithoutSalaryAdjustmentsApprovedInput, UserUncheckedCreateWithoutSalaryAdjustmentsApprovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryAdjustmentsApprovedInput
    connect?: UserWhereUniqueInput
  }

  export type EnumSalaryAdjustmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.SalaryAdjustmentType
  }

  export type UserUpdateOneRequiredWithoutSalaryAdjustmentsNestedInput = {
    create?: XOR<UserCreateWithoutSalaryAdjustmentsInput, UserUncheckedCreateWithoutSalaryAdjustmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryAdjustmentsInput
    upsert?: UserUpsertWithoutSalaryAdjustmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalaryAdjustmentsInput, UserUpdateWithoutSalaryAdjustmentsInput>, UserUncheckedUpdateWithoutSalaryAdjustmentsInput>
  }

  export type UserUpdateOneWithoutSalaryAdjustmentsApprovedNestedInput = {
    create?: XOR<UserCreateWithoutSalaryAdjustmentsApprovedInput, UserUncheckedCreateWithoutSalaryAdjustmentsApprovedInput>
    connectOrCreate?: UserCreateOrConnectWithoutSalaryAdjustmentsApprovedInput
    upsert?: UserUpsertWithoutSalaryAdjustmentsApprovedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSalaryAdjustmentsApprovedInput, UserUpdateWithoutSalaryAdjustmentsApprovedInput>, UserUncheckedUpdateWithoutSalaryAdjustmentsApprovedInput>
  }

  export type UserCreateNestedOneWithoutEmployeeExpensesInput = {
    create?: XOR<UserCreateWithoutEmployeeExpensesInput, UserUncheckedCreateWithoutEmployeeExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeExpensesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutExpenseReviewsInput = {
    create?: XOR<UserCreateWithoutExpenseReviewsInput, UserUncheckedCreateWithoutExpenseReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpenseReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type TransactionCreateNestedOneWithoutExpenseReimbursementInput = {
    create?: XOR<TransactionCreateWithoutExpenseReimbursementInput, TransactionUncheckedCreateWithoutExpenseReimbursementInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutExpenseReimbursementInput
    connect?: TransactionWhereUniqueInput
  }

  export type EnumExpenseStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExpenseStatus
  }

  export type UserUpdateOneRequiredWithoutEmployeeExpensesNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeExpensesInput, UserUncheckedCreateWithoutEmployeeExpensesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeExpensesInput
    upsert?: UserUpsertWithoutEmployeeExpensesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeExpensesInput, UserUpdateWithoutEmployeeExpensesInput>, UserUncheckedUpdateWithoutEmployeeExpensesInput>
  }

  export type UserUpdateOneWithoutExpenseReviewsNestedInput = {
    create?: XOR<UserCreateWithoutExpenseReviewsInput, UserUncheckedCreateWithoutExpenseReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutExpenseReviewsInput
    upsert?: UserUpsertWithoutExpenseReviewsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutExpenseReviewsInput, UserUpdateWithoutExpenseReviewsInput>, UserUncheckedUpdateWithoutExpenseReviewsInput>
  }

  export type TransactionUpdateOneWithoutExpenseReimbursementNestedInput = {
    create?: XOR<TransactionCreateWithoutExpenseReimbursementInput, TransactionUncheckedCreateWithoutExpenseReimbursementInput>
    connectOrCreate?: TransactionCreateOrConnectWithoutExpenseReimbursementInput
    upsert?: TransactionUpsertWithoutExpenseReimbursementInput
    disconnect?: TransactionWhereInput | boolean
    delete?: TransactionWhereInput | boolean
    connect?: TransactionWhereUniqueInput
    update?: XOR<XOR<TransactionUpdateToOneWithWhereWithoutExpenseReimbursementInput, TransactionUpdateWithoutExpenseReimbursementInput>, TransactionUncheckedUpdateWithoutExpenseReimbursementInput>
  }

  export type UserCreateNestedOneWithoutPtoRequestsInput = {
    create?: XOR<UserCreateWithoutPtoRequestsInput, UserUncheckedCreateWithoutPtoRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPtoRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPtoApprovalsInput = {
    create?: XOR<UserCreateWithoutPtoApprovalsInput, UserUncheckedCreateWithoutPtoApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPtoApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPTOStatusFieldUpdateOperationsInput = {
    set?: $Enums.PTOStatus
  }

  export type UserUpdateOneRequiredWithoutPtoRequestsNestedInput = {
    create?: XOR<UserCreateWithoutPtoRequestsInput, UserUncheckedCreateWithoutPtoRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPtoRequestsInput
    upsert?: UserUpsertWithoutPtoRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPtoRequestsInput, UserUpdateWithoutPtoRequestsInput>, UserUncheckedUpdateWithoutPtoRequestsInput>
  }

  export type UserUpdateOneWithoutPtoApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutPtoApprovalsInput, UserUncheckedCreateWithoutPtoApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPtoApprovalsInput
    upsert?: UserUpsertWithoutPtoApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPtoApprovalsInput, UserUpdateWithoutPtoApprovalsInput>, UserUncheckedUpdateWithoutPtoApprovalsInput>
  }

  export type UserCreateNestedOneWithoutPtoBalancesInput = {
    create?: XOR<UserCreateWithoutPtoBalancesInput, UserUncheckedCreateWithoutPtoBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPtoBalancesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutPtoBalancesNestedInput = {
    create?: XOR<UserCreateWithoutPtoBalancesInput, UserUncheckedCreateWithoutPtoBalancesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPtoBalancesInput
    upsert?: UserUpsertWithoutPtoBalancesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPtoBalancesInput, UserUpdateWithoutPtoBalancesInput>, UserUncheckedUpdateWithoutPtoBalancesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumDocumentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeFilter<$PrismaModel> | $Enums.DocumentType
  }

  export type NestedEnumDocumentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusFilter<$PrismaModel> | $Enums.DocumentStatus
  }

  export type NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentType | EnumDocumentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentType[] | ListEnumDocumentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentStatus | EnumDocumentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentStatus[] | ListEnumDocumentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentStatusWithAggregatesFilter<$PrismaModel> | $Enums.DocumentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentStatusFilter<$PrismaModel>
    _max?: NestedEnumDocumentStatusFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAuditOperationFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditOperation | EnumAuditOperationFieldRefInput<$PrismaModel>
    in?: $Enums.AuditOperation[] | ListEnumAuditOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditOperation[] | ListEnumAuditOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditOperationFilter<$PrismaModel> | $Enums.AuditOperation
  }

  export type NestedEnumAuditOperationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuditOperation | EnumAuditOperationFieldRefInput<$PrismaModel>
    in?: $Enums.AuditOperation[] | ListEnumAuditOperationFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuditOperation[] | ListEnumAuditOperationFieldRefInput<$PrismaModel>
    not?: NestedEnumAuditOperationWithAggregatesFilter<$PrismaModel> | $Enums.AuditOperation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuditOperationFilter<$PrismaModel>
    _max?: NestedEnumAuditOperationFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumRuleTriggerFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleTrigger | EnumRuleTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.RuleTrigger[] | ListEnumRuleTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleTrigger[] | ListEnumRuleTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleTriggerFilter<$PrismaModel> | $Enums.RuleTrigger
  }

  export type NestedEnumRuleTriggerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RuleTrigger | EnumRuleTriggerFieldRefInput<$PrismaModel>
    in?: $Enums.RuleTrigger[] | ListEnumRuleTriggerFieldRefInput<$PrismaModel>
    notIn?: $Enums.RuleTrigger[] | ListEnumRuleTriggerFieldRefInput<$PrismaModel>
    not?: NestedEnumRuleTriggerWithAggregatesFilter<$PrismaModel> | $Enums.RuleTrigger
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRuleTriggerFilter<$PrismaModel>
    _max?: NestedEnumRuleTriggerFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumNotificationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusFilter<$PrismaModel> | $Enums.NotificationStatus
  }

  export type NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationStatus | EnumNotificationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationStatus[] | ListEnumNotificationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationStatusWithAggregatesFilter<$PrismaModel> | $Enums.NotificationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationStatusFilter<$PrismaModel>
    _max?: NestedEnumNotificationStatusFilter<$PrismaModel>
  }

  export type NestedEnumPayrollStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollStatusFilter<$PrismaModel> | $Enums.PayrollStatus
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumPayrollStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PayrollStatus | EnumPayrollStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PayrollStatus[] | ListEnumPayrollStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPayrollStatusWithAggregatesFilter<$PrismaModel> | $Enums.PayrollStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPayrollStatusFilter<$PrismaModel>
    _max?: NestedEnumPayrollStatusFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumSalaryAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryAdjustmentType | EnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryAdjustmentType[] | ListEnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryAdjustmentType[] | ListEnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryAdjustmentTypeFilter<$PrismaModel> | $Enums.SalaryAdjustmentType
  }

  export type NestedEnumSalaryAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SalaryAdjustmentType | EnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SalaryAdjustmentType[] | ListEnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SalaryAdjustmentType[] | ListEnumSalaryAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSalaryAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.SalaryAdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSalaryAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumSalaryAdjustmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumExpenseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusFilter<$PrismaModel> | $Enums.ExpenseStatus
  }

  export type NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExpenseStatus | EnumExpenseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExpenseStatus[] | ListEnumExpenseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExpenseStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExpenseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExpenseStatusFilter<$PrismaModel>
    _max?: NestedEnumExpenseStatusFilter<$PrismaModel>
  }

  export type NestedEnumPTOStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PTOStatus | EnumPTOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PTOStatus[] | ListEnumPTOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PTOStatus[] | ListEnumPTOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPTOStatusFilter<$PrismaModel> | $Enums.PTOStatus
  }

  export type NestedEnumPTOStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PTOStatus | EnumPTOStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PTOStatus[] | ListEnumPTOStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PTOStatus[] | ListEnumPTOStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPTOStatusWithAggregatesFilter<$PrismaModel> | $Enums.PTOStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPTOStatusFilter<$PrismaModel>
    _max?: NestedEnumPTOStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutRoleInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutRoleInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutRoleInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserCreateManyRoleInputEnvelope = {
    data: UserCreateManyRoleInput | UserCreateManyRoleInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
    create: XOR<UserCreateWithoutRoleInput, UserUncheckedCreateWithoutRoleInput>
  }

  export type UserUpdateWithWhereUniqueWithoutRoleInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutRoleInput, UserUncheckedUpdateWithoutRoleInput>
  }

  export type UserUpdateManyWithWhereWithoutRoleInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutRoleInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    username?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    roleId?: StringFilter<"User"> | string
    tenantId?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    deletedBy?: StringNullableFilter<"User"> | string | null
    createdBy?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type TaskCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee?: UserCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    assigneeId?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutProjectInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskCreateManyProjectInputEnvelope = {
    data: TaskCreateManyProjectInput | TaskCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type TaskUpsertWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
    create: XOR<TaskCreateWithoutProjectInput, TaskUncheckedCreateWithoutProjectInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutProjectInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutProjectInput, TaskUncheckedUpdateWithoutProjectInput>
  }

  export type TaskUpdateManyWithWhereWithoutProjectInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutProjectInput>
  }

  export type TaskScalarWhereInput = {
    AND?: TaskScalarWhereInput | TaskScalarWhereInput[]
    OR?: TaskScalarWhereInput[]
    NOT?: TaskScalarWhereInput | TaskScalarWhereInput[]
    id?: StringFilter<"Task"> | string
    title?: StringFilter<"Task"> | string
    description?: StringNullableFilter<"Task"> | string | null
    status?: EnumTaskStatusFilter<"Task"> | $Enums.TaskStatus
    projectId?: StringFilter<"Task"> | string
    assigneeId?: StringNullableFilter<"Task"> | string | null
    tenantId?: StringNullableFilter<"Task"> | string | null
    isDeleted?: BoolFilter<"Task"> | boolean
    deletedAt?: DateTimeNullableFilter<"Task"> | Date | string | null
    deletedBy?: StringNullableFilter<"Task"> | string | null
    createdBy?: StringNullableFilter<"Task"> | string | null
    createdAt?: DateTimeFilter<"Task"> | Date | string
    updatedAt?: DateTimeFilter<"Task"> | Date | string
  }

  export type ProjectCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectUncheckedCreateWithoutTasksInput = {
    id?: string
    name: string
    description?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProjectCreateOrConnectWithoutTasksInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
  }

  export type UserCreateWithoutTasksInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutTasksInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutTasksInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
  }

  export type ProjectUpsertWithoutTasksInput = {
    update: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
    create: XOR<ProjectCreateWithoutTasksInput, ProjectUncheckedCreateWithoutTasksInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutTasksInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutTasksInput, ProjectUncheckedUpdateWithoutTasksInput>
  }

  export type ProjectUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTasksInput = {
    update: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
    create: XOR<UserCreateWithoutTasksInput, UserUncheckedCreateWithoutTasksInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTasksInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTasksInput, UserUncheckedUpdateWithoutTasksInput>
  }

  export type UserUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type DocumentCreateWithoutChildrenInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    parent?: DocumentCreateNestedOneWithoutChildrenInput
    author: UserCreateNestedOneWithoutDocumentsInput
    revisions?: DocumentRevisionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutChildrenInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    parentId?: string | null
    authorId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    revisions?: DocumentRevisionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutChildrenInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutChildrenInput, DocumentUncheckedCreateWithoutChildrenInput>
  }

  export type DocumentCreateWithoutParentInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    children?: DocumentCreateNestedManyWithoutParentInput
    author: UserCreateNestedOneWithoutDocumentsInput
    revisions?: DocumentRevisionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutParentInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    authorId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    children?: DocumentUncheckedCreateNestedManyWithoutParentInput
    revisions?: DocumentRevisionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutParentInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutParentInput, DocumentUncheckedCreateWithoutParentInput>
  }

  export type DocumentCreateManyParentInputEnvelope = {
    data: DocumentCreateManyParentInput | DocumentCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutDocumentsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutDocumentsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutDocumentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
  }

  export type DocumentRevisionCreateWithoutDocumentInput = {
    id?: string
    version: number
    title: string
    content: string
    summary?: string | null
    changeLog?: string | null
    tenantId?: string | null
    createdAt?: Date | string
    author: UserCreateNestedOneWithoutDocumentRevisionsInput
  }

  export type DocumentRevisionUncheckedCreateWithoutDocumentInput = {
    id?: string
    version: number
    title: string
    content: string
    summary?: string | null
    changeLog?: string | null
    authorId: string
    tenantId?: string | null
    createdAt?: Date | string
  }

  export type DocumentRevisionCreateOrConnectWithoutDocumentInput = {
    where: DocumentRevisionWhereUniqueInput
    create: XOR<DocumentRevisionCreateWithoutDocumentInput, DocumentRevisionUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentRevisionCreateManyDocumentInputEnvelope = {
    data: DocumentRevisionCreateManyDocumentInput | DocumentRevisionCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type DocumentUpsertWithoutChildrenInput = {
    update: XOR<DocumentUpdateWithoutChildrenInput, DocumentUncheckedUpdateWithoutChildrenInput>
    create: XOR<DocumentCreateWithoutChildrenInput, DocumentUncheckedCreateWithoutChildrenInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutChildrenInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutChildrenInput, DocumentUncheckedUpdateWithoutChildrenInput>
  }

  export type DocumentUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DocumentUpdateOneWithoutChildrenNestedInput
    author?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    revisions?: DocumentRevisionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revisions?: DocumentRevisionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUpsertWithWhereUniqueWithoutParentInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutParentInput, DocumentUncheckedUpdateWithoutParentInput>
    create: XOR<DocumentCreateWithoutParentInput, DocumentUncheckedCreateWithoutParentInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutParentInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutParentInput, DocumentUncheckedUpdateWithoutParentInput>
  }

  export type DocumentUpdateManyWithWhereWithoutParentInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutParentInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    title?: StringFilter<"Document"> | string
    content?: StringFilter<"Document"> | string
    slug?: StringFilter<"Document"> | string
    summary?: StringNullableFilter<"Document"> | string | null
    type?: EnumDocumentTypeFilter<"Document"> | $Enums.DocumentType
    status?: EnumDocumentStatusFilter<"Document"> | $Enums.DocumentStatus
    tags?: StringNullableListFilter<"Document">
    parentId?: StringNullableFilter<"Document"> | string | null
    authorId?: StringFilter<"Document"> | string
    tenantId?: StringNullableFilter<"Document"> | string | null
    isDeleted?: BoolFilter<"Document"> | boolean
    deletedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    deletedBy?: StringNullableFilter<"Document"> | string | null
    createdBy?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    publishedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
    viewCount?: IntFilter<"Document"> | number
    lastViewedAt?: DateTimeNullableFilter<"Document"> | Date | string | null
  }

  export type UserUpsertWithoutDocumentsInput = {
    update: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
    create: XOR<UserCreateWithoutDocumentsInput, UserUncheckedCreateWithoutDocumentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentsInput, UserUncheckedUpdateWithoutDocumentsInput>
  }

  export type UserUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type DocumentRevisionUpsertWithWhereUniqueWithoutDocumentInput = {
    where: DocumentRevisionWhereUniqueInput
    update: XOR<DocumentRevisionUpdateWithoutDocumentInput, DocumentRevisionUncheckedUpdateWithoutDocumentInput>
    create: XOR<DocumentRevisionCreateWithoutDocumentInput, DocumentRevisionUncheckedCreateWithoutDocumentInput>
  }

  export type DocumentRevisionUpdateWithWhereUniqueWithoutDocumentInput = {
    where: DocumentRevisionWhereUniqueInput
    data: XOR<DocumentRevisionUpdateWithoutDocumentInput, DocumentRevisionUncheckedUpdateWithoutDocumentInput>
  }

  export type DocumentRevisionUpdateManyWithWhereWithoutDocumentInput = {
    where: DocumentRevisionScalarWhereInput
    data: XOR<DocumentRevisionUpdateManyMutationInput, DocumentRevisionUncheckedUpdateManyWithoutDocumentInput>
  }

  export type DocumentRevisionScalarWhereInput = {
    AND?: DocumentRevisionScalarWhereInput | DocumentRevisionScalarWhereInput[]
    OR?: DocumentRevisionScalarWhereInput[]
    NOT?: DocumentRevisionScalarWhereInput | DocumentRevisionScalarWhereInput[]
    id?: StringFilter<"DocumentRevision"> | string
    documentId?: StringFilter<"DocumentRevision"> | string
    version?: IntFilter<"DocumentRevision"> | number
    title?: StringFilter<"DocumentRevision"> | string
    content?: StringFilter<"DocumentRevision"> | string
    summary?: StringNullableFilter<"DocumentRevision"> | string | null
    changeLog?: StringNullableFilter<"DocumentRevision"> | string | null
    authorId?: StringFilter<"DocumentRevision"> | string
    tenantId?: StringNullableFilter<"DocumentRevision"> | string | null
    createdAt?: DateTimeFilter<"DocumentRevision"> | Date | string
  }

  export type DocumentCreateWithoutRevisionsInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    parent?: DocumentCreateNestedOneWithoutChildrenInput
    children?: DocumentCreateNestedManyWithoutParentInput
    author: UserCreateNestedOneWithoutDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutRevisionsInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    parentId?: string | null
    authorId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    children?: DocumentUncheckedCreateNestedManyWithoutParentInput
  }

  export type DocumentCreateOrConnectWithoutRevisionsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutRevisionsInput, DocumentUncheckedCreateWithoutRevisionsInput>
  }

  export type UserCreateWithoutDocumentRevisionsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutDocumentRevisionsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutDocumentRevisionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDocumentRevisionsInput, UserUncheckedCreateWithoutDocumentRevisionsInput>
  }

  export type DocumentUpsertWithoutRevisionsInput = {
    update: XOR<DocumentUpdateWithoutRevisionsInput, DocumentUncheckedUpdateWithoutRevisionsInput>
    create: XOR<DocumentCreateWithoutRevisionsInput, DocumentUncheckedCreateWithoutRevisionsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutRevisionsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutRevisionsInput, DocumentUncheckedUpdateWithoutRevisionsInput>
  }

  export type DocumentUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DocumentUpdateOneWithoutChildrenNestedInput
    children?: DocumentUpdateManyWithoutParentNestedInput
    author?: UserUpdateOneRequiredWithoutDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: DocumentUncheckedUpdateManyWithoutParentNestedInput
  }

  export type UserUpsertWithoutDocumentRevisionsInput = {
    update: XOR<UserUpdateWithoutDocumentRevisionsInput, UserUncheckedUpdateWithoutDocumentRevisionsInput>
    create: XOR<UserCreateWithoutDocumentRevisionsInput, UserUncheckedCreateWithoutDocumentRevisionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDocumentRevisionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDocumentRevisionsInput, UserUncheckedUpdateWithoutDocumentRevisionsInput>
  }

  export type UserUpdateWithoutDocumentRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutDocumentRevisionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type SaleCreateWithoutProductInput = {
    id?: string
    quantity: number
    total: number
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    seller: UserCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutProductInput = {
    id?: string
    quantity: number
    total: number
    soldBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type SaleCreateOrConnectWithoutProductInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutProductInput, SaleUncheckedCreateWithoutProductInput>
  }

  export type SaleCreateManyProductInputEnvelope = {
    data: SaleCreateManyProductInput | SaleCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type SaleUpsertWithWhereUniqueWithoutProductInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutProductInput, SaleUncheckedUpdateWithoutProductInput>
    create: XOR<SaleCreateWithoutProductInput, SaleUncheckedCreateWithoutProductInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutProductInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutProductInput, SaleUncheckedUpdateWithoutProductInput>
  }

  export type SaleUpdateManyWithWhereWithoutProductInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutProductInput>
  }

  export type SaleScalarWhereInput = {
    AND?: SaleScalarWhereInput | SaleScalarWhereInput[]
    OR?: SaleScalarWhereInput[]
    NOT?: SaleScalarWhereInput | SaleScalarWhereInput[]
    id?: StringFilter<"Sale"> | string
    productId?: StringFilter<"Sale"> | string
    quantity?: IntFilter<"Sale"> | number
    total?: FloatFilter<"Sale"> | number
    soldBy?: StringFilter<"Sale"> | string
    tenantId?: StringNullableFilter<"Sale"> | string | null
    isDeleted?: BoolFilter<"Sale"> | boolean
    deletedAt?: DateTimeNullableFilter<"Sale"> | Date | string | null
    deletedBy?: StringNullableFilter<"Sale"> | string | null
    createdBy?: StringNullableFilter<"Sale"> | string | null
    createdAt?: DateTimeFilter<"Sale"> | Date | string
  }

  export type ProductCreateWithoutSalesInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUncheckedCreateWithoutSalesInput = {
    id?: string
    name: string
    description?: string | null
    price: number
    stock?: number
    category?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductCreateOrConnectWithoutSalesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutSalesInput, ProductUncheckedCreateWithoutSalesInput>
  }

  export type UserCreateWithoutSalesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutSalesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutSalesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
  }

  export type ProductUpsertWithoutSalesInput = {
    update: XOR<ProductUpdateWithoutSalesInput, ProductUncheckedUpdateWithoutSalesInput>
    create: XOR<ProductCreateWithoutSalesInput, ProductUncheckedCreateWithoutSalesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutSalesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutSalesInput, ProductUncheckedUpdateWithoutSalesInput>
  }

  export type ProductUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    stock?: IntFieldUpdateOperationsInput | number
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSalesInput = {
    update: XOR<UserUpdateWithoutSalesInput, UserUncheckedUpdateWithoutSalesInput>
    create: XOR<UserCreateWithoutSalesInput, UserUncheckedCreateWithoutSalesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalesInput, UserUncheckedUpdateWithoutSalesInput>
  }

  export type UserUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutSalesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type TransactionCreateWithoutAccountInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    category?: TransactionCategoryCreateNestedOneWithoutTransactionsInput
    creator?: UserCreateNestedOneWithoutTransactionsInput
    payroll?: PayrollCreateNestedOneWithoutTransactionsInput
    expenseReimbursement?: EmployeeExpenseCreateNestedOneWithoutReimbursementTransactionInput
  }

  export type TransactionUncheckedCreateWithoutAccountInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    categoryId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollId?: string | null
    expenseReimbursement?: EmployeeExpenseUncheckedCreateNestedOneWithoutReimbursementTransactionInput
  }

  export type TransactionCreateOrConnectWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionCreateManyAccountInputEnvelope = {
    data: TransactionCreateManyAccountInput | TransactionCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type BankBalanceCreateWithoutAccountInput = {
    id?: string
    balanceDate: Date | string
    openingBalance?: number
    closingBalance?: number
    totalIncome?: number
    totalExpenses?: number
    transactionCount?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankBalanceUncheckedCreateWithoutAccountInput = {
    id?: string
    balanceDate: Date | string
    openingBalance?: number
    closingBalance?: number
    totalIncome?: number
    totalExpenses?: number
    transactionCount?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BankBalanceCreateOrConnectWithoutAccountInput = {
    where: BankBalanceWhereUniqueInput
    create: XOR<BankBalanceCreateWithoutAccountInput, BankBalanceUncheckedCreateWithoutAccountInput>
  }

  export type BankBalanceCreateManyAccountInputEnvelope = {
    data: BankBalanceCreateManyAccountInput | BankBalanceCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
    create: XOR<TransactionCreateWithoutAccountInput, TransactionUncheckedCreateWithoutAccountInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutAccountInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutAccountInput, TransactionUncheckedUpdateWithoutAccountInput>
  }

  export type TransactionUpdateManyWithWhereWithoutAccountInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutAccountInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    description?: StringFilter<"Transaction"> | string
    amount?: FloatFilter<"Transaction"> | number
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    status?: EnumTransactionStatusFilter<"Transaction"> | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFilter<"Transaction"> | $Enums.PaymentMethod
    reference?: StringNullableFilter<"Transaction"> | string | null
    externalId?: StringNullableFilter<"Transaction"> | string | null
    accountId?: StringFilter<"Transaction"> | string
    categoryId?: StringNullableFilter<"Transaction"> | string | null
    customerName?: StringNullableFilter<"Transaction"> | string | null
    supplierName?: StringNullableFilter<"Transaction"> | string | null
    employeeName?: StringNullableFilter<"Transaction"> | string | null
    projectName?: StringNullableFilter<"Transaction"> | string | null
    items?: JsonNullableFilter<"Transaction">
    notes?: StringNullableFilter<"Transaction"> | string | null
    receiptUrl?: StringNullableFilter<"Transaction"> | string | null
    mpPaymentId?: StringNullableFilter<"Transaction"> | string | null
    mpStatus?: StringNullableFilter<"Transaction"> | string | null
    mpPaymentType?: StringNullableFilter<"Transaction"> | string | null
    tenantId?: StringNullableFilter<"Transaction"> | string | null
    isDeleted?: BoolFilter<"Transaction"> | boolean
    deletedAt?: DateTimeNullableFilter<"Transaction"> | Date | string | null
    deletedBy?: StringNullableFilter<"Transaction"> | string | null
    createdBy?: StringNullableFilter<"Transaction"> | string | null
    createdAt?: DateTimeFilter<"Transaction"> | Date | string
    updatedAt?: DateTimeFilter<"Transaction"> | Date | string
    payrollId?: StringNullableFilter<"Transaction"> | string | null
  }

  export type BankBalanceUpsertWithWhereUniqueWithoutAccountInput = {
    where: BankBalanceWhereUniqueInput
    update: XOR<BankBalanceUpdateWithoutAccountInput, BankBalanceUncheckedUpdateWithoutAccountInput>
    create: XOR<BankBalanceCreateWithoutAccountInput, BankBalanceUncheckedCreateWithoutAccountInput>
  }

  export type BankBalanceUpdateWithWhereUniqueWithoutAccountInput = {
    where: BankBalanceWhereUniqueInput
    data: XOR<BankBalanceUpdateWithoutAccountInput, BankBalanceUncheckedUpdateWithoutAccountInput>
  }

  export type BankBalanceUpdateManyWithWhereWithoutAccountInput = {
    where: BankBalanceScalarWhereInput
    data: XOR<BankBalanceUpdateManyMutationInput, BankBalanceUncheckedUpdateManyWithoutAccountInput>
  }

  export type BankBalanceScalarWhereInput = {
    AND?: BankBalanceScalarWhereInput | BankBalanceScalarWhereInput[]
    OR?: BankBalanceScalarWhereInput[]
    NOT?: BankBalanceScalarWhereInput | BankBalanceScalarWhereInput[]
    id?: StringFilter<"BankBalance"> | string
    accountId?: StringFilter<"BankBalance"> | string
    balanceDate?: DateTimeFilter<"BankBalance"> | Date | string
    openingBalance?: FloatFilter<"BankBalance"> | number
    closingBalance?: FloatFilter<"BankBalance"> | number
    totalIncome?: FloatFilter<"BankBalance"> | number
    totalExpenses?: FloatFilter<"BankBalance"> | number
    transactionCount?: IntFilter<"BankBalance"> | number
    tenantId?: StringNullableFilter<"BankBalance"> | string | null
    createdAt?: DateTimeFilter<"BankBalance"> | Date | string
    updatedAt?: DateTimeFilter<"BankBalance"> | Date | string
  }

  export type TransactionCreateWithoutCategoryInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: BankAccountCreateNestedOneWithoutTransactionsInput
    creator?: UserCreateNestedOneWithoutTransactionsInput
    payroll?: PayrollCreateNestedOneWithoutTransactionsInput
    expenseReimbursement?: EmployeeExpenseCreateNestedOneWithoutReimbursementTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCategoryInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    accountId: string
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollId?: string | null
    expenseReimbursement?: EmployeeExpenseUncheckedCreateNestedOneWithoutReimbursementTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput>
  }

  export type TransactionCreateManyCategoryInputEnvelope = {
    data: TransactionCreateManyCategoryInput | TransactionCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type TransactionUpsertWithWhereUniqueWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCategoryInput, TransactionUncheckedUpdateWithoutCategoryInput>
    create: XOR<TransactionCreateWithoutCategoryInput, TransactionUncheckedCreateWithoutCategoryInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCategoryInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCategoryInput, TransactionUncheckedUpdateWithoutCategoryInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCategoryInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCategoryInput>
  }

  export type BankAccountCreateWithoutTransactionsInput = {
    id?: string
    name: string
    accountNumber?: string | null
    bankName?: string | null
    accountType?: string | null
    currency?: string
    currentBalance?: number
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    balanceHistory?: BankBalanceCreateNestedManyWithoutAccountInput
  }

  export type BankAccountUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    accountNumber?: string | null
    bankName?: string | null
    accountType?: string | null
    currency?: string
    currentBalance?: number
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    balanceHistory?: BankBalanceUncheckedCreateNestedManyWithoutAccountInput
  }

  export type BankAccountCreateOrConnectWithoutTransactionsInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
  }

  export type TransactionCategoryCreateWithoutTransactionsInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    description?: string | null
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCategoryUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    icon?: string | null
    color?: string | null
    description?: string | null
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCategoryCreateOrConnectWithoutTransactionsInput = {
    where: TransactionCategoryWhereUniqueInput
    create: XOR<TransactionCategoryCreateWithoutTransactionsInput, TransactionCategoryUncheckedCreateWithoutTransactionsInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type PayrollCreateWithoutTransactionsInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedAt?: Date | string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutPayrollsApprovedInput
    processor?: UserCreateNestedOneWithoutPayrollsProcessedInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUncheckedCreateWithoutTransactionsInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutPayrollInput
  }

  export type PayrollCreateOrConnectWithoutTransactionsInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutTransactionsInput, PayrollUncheckedCreateWithoutTransactionsInput>
  }

  export type EmployeeExpenseCreateWithoutReimbursementTransactionInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutEmployeeExpensesInput
    reviewer?: UserCreateNestedOneWithoutExpenseReviewsInput
  }

  export type EmployeeExpenseUncheckedCreateWithoutReimbursementTransactionInput = {
    id?: string
    employeeId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeExpenseCreateOrConnectWithoutReimbursementTransactionInput = {
    where: EmployeeExpenseWhereUniqueInput
    create: XOR<EmployeeExpenseCreateWithoutReimbursementTransactionInput, EmployeeExpenseUncheckedCreateWithoutReimbursementTransactionInput>
  }

  export type BankAccountUpsertWithoutTransactionsInput = {
    update: XOR<BankAccountUpdateWithoutTransactionsInput, BankAccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutTransactionsInput, BankAccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type BankAccountUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balanceHistory?: BankBalanceUpdateManyWithoutAccountNestedInput
  }

  export type BankAccountUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    balanceHistory?: BankBalanceUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type TransactionCategoryUpsertWithoutTransactionsInput = {
    update: XOR<TransactionCategoryUpdateWithoutTransactionsInput, TransactionCategoryUncheckedUpdateWithoutTransactionsInput>
    create: XOR<TransactionCategoryCreateWithoutTransactionsInput, TransactionCategoryUncheckedCreateWithoutTransactionsInput>
    where?: TransactionCategoryWhereInput
  }

  export type TransactionCategoryUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: TransactionCategoryWhereInput
    data: XOR<TransactionCategoryUpdateWithoutTransactionsInput, TransactionCategoryUncheckedUpdateWithoutTransactionsInput>
  }

  export type TransactionCategoryUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCategoryUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type PayrollUpsertWithoutTransactionsInput = {
    update: XOR<PayrollUpdateWithoutTransactionsInput, PayrollUncheckedUpdateWithoutTransactionsInput>
    create: XOR<PayrollCreateWithoutTransactionsInput, PayrollUncheckedCreateWithoutTransactionsInput>
    where?: PayrollWhereInput
  }

  export type PayrollUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: PayrollWhereInput
    data: XOR<PayrollUpdateWithoutTransactionsInput, PayrollUncheckedUpdateWithoutTransactionsInput>
  }

  export type PayrollUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutPayrollsApprovedNestedInput
    processor?: UserUpdateOneWithoutPayrollsProcessedNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutPayrollNestedInput
  }

  export type EmployeeExpenseUpsertWithoutReimbursementTransactionInput = {
    update: XOR<EmployeeExpenseUpdateWithoutReimbursementTransactionInput, EmployeeExpenseUncheckedUpdateWithoutReimbursementTransactionInput>
    create: XOR<EmployeeExpenseCreateWithoutReimbursementTransactionInput, EmployeeExpenseUncheckedCreateWithoutReimbursementTransactionInput>
    where?: EmployeeExpenseWhereInput
  }

  export type EmployeeExpenseUpdateToOneWithWhereWithoutReimbursementTransactionInput = {
    where?: EmployeeExpenseWhereInput
    data: XOR<EmployeeExpenseUpdateWithoutReimbursementTransactionInput, EmployeeExpenseUncheckedUpdateWithoutReimbursementTransactionInput>
  }

  export type EmployeeExpenseUpdateWithoutReimbursementTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutEmployeeExpensesNestedInput
    reviewer?: UserUpdateOneWithoutExpenseReviewsNestedInput
  }

  export type EmployeeExpenseUncheckedUpdateWithoutReimbursementTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateWithoutBalanceHistoryInput = {
    id?: string
    name: string
    accountNumber?: string | null
    bankName?: string | null
    accountType?: string | null
    currency?: string
    currentBalance?: number
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionCreateNestedManyWithoutAccountInput
  }

  export type BankAccountUncheckedCreateWithoutBalanceHistoryInput = {
    id?: string
    name: string
    accountNumber?: string | null
    bankName?: string | null
    accountType?: string | null
    currency?: string
    currentBalance?: number
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutAccountInput
  }

  export type BankAccountCreateOrConnectWithoutBalanceHistoryInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutBalanceHistoryInput, BankAccountUncheckedCreateWithoutBalanceHistoryInput>
  }

  export type BankAccountUpsertWithoutBalanceHistoryInput = {
    update: XOR<BankAccountUpdateWithoutBalanceHistoryInput, BankAccountUncheckedUpdateWithoutBalanceHistoryInput>
    create: XOR<BankAccountCreateWithoutBalanceHistoryInput, BankAccountUncheckedCreateWithoutBalanceHistoryInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutBalanceHistoryInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutBalanceHistoryInput, BankAccountUncheckedUpdateWithoutBalanceHistoryInput>
  }

  export type BankAccountUpdateWithoutBalanceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUpdateManyWithoutAccountNestedInput
  }

  export type BankAccountUncheckedUpdateWithoutBalanceHistoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    accountNumber?: NullableStringFieldUpdateOperationsInput | string | null
    bankName?: NullableStringFieldUpdateOperationsInput | string | null
    accountType?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    currentBalance?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type RoleCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: RoleCreatepermissionsInput | string[]
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    description?: string | null
    permissions?: RoleCreatepermissionsInput | string[]
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoleCreateOrConnectWithoutUsersInput = {
    where: RoleWhereUniqueInput
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
  }

  export type TaskCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    project: ProjectCreateNestedOneWithoutTasksInput
  }

  export type TaskUncheckedCreateWithoutAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    projectId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskCreateOrConnectWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskCreateManyAssigneeInputEnvelope = {
    data: TaskCreateManyAssigneeInput | TaskCreateManyAssigneeInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    parent?: DocumentCreateNestedOneWithoutChildrenInput
    children?: DocumentCreateNestedManyWithoutParentInput
    revisions?: DocumentRevisionCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutAuthorInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    parentId?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
    children?: DocumentUncheckedCreateNestedManyWithoutParentInput
    revisions?: DocumentRevisionUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutAuthorInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutAuthorInput, DocumentUncheckedCreateWithoutAuthorInput>
  }

  export type DocumentCreateManyAuthorInputEnvelope = {
    data: DocumentCreateManyAuthorInput | DocumentCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type DocumentRevisionCreateWithoutAuthorInput = {
    id?: string
    version: number
    title: string
    content: string
    summary?: string | null
    changeLog?: string | null
    tenantId?: string | null
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutRevisionsInput
  }

  export type DocumentRevisionUncheckedCreateWithoutAuthorInput = {
    id?: string
    documentId: string
    version: number
    title: string
    content: string
    summary?: string | null
    changeLog?: string | null
    tenantId?: string | null
    createdAt?: Date | string
  }

  export type DocumentRevisionCreateOrConnectWithoutAuthorInput = {
    where: DocumentRevisionWhereUniqueInput
    create: XOR<DocumentRevisionCreateWithoutAuthorInput, DocumentRevisionUncheckedCreateWithoutAuthorInput>
  }

  export type DocumentRevisionCreateManyAuthorInputEnvelope = {
    data: DocumentRevisionCreateManyAuthorInput | DocumentRevisionCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SaleCreateWithoutSellerInput = {
    id?: string
    quantity: number
    total: number
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutSalesInput
  }

  export type SaleUncheckedCreateWithoutSellerInput = {
    id?: string
    productId: string
    quantity: number
    total: number
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type SaleCreateOrConnectWithoutSellerInput = {
    where: SaleWhereUniqueInput
    create: XOR<SaleCreateWithoutSellerInput, SaleUncheckedCreateWithoutSellerInput>
  }

  export type SaleCreateManySellerInputEnvelope = {
    data: SaleCreateManySellerInput | SaleCreateManySellerInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCreatorInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: BankAccountCreateNestedOneWithoutTransactionsInput
    category?: TransactionCategoryCreateNestedOneWithoutTransactionsInput
    payroll?: PayrollCreateNestedOneWithoutTransactionsInput
    expenseReimbursement?: EmployeeExpenseCreateNestedOneWithoutReimbursementTransactionInput
  }

  export type TransactionUncheckedCreateWithoutCreatorInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    accountId: string
    categoryId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollId?: string | null
    expenseReimbursement?: EmployeeExpenseUncheckedCreateNestedOneWithoutReimbursementTransactionInput
  }

  export type TransactionCreateOrConnectWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput>
  }

  export type TransactionCreateManyCreatorInputEnvelope = {
    data: TransactionCreateManyCreatorInput | TransactionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type AuditTrailCreateWithoutUserInput = {
    id?: string
    tableName: string
    recordId: string
    operation: $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditTrailUncheckedCreateWithoutUserInput = {
    id?: string
    tableName: string
    recordId: string
    operation: $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type AuditTrailCreateOrConnectWithoutUserInput = {
    where: AuditTrailWhereUniqueInput
    create: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput>
  }

  export type AuditTrailCreateManyUserInputEnvelope = {
    data: AuditTrailCreateManyUserInput | AuditTrailCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationTemplateCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    subject?: string | null
    content: string
    variables?: NotificationTemplateCreatevariablesInput | string[]
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: NotificationRuleCreateNestedManyWithoutTemplateInput
    notifications?: NotificationCreateNestedManyWithoutTemplateInput
  }

  export type NotificationTemplateUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    subject?: string | null
    content: string
    variables?: NotificationTemplateCreatevariablesInput | string[]
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: NotificationRuleUncheckedCreateNestedManyWithoutTemplateInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type NotificationTemplateCreateOrConnectWithoutCreatorInput = {
    where: NotificationTemplateWhereUniqueInput
    create: XOR<NotificationTemplateCreateWithoutCreatorInput, NotificationTemplateUncheckedCreateWithoutCreatorInput>
  }

  export type NotificationTemplateCreateManyCreatorInputEnvelope = {
    data: NotificationTemplateCreateManyCreatorInput | NotificationTemplateCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationRuleCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: NotificationTemplateCreateNestedOneWithoutRulesInput
    notifications?: NotificationCreateNestedManyWithoutRuleInput
  }

  export type NotificationRuleUncheckedCreateWithoutCreatorInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    templateId: string
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutRuleInput
  }

  export type NotificationRuleCreateOrConnectWithoutCreatorInput = {
    where: NotificationRuleWhereUniqueInput
    create: XOR<NotificationRuleCreateWithoutCreatorInput, NotificationRuleUncheckedCreateWithoutCreatorInput>
  }

  export type NotificationRuleCreateManyCreatorInputEnvelope = {
    data: NotificationRuleCreateManyCreatorInput | NotificationRuleCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutRecipientInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: NotificationTemplateCreateNestedOneWithoutNotificationsInput
    rule?: NotificationRuleCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRecipientInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    templateId?: string | null
    ruleId?: string | null
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationCreateManyRecipientInputEnvelope = {
    data: NotificationCreateManyRecipientInput | NotificationCreateManyRecipientInput[]
    skipDuplicates?: boolean
  }

  export type MagicTokenCreateWithoutUserInput = {
    id?: string
    purpose: string
    tokenHash: string
    expiresAt: Date | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MagicTokenUncheckedCreateWithoutUserInput = {
    id?: string
    purpose: string
    tokenHash: string
    expiresAt: Date | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MagicTokenCreateOrConnectWithoutUserInput = {
    where: MagicTokenWhereUniqueInput
    create: XOR<MagicTokenCreateWithoutUserInput, MagicTokenUncheckedCreateWithoutUserInput>
  }

  export type MagicTokenCreateManyUserInputEnvelope = {
    data: MagicTokenCreateManyUserInput | MagicTokenCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PayrollCreateWithoutApproverInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedAt?: Date | string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    processor?: UserCreateNestedOneWithoutPayrollsProcessedInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutPayrollInput
    transactions?: TransactionCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUncheckedCreateWithoutApproverInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutPayrollInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPayrollInput
  }

  export type PayrollCreateOrConnectWithoutApproverInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutApproverInput, PayrollUncheckedCreateWithoutApproverInput>
  }

  export type PayrollCreateManyApproverInputEnvelope = {
    data: PayrollCreateManyApproverInput | PayrollCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type PayrollCreateWithoutProcessorInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedAt?: Date | string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutPayrollsApprovedInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutPayrollInput
    transactions?: TransactionCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUncheckedCreateWithoutProcessorInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutPayrollInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutPayrollInput
  }

  export type PayrollCreateOrConnectWithoutProcessorInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutProcessorInput, PayrollUncheckedCreateWithoutProcessorInput>
  }

  export type PayrollCreateManyProcessorInputEnvelope = {
    data: PayrollCreateManyProcessorInput | PayrollCreateManyProcessorInput[]
    skipDuplicates?: boolean
  }

  export type PayrollEntryCreateWithoutEmployeeInput = {
    id?: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hoursWorked?: Decimal | DecimalJsLike | number | string | null
    overtimeHours?: Decimal | DecimalJsLike | number | string | null
    bonusAmount?: Decimal | DecimalJsLike | number | string | null
    allowances?: Decimal | DecimalJsLike | number | string | null
    grossPay: Decimal | DecimalJsLike | number | string
    taxDeductions: Decimal | DecimalJsLike | number | string
    socialSecurity: Decimal | DecimalJsLike | number | string
    otherDeductions?: Decimal | DecimalJsLike | number | string | null
    netPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payroll: PayrollCreateNestedOneWithoutPayrollEntriesInput
  }

  export type PayrollEntryUncheckedCreateWithoutEmployeeInput = {
    id?: string
    payrollId: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hoursWorked?: Decimal | DecimalJsLike | number | string | null
    overtimeHours?: Decimal | DecimalJsLike | number | string | null
    bonusAmount?: Decimal | DecimalJsLike | number | string | null
    allowances?: Decimal | DecimalJsLike | number | string | null
    grossPay: Decimal | DecimalJsLike | number | string
    taxDeductions: Decimal | DecimalJsLike | number | string
    socialSecurity: Decimal | DecimalJsLike | number | string
    otherDeductions?: Decimal | DecimalJsLike | number | string | null
    netPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryCreateOrConnectWithoutEmployeeInput = {
    where: PayrollEntryWhereUniqueInput
    create: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollEntryCreateManyEmployeeInputEnvelope = {
    data: PayrollEntryCreateManyEmployeeInput | PayrollEntryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type SalaryAdjustmentCreateWithoutEmployeeInput = {
    id?: string
    adjustmentType: $Enums.SalaryAdjustmentType
    previousAmount: Decimal | DecimalJsLike | number | string
    newAmount: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    reason: string
    notes?: string | null
    approvedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutSalaryAdjustmentsApprovedInput
  }

  export type SalaryAdjustmentUncheckedCreateWithoutEmployeeInput = {
    id?: string
    adjustmentType: $Enums.SalaryAdjustmentType
    previousAmount: Decimal | DecimalJsLike | number | string
    newAmount: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    reason: string
    notes?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryAdjustmentCreateOrConnectWithoutEmployeeInput = {
    where: SalaryAdjustmentWhereUniqueInput
    create: XOR<SalaryAdjustmentCreateWithoutEmployeeInput, SalaryAdjustmentUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryAdjustmentCreateManyEmployeeInputEnvelope = {
    data: SalaryAdjustmentCreateManyEmployeeInput | SalaryAdjustmentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type SalaryAdjustmentCreateWithoutApproverInput = {
    id?: string
    adjustmentType: $Enums.SalaryAdjustmentType
    previousAmount: Decimal | DecimalJsLike | number | string
    newAmount: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    reason: string
    notes?: string | null
    approvedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutSalaryAdjustmentsInput
  }

  export type SalaryAdjustmentUncheckedCreateWithoutApproverInput = {
    id?: string
    employeeId: string
    adjustmentType: $Enums.SalaryAdjustmentType
    previousAmount: Decimal | DecimalJsLike | number | string
    newAmount: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    reason: string
    notes?: string | null
    approvedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryAdjustmentCreateOrConnectWithoutApproverInput = {
    where: SalaryAdjustmentWhereUniqueInput
    create: XOR<SalaryAdjustmentCreateWithoutApproverInput, SalaryAdjustmentUncheckedCreateWithoutApproverInput>
  }

  export type SalaryAdjustmentCreateManyApproverInputEnvelope = {
    data: SalaryAdjustmentCreateManyApproverInput | SalaryAdjustmentCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeExpenseCreateWithoutEmployeeInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviewer?: UserCreateNestedOneWithoutExpenseReviewsInput
    reimbursementTransaction?: TransactionCreateNestedOneWithoutExpenseReimbursementInput
  }

  export type EmployeeExpenseUncheckedCreateWithoutEmployeeInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    reimbursementTransactionId?: string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeExpenseCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeExpenseWhereUniqueInput
    create: XOR<EmployeeExpenseCreateWithoutEmployeeInput, EmployeeExpenseUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeExpenseCreateManyEmployeeInputEnvelope = {
    data: EmployeeExpenseCreateManyEmployeeInput | EmployeeExpenseCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeExpenseCreateWithoutReviewerInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutEmployeeExpensesInput
    reimbursementTransaction?: TransactionCreateNestedOneWithoutExpenseReimbursementInput
  }

  export type EmployeeExpenseUncheckedCreateWithoutReviewerInput = {
    id?: string
    employeeId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    reimbursementTransactionId?: string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeExpenseCreateOrConnectWithoutReviewerInput = {
    where: EmployeeExpenseWhereUniqueInput
    create: XOR<EmployeeExpenseCreateWithoutReviewerInput, EmployeeExpenseUncheckedCreateWithoutReviewerInput>
  }

  export type EmployeeExpenseCreateManyReviewerInputEnvelope = {
    data: EmployeeExpenseCreateManyReviewerInput | EmployeeExpenseCreateManyReviewerInput[]
    skipDuplicates?: boolean
  }

  export type PTORequestCreateWithoutEmployeeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    status?: $Enums.PTOStatus
    reason?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    cancelledAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutPtoApprovalsInput
  }

  export type PTORequestUncheckedCreateWithoutEmployeeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    status?: $Enums.PTOStatus
    reason?: string | null
    submittedAt?: Date | string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    cancelledAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTORequestCreateOrConnectWithoutEmployeeInput = {
    where: PTORequestWhereUniqueInput
    create: XOR<PTORequestCreateWithoutEmployeeInput, PTORequestUncheckedCreateWithoutEmployeeInput>
  }

  export type PTORequestCreateManyEmployeeInputEnvelope = {
    data: PTORequestCreateManyEmployeeInput | PTORequestCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PTORequestCreateWithoutApproverInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    status?: $Enums.PTOStatus
    reason?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    cancelledAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutPtoRequestsInput
  }

  export type PTORequestUncheckedCreateWithoutApproverInput = {
    id?: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    status?: $Enums.PTOStatus
    reason?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    cancelledAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTORequestCreateOrConnectWithoutApproverInput = {
    where: PTORequestWhereUniqueInput
    create: XOR<PTORequestCreateWithoutApproverInput, PTORequestUncheckedCreateWithoutApproverInput>
  }

  export type PTORequestCreateManyApproverInputEnvelope = {
    data: PTORequestCreateManyApproverInput | PTORequestCreateManyApproverInput[]
    skipDuplicates?: boolean
  }

  export type PTOBalanceCreateWithoutEmployeeInput = {
    id?: string
    year: number
    totalDays: Decimal | DecimalJsLike | number | string
    usedDays?: Decimal | DecimalJsLike | number | string
    carryOverDays?: Decimal | DecimalJsLike | number | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTOBalanceUncheckedCreateWithoutEmployeeInput = {
    id?: string
    year: number
    totalDays: Decimal | DecimalJsLike | number | string
    usedDays?: Decimal | DecimalJsLike | number | string
    carryOverDays?: Decimal | DecimalJsLike | number | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTOBalanceCreateOrConnectWithoutEmployeeInput = {
    where: PTOBalanceWhereUniqueInput
    create: XOR<PTOBalanceCreateWithoutEmployeeInput, PTOBalanceUncheckedCreateWithoutEmployeeInput>
  }

  export type PTOBalanceCreateManyEmployeeInputEnvelope = {
    data: PTOBalanceCreateManyEmployeeInput | PTOBalanceCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type RoleUpsertWithoutUsersInput = {
    update: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
    create: XOR<RoleCreateWithoutUsersInput, RoleUncheckedCreateWithoutUsersInput>
    where?: RoleWhereInput
  }

  export type RoleUpdateToOneWithWhereWithoutUsersInput = {
    where?: RoleWhereInput
    data: XOR<RoleUpdateWithoutUsersInput, RoleUncheckedUpdateWithoutUsersInput>
  }

  export type RoleUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoleUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: RoleUpdatepermissionsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    update: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
    create: XOR<TaskCreateWithoutAssigneeInput, TaskUncheckedCreateWithoutAssigneeInput>
  }

  export type TaskUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: TaskWhereUniqueInput
    data: XOR<TaskUpdateWithoutAssigneeInput, TaskUncheckedUpdateWithoutAssigneeInput>
  }

  export type TaskUpdateManyWithWhereWithoutAssigneeInput = {
    where: TaskScalarWhereInput
    data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutAuthorInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutAuthorInput, DocumentUncheckedUpdateWithoutAuthorInput>
    create: XOR<DocumentCreateWithoutAuthorInput, DocumentUncheckedCreateWithoutAuthorInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutAuthorInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutAuthorInput, DocumentUncheckedUpdateWithoutAuthorInput>
  }

  export type DocumentUpdateManyWithWhereWithoutAuthorInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutAuthorInput>
  }

  export type DocumentRevisionUpsertWithWhereUniqueWithoutAuthorInput = {
    where: DocumentRevisionWhereUniqueInput
    update: XOR<DocumentRevisionUpdateWithoutAuthorInput, DocumentRevisionUncheckedUpdateWithoutAuthorInput>
    create: XOR<DocumentRevisionCreateWithoutAuthorInput, DocumentRevisionUncheckedCreateWithoutAuthorInput>
  }

  export type DocumentRevisionUpdateWithWhereUniqueWithoutAuthorInput = {
    where: DocumentRevisionWhereUniqueInput
    data: XOR<DocumentRevisionUpdateWithoutAuthorInput, DocumentRevisionUncheckedUpdateWithoutAuthorInput>
  }

  export type DocumentRevisionUpdateManyWithWhereWithoutAuthorInput = {
    where: DocumentRevisionScalarWhereInput
    data: XOR<DocumentRevisionUpdateManyMutationInput, DocumentRevisionUncheckedUpdateManyWithoutAuthorInput>
  }

  export type SaleUpsertWithWhereUniqueWithoutSellerInput = {
    where: SaleWhereUniqueInput
    update: XOR<SaleUpdateWithoutSellerInput, SaleUncheckedUpdateWithoutSellerInput>
    create: XOR<SaleCreateWithoutSellerInput, SaleUncheckedCreateWithoutSellerInput>
  }

  export type SaleUpdateWithWhereUniqueWithoutSellerInput = {
    where: SaleWhereUniqueInput
    data: XOR<SaleUpdateWithoutSellerInput, SaleUncheckedUpdateWithoutSellerInput>
  }

  export type SaleUpdateManyWithWhereWithoutSellerInput = {
    where: SaleScalarWhereInput
    data: XOR<SaleUpdateManyMutationInput, SaleUncheckedUpdateManyWithoutSellerInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCreatorInput, TransactionUncheckedUpdateWithoutCreatorInput>
    create: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCreatorInput, TransactionUncheckedUpdateWithoutCreatorInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCreatorInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type AuditTrailUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditTrailWhereUniqueInput
    update: XOR<AuditTrailUpdateWithoutUserInput, AuditTrailUncheckedUpdateWithoutUserInput>
    create: XOR<AuditTrailCreateWithoutUserInput, AuditTrailUncheckedCreateWithoutUserInput>
  }

  export type AuditTrailUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditTrailWhereUniqueInput
    data: XOR<AuditTrailUpdateWithoutUserInput, AuditTrailUncheckedUpdateWithoutUserInput>
  }

  export type AuditTrailUpdateManyWithWhereWithoutUserInput = {
    where: AuditTrailScalarWhereInput
    data: XOR<AuditTrailUpdateManyMutationInput, AuditTrailUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditTrailScalarWhereInput = {
    AND?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
    OR?: AuditTrailScalarWhereInput[]
    NOT?: AuditTrailScalarWhereInput | AuditTrailScalarWhereInput[]
    id?: StringFilter<"AuditTrail"> | string
    tableName?: StringFilter<"AuditTrail"> | string
    recordId?: StringFilter<"AuditTrail"> | string
    operation?: EnumAuditOperationFilter<"AuditTrail"> | $Enums.AuditOperation
    beforeData?: JsonNullableFilter<"AuditTrail">
    afterData?: JsonNullableFilter<"AuditTrail">
    userId?: StringNullableFilter<"AuditTrail"> | string | null
    tenantId?: StringNullableFilter<"AuditTrail"> | string | null
    timestamp?: DateTimeFilter<"AuditTrail"> | Date | string
    ipAddress?: StringNullableFilter<"AuditTrail"> | string | null
    userAgent?: StringNullableFilter<"AuditTrail"> | string | null
  }

  export type NotificationTemplateUpsertWithWhereUniqueWithoutCreatorInput = {
    where: NotificationTemplateWhereUniqueInput
    update: XOR<NotificationTemplateUpdateWithoutCreatorInput, NotificationTemplateUncheckedUpdateWithoutCreatorInput>
    create: XOR<NotificationTemplateCreateWithoutCreatorInput, NotificationTemplateUncheckedCreateWithoutCreatorInput>
  }

  export type NotificationTemplateUpdateWithWhereUniqueWithoutCreatorInput = {
    where: NotificationTemplateWhereUniqueInput
    data: XOR<NotificationTemplateUpdateWithoutCreatorInput, NotificationTemplateUncheckedUpdateWithoutCreatorInput>
  }

  export type NotificationTemplateUpdateManyWithWhereWithoutCreatorInput = {
    where: NotificationTemplateScalarWhereInput
    data: XOR<NotificationTemplateUpdateManyMutationInput, NotificationTemplateUncheckedUpdateManyWithoutCreatorInput>
  }

  export type NotificationTemplateScalarWhereInput = {
    AND?: NotificationTemplateScalarWhereInput | NotificationTemplateScalarWhereInput[]
    OR?: NotificationTemplateScalarWhereInput[]
    NOT?: NotificationTemplateScalarWhereInput | NotificationTemplateScalarWhereInput[]
    id?: StringFilter<"NotificationTemplate"> | string
    name?: StringFilter<"NotificationTemplate"> | string
    description?: StringNullableFilter<"NotificationTemplate"> | string | null
    type?: EnumNotificationTypeFilter<"NotificationTemplate"> | $Enums.NotificationType
    subject?: StringNullableFilter<"NotificationTemplate"> | string | null
    content?: StringFilter<"NotificationTemplate"> | string
    variables?: StringNullableListFilter<"NotificationTemplate">
    isActive?: BoolFilter<"NotificationTemplate"> | boolean
    createdBy?: StringFilter<"NotificationTemplate"> | string
    tenantId?: StringNullableFilter<"NotificationTemplate"> | string | null
    isDeleted?: BoolFilter<"NotificationTemplate"> | boolean
    deletedAt?: DateTimeNullableFilter<"NotificationTemplate"> | Date | string | null
    deletedBy?: StringNullableFilter<"NotificationTemplate"> | string | null
    createdAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationTemplate"> | Date | string
  }

  export type NotificationRuleUpsertWithWhereUniqueWithoutCreatorInput = {
    where: NotificationRuleWhereUniqueInput
    update: XOR<NotificationRuleUpdateWithoutCreatorInput, NotificationRuleUncheckedUpdateWithoutCreatorInput>
    create: XOR<NotificationRuleCreateWithoutCreatorInput, NotificationRuleUncheckedCreateWithoutCreatorInput>
  }

  export type NotificationRuleUpdateWithWhereUniqueWithoutCreatorInput = {
    where: NotificationRuleWhereUniqueInput
    data: XOR<NotificationRuleUpdateWithoutCreatorInput, NotificationRuleUncheckedUpdateWithoutCreatorInput>
  }

  export type NotificationRuleUpdateManyWithWhereWithoutCreatorInput = {
    where: NotificationRuleScalarWhereInput
    data: XOR<NotificationRuleUpdateManyMutationInput, NotificationRuleUncheckedUpdateManyWithoutCreatorInput>
  }

  export type NotificationRuleScalarWhereInput = {
    AND?: NotificationRuleScalarWhereInput | NotificationRuleScalarWhereInput[]
    OR?: NotificationRuleScalarWhereInput[]
    NOT?: NotificationRuleScalarWhereInput | NotificationRuleScalarWhereInput[]
    id?: StringFilter<"NotificationRule"> | string
    name?: StringFilter<"NotificationRule"> | string
    description?: StringNullableFilter<"NotificationRule"> | string | null
    trigger?: EnumRuleTriggerFilter<"NotificationRule"> | $Enums.RuleTrigger
    conditions?: JsonFilter<"NotificationRule">
    isActive?: BoolFilter<"NotificationRule"> | boolean
    templateId?: StringFilter<"NotificationRule"> | string
    recipients?: JsonFilter<"NotificationRule">
    delay?: IntNullableFilter<"NotificationRule"> | number | null
    createdBy?: StringFilter<"NotificationRule"> | string
    tenantId?: StringNullableFilter<"NotificationRule"> | string | null
    isDeleted?: BoolFilter<"NotificationRule"> | boolean
    deletedAt?: DateTimeNullableFilter<"NotificationRule"> | Date | string | null
    deletedBy?: StringNullableFilter<"NotificationRule"> | string | null
    createdAt?: DateTimeFilter<"NotificationRule"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationRule"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
    create: XOR<NotificationCreateWithoutRecipientInput, NotificationUncheckedCreateWithoutRecipientInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRecipientInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRecipientInput, NotificationUncheckedUpdateWithoutRecipientInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRecipientInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRecipientInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    status?: EnumNotificationStatusFilter<"Notification"> | $Enums.NotificationStatus
    subject?: StringNullableFilter<"Notification"> | string | null
    content?: StringFilter<"Notification"> | string
    recipientId?: StringFilter<"Notification"> | string
    templateId?: StringNullableFilter<"Notification"> | string | null
    ruleId?: StringNullableFilter<"Notification"> | string | null
    entityType?: StringNullableFilter<"Notification"> | string | null
    entityId?: StringNullableFilter<"Notification"> | string | null
    metadata?: JsonNullableFilter<"Notification">
    scheduledAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    sentAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    errorMessage?: StringNullableFilter<"Notification"> | string | null
    readAt?: DateTimeNullableFilter<"Notification"> | Date | string | null
    tenantId?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    updatedAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type MagicTokenUpsertWithWhereUniqueWithoutUserInput = {
    where: MagicTokenWhereUniqueInput
    update: XOR<MagicTokenUpdateWithoutUserInput, MagicTokenUncheckedUpdateWithoutUserInput>
    create: XOR<MagicTokenCreateWithoutUserInput, MagicTokenUncheckedCreateWithoutUserInput>
  }

  export type MagicTokenUpdateWithWhereUniqueWithoutUserInput = {
    where: MagicTokenWhereUniqueInput
    data: XOR<MagicTokenUpdateWithoutUserInput, MagicTokenUncheckedUpdateWithoutUserInput>
  }

  export type MagicTokenUpdateManyWithWhereWithoutUserInput = {
    where: MagicTokenScalarWhereInput
    data: XOR<MagicTokenUpdateManyMutationInput, MagicTokenUncheckedUpdateManyWithoutUserInput>
  }

  export type MagicTokenScalarWhereInput = {
    AND?: MagicTokenScalarWhereInput | MagicTokenScalarWhereInput[]
    OR?: MagicTokenScalarWhereInput[]
    NOT?: MagicTokenScalarWhereInput | MagicTokenScalarWhereInput[]
    id?: StringFilter<"MagicToken"> | string
    userId?: StringFilter<"MagicToken"> | string
    purpose?: StringFilter<"MagicToken"> | string
    tokenHash?: StringFilter<"MagicToken"> | string
    expiresAt?: DateTimeFilter<"MagicToken"> | Date | string
    tenantId?: StringNullableFilter<"MagicToken"> | string | null
    isDeleted?: BoolFilter<"MagicToken"> | boolean
    deletedAt?: DateTimeNullableFilter<"MagicToken"> | Date | string | null
    deletedBy?: StringNullableFilter<"MagicToken"> | string | null
    createdBy?: StringNullableFilter<"MagicToken"> | string | null
    createdAt?: DateTimeFilter<"MagicToken"> | Date | string
    updatedAt?: DateTimeFilter<"MagicToken"> | Date | string
  }

  export type PayrollUpsertWithWhereUniqueWithoutApproverInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutApproverInput, PayrollUncheckedUpdateWithoutApproverInput>
    create: XOR<PayrollCreateWithoutApproverInput, PayrollUncheckedCreateWithoutApproverInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutApproverInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutApproverInput, PayrollUncheckedUpdateWithoutApproverInput>
  }

  export type PayrollUpdateManyWithWhereWithoutApproverInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutApproverInput>
  }

  export type PayrollScalarWhereInput = {
    AND?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    OR?: PayrollScalarWhereInput[]
    NOT?: PayrollScalarWhereInput | PayrollScalarWhereInput[]
    id?: StringFilter<"Payroll"> | string
    runDate?: DateTimeFilter<"Payroll"> | Date | string
    payPeriodStart?: DateTimeFilter<"Payroll"> | Date | string
    payPeriodEnd?: DateTimeFilter<"Payroll"> | Date | string
    status?: EnumPayrollStatusFilter<"Payroll"> | $Enums.PayrollStatus
    totalGrossPay?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"Payroll"> | string | null
    approvedBy?: StringNullableFilter<"Payroll"> | string | null
    approvedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    processedBy?: StringNullableFilter<"Payroll"> | string | null
    processedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    tenantId?: StringNullableFilter<"Payroll"> | string | null
    isDeleted?: BoolFilter<"Payroll"> | boolean
    deletedAt?: DateTimeNullableFilter<"Payroll"> | Date | string | null
    deletedBy?: StringNullableFilter<"Payroll"> | string | null
    createdBy?: StringNullableFilter<"Payroll"> | string | null
    createdAt?: DateTimeFilter<"Payroll"> | Date | string
    updatedAt?: DateTimeFilter<"Payroll"> | Date | string
  }

  export type PayrollUpsertWithWhereUniqueWithoutProcessorInput = {
    where: PayrollWhereUniqueInput
    update: XOR<PayrollUpdateWithoutProcessorInput, PayrollUncheckedUpdateWithoutProcessorInput>
    create: XOR<PayrollCreateWithoutProcessorInput, PayrollUncheckedCreateWithoutProcessorInput>
  }

  export type PayrollUpdateWithWhereUniqueWithoutProcessorInput = {
    where: PayrollWhereUniqueInput
    data: XOR<PayrollUpdateWithoutProcessorInput, PayrollUncheckedUpdateWithoutProcessorInput>
  }

  export type PayrollUpdateManyWithWhereWithoutProcessorInput = {
    where: PayrollScalarWhereInput
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyWithoutProcessorInput>
  }

  export type PayrollEntryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollEntryWhereUniqueInput
    update: XOR<PayrollEntryUpdateWithoutEmployeeInput, PayrollEntryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PayrollEntryCreateWithoutEmployeeInput, PayrollEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollEntryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollEntryWhereUniqueInput
    data: XOR<PayrollEntryUpdateWithoutEmployeeInput, PayrollEntryUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollEntryUpdateManyWithWhereWithoutEmployeeInput = {
    where: PayrollEntryScalarWhereInput
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollEntryScalarWhereInput = {
    AND?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
    OR?: PayrollEntryScalarWhereInput[]
    NOT?: PayrollEntryScalarWhereInput | PayrollEntryScalarWhereInput[]
    id?: StringFilter<"PayrollEntry"> | string
    payrollId?: StringFilter<"PayrollEntry"> | string
    employeeId?: StringFilter<"PayrollEntry"> | string
    baseSalary?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    hoursWorked?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    allowances?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    otherDeductions?: DecimalNullableFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFilter<"PayrollEntry"> | Decimal | DecimalJsLike | number | string
    notes?: StringNullableFilter<"PayrollEntry"> | string | null
    tenantId?: StringNullableFilter<"PayrollEntry"> | string | null
    isDeleted?: BoolFilter<"PayrollEntry"> | boolean
    deletedAt?: DateTimeNullableFilter<"PayrollEntry"> | Date | string | null
    deletedBy?: StringNullableFilter<"PayrollEntry"> | string | null
    createdBy?: StringNullableFilter<"PayrollEntry"> | string | null
    createdAt?: DateTimeFilter<"PayrollEntry"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollEntry"> | Date | string
  }

  export type SalaryAdjustmentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryAdjustmentWhereUniqueInput
    update: XOR<SalaryAdjustmentUpdateWithoutEmployeeInput, SalaryAdjustmentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<SalaryAdjustmentCreateWithoutEmployeeInput, SalaryAdjustmentUncheckedCreateWithoutEmployeeInput>
  }

  export type SalaryAdjustmentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: SalaryAdjustmentWhereUniqueInput
    data: XOR<SalaryAdjustmentUpdateWithoutEmployeeInput, SalaryAdjustmentUncheckedUpdateWithoutEmployeeInput>
  }

  export type SalaryAdjustmentUpdateManyWithWhereWithoutEmployeeInput = {
    where: SalaryAdjustmentScalarWhereInput
    data: XOR<SalaryAdjustmentUpdateManyMutationInput, SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type SalaryAdjustmentScalarWhereInput = {
    AND?: SalaryAdjustmentScalarWhereInput | SalaryAdjustmentScalarWhereInput[]
    OR?: SalaryAdjustmentScalarWhereInput[]
    NOT?: SalaryAdjustmentScalarWhereInput | SalaryAdjustmentScalarWhereInput[]
    id?: StringFilter<"SalaryAdjustment"> | string
    employeeId?: StringFilter<"SalaryAdjustment"> | string
    adjustmentType?: EnumSalaryAdjustmentTypeFilter<"SalaryAdjustment"> | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFilter<"SalaryAdjustment"> | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFilter<"SalaryAdjustment"> | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFilter<"SalaryAdjustment"> | Date | string
    reason?: StringFilter<"SalaryAdjustment"> | string
    notes?: StringNullableFilter<"SalaryAdjustment"> | string | null
    approvedBy?: StringNullableFilter<"SalaryAdjustment"> | string | null
    approvedAt?: DateTimeNullableFilter<"SalaryAdjustment"> | Date | string | null
    tenantId?: StringNullableFilter<"SalaryAdjustment"> | string | null
    isDeleted?: BoolFilter<"SalaryAdjustment"> | boolean
    deletedAt?: DateTimeNullableFilter<"SalaryAdjustment"> | Date | string | null
    deletedBy?: StringNullableFilter<"SalaryAdjustment"> | string | null
    createdBy?: StringNullableFilter<"SalaryAdjustment"> | string | null
    createdAt?: DateTimeFilter<"SalaryAdjustment"> | Date | string
    updatedAt?: DateTimeFilter<"SalaryAdjustment"> | Date | string
  }

  export type SalaryAdjustmentUpsertWithWhereUniqueWithoutApproverInput = {
    where: SalaryAdjustmentWhereUniqueInput
    update: XOR<SalaryAdjustmentUpdateWithoutApproverInput, SalaryAdjustmentUncheckedUpdateWithoutApproverInput>
    create: XOR<SalaryAdjustmentCreateWithoutApproverInput, SalaryAdjustmentUncheckedCreateWithoutApproverInput>
  }

  export type SalaryAdjustmentUpdateWithWhereUniqueWithoutApproverInput = {
    where: SalaryAdjustmentWhereUniqueInput
    data: XOR<SalaryAdjustmentUpdateWithoutApproverInput, SalaryAdjustmentUncheckedUpdateWithoutApproverInput>
  }

  export type SalaryAdjustmentUpdateManyWithWhereWithoutApproverInput = {
    where: SalaryAdjustmentScalarWhereInput
    data: XOR<SalaryAdjustmentUpdateManyMutationInput, SalaryAdjustmentUncheckedUpdateManyWithoutApproverInput>
  }

  export type EmployeeExpenseUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeExpenseWhereUniqueInput
    update: XOR<EmployeeExpenseUpdateWithoutEmployeeInput, EmployeeExpenseUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeExpenseCreateWithoutEmployeeInput, EmployeeExpenseUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeExpenseUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeExpenseWhereUniqueInput
    data: XOR<EmployeeExpenseUpdateWithoutEmployeeInput, EmployeeExpenseUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeExpenseUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeExpenseScalarWhereInput
    data: XOR<EmployeeExpenseUpdateManyMutationInput, EmployeeExpenseUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeExpenseScalarWhereInput = {
    AND?: EmployeeExpenseScalarWhereInput | EmployeeExpenseScalarWhereInput[]
    OR?: EmployeeExpenseScalarWhereInput[]
    NOT?: EmployeeExpenseScalarWhereInput | EmployeeExpenseScalarWhereInput[]
    id?: StringFilter<"EmployeeExpense"> | string
    employeeId?: StringFilter<"EmployeeExpense"> | string
    description?: StringFilter<"EmployeeExpense"> | string
    amount?: DecimalFilter<"EmployeeExpense"> | Decimal | DecimalJsLike | number | string
    category?: StringFilter<"EmployeeExpense"> | string
    expenseDate?: DateTimeFilter<"EmployeeExpense"> | Date | string
    receiptUrl?: StringNullableFilter<"EmployeeExpense"> | string | null
    status?: EnumExpenseStatusFilter<"EmployeeExpense"> | $Enums.ExpenseStatus
    submittedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    reviewedBy?: StringNullableFilter<"EmployeeExpense"> | string | null
    reviewedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    reimbursedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    reimbursementTransactionId?: StringNullableFilter<"EmployeeExpense"> | string | null
    notes?: StringNullableFilter<"EmployeeExpense"> | string | null
    tenantId?: StringNullableFilter<"EmployeeExpense"> | string | null
    isDeleted?: BoolFilter<"EmployeeExpense"> | boolean
    deletedAt?: DateTimeNullableFilter<"EmployeeExpense"> | Date | string | null
    deletedBy?: StringNullableFilter<"EmployeeExpense"> | string | null
    createdBy?: StringNullableFilter<"EmployeeExpense"> | string | null
    createdAt?: DateTimeFilter<"EmployeeExpense"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeExpense"> | Date | string
  }

  export type EmployeeExpenseUpsertWithWhereUniqueWithoutReviewerInput = {
    where: EmployeeExpenseWhereUniqueInput
    update: XOR<EmployeeExpenseUpdateWithoutReviewerInput, EmployeeExpenseUncheckedUpdateWithoutReviewerInput>
    create: XOR<EmployeeExpenseCreateWithoutReviewerInput, EmployeeExpenseUncheckedCreateWithoutReviewerInput>
  }

  export type EmployeeExpenseUpdateWithWhereUniqueWithoutReviewerInput = {
    where: EmployeeExpenseWhereUniqueInput
    data: XOR<EmployeeExpenseUpdateWithoutReviewerInput, EmployeeExpenseUncheckedUpdateWithoutReviewerInput>
  }

  export type EmployeeExpenseUpdateManyWithWhereWithoutReviewerInput = {
    where: EmployeeExpenseScalarWhereInput
    data: XOR<EmployeeExpenseUpdateManyMutationInput, EmployeeExpenseUncheckedUpdateManyWithoutReviewerInput>
  }

  export type PTORequestUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PTORequestWhereUniqueInput
    update: XOR<PTORequestUpdateWithoutEmployeeInput, PTORequestUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PTORequestCreateWithoutEmployeeInput, PTORequestUncheckedCreateWithoutEmployeeInput>
  }

  export type PTORequestUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PTORequestWhereUniqueInput
    data: XOR<PTORequestUpdateWithoutEmployeeInput, PTORequestUncheckedUpdateWithoutEmployeeInput>
  }

  export type PTORequestUpdateManyWithWhereWithoutEmployeeInput = {
    where: PTORequestScalarWhereInput
    data: XOR<PTORequestUpdateManyMutationInput, PTORequestUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PTORequestScalarWhereInput = {
    AND?: PTORequestScalarWhereInput | PTORequestScalarWhereInput[]
    OR?: PTORequestScalarWhereInput[]
    NOT?: PTORequestScalarWhereInput | PTORequestScalarWhereInput[]
    id?: StringFilter<"PTORequest"> | string
    employeeId?: StringFilter<"PTORequest"> | string
    startDate?: DateTimeFilter<"PTORequest"> | Date | string
    endDate?: DateTimeFilter<"PTORequest"> | Date | string
    totalDays?: DecimalFilter<"PTORequest"> | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFilter<"PTORequest"> | $Enums.PTOStatus
    reason?: StringNullableFilter<"PTORequest"> | string | null
    submittedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    approvedBy?: StringNullableFilter<"PTORequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    rejectedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    tenantId?: StringNullableFilter<"PTORequest"> | string | null
    isDeleted?: BoolFilter<"PTORequest"> | boolean
    deletedAt?: DateTimeNullableFilter<"PTORequest"> | Date | string | null
    deletedBy?: StringNullableFilter<"PTORequest"> | string | null
    createdBy?: StringNullableFilter<"PTORequest"> | string | null
    createdAt?: DateTimeFilter<"PTORequest"> | Date | string
    updatedAt?: DateTimeFilter<"PTORequest"> | Date | string
  }

  export type PTORequestUpsertWithWhereUniqueWithoutApproverInput = {
    where: PTORequestWhereUniqueInput
    update: XOR<PTORequestUpdateWithoutApproverInput, PTORequestUncheckedUpdateWithoutApproverInput>
    create: XOR<PTORequestCreateWithoutApproverInput, PTORequestUncheckedCreateWithoutApproverInput>
  }

  export type PTORequestUpdateWithWhereUniqueWithoutApproverInput = {
    where: PTORequestWhereUniqueInput
    data: XOR<PTORequestUpdateWithoutApproverInput, PTORequestUncheckedUpdateWithoutApproverInput>
  }

  export type PTORequestUpdateManyWithWhereWithoutApproverInput = {
    where: PTORequestScalarWhereInput
    data: XOR<PTORequestUpdateManyMutationInput, PTORequestUncheckedUpdateManyWithoutApproverInput>
  }

  export type PTOBalanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PTOBalanceWhereUniqueInput
    update: XOR<PTOBalanceUpdateWithoutEmployeeInput, PTOBalanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PTOBalanceCreateWithoutEmployeeInput, PTOBalanceUncheckedCreateWithoutEmployeeInput>
  }

  export type PTOBalanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PTOBalanceWhereUniqueInput
    data: XOR<PTOBalanceUpdateWithoutEmployeeInput, PTOBalanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type PTOBalanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: PTOBalanceScalarWhereInput
    data: XOR<PTOBalanceUpdateManyMutationInput, PTOBalanceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PTOBalanceScalarWhereInput = {
    AND?: PTOBalanceScalarWhereInput | PTOBalanceScalarWhereInput[]
    OR?: PTOBalanceScalarWhereInput[]
    NOT?: PTOBalanceScalarWhereInput | PTOBalanceScalarWhereInput[]
    id?: StringFilter<"PTOBalance"> | string
    employeeId?: StringFilter<"PTOBalance"> | string
    year?: IntFilter<"PTOBalance"> | number
    totalDays?: DecimalFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalFilter<"PTOBalance"> | Decimal | DecimalJsLike | number | string
    tenantId?: StringNullableFilter<"PTOBalance"> | string | null
    isDeleted?: BoolFilter<"PTOBalance"> | boolean
    deletedAt?: DateTimeNullableFilter<"PTOBalance"> | Date | string | null
    deletedBy?: StringNullableFilter<"PTOBalance"> | string | null
    createdBy?: StringNullableFilter<"PTOBalance"> | string | null
    createdAt?: DateTimeFilter<"PTOBalance"> | Date | string
    updatedAt?: DateTimeFilter<"PTOBalance"> | Date | string
  }

  export type UserCreateWithoutMagicTokensInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutMagicTokensInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutMagicTokensInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMagicTokensInput, UserUncheckedCreateWithoutMagicTokensInput>
  }

  export type UserUpsertWithoutMagicTokensInput = {
    update: XOR<UserUpdateWithoutMagicTokensInput, UserUncheckedUpdateWithoutMagicTokensInput>
    create: XOR<UserCreateWithoutMagicTokensInput, UserUncheckedCreateWithoutMagicTokensInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMagicTokensInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMagicTokensInput, UserUncheckedUpdateWithoutMagicTokensInput>
  }

  export type UserUpdateWithoutMagicTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutMagicTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserCreateWithoutAuditTrailsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutAuditTrailsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutAuditTrailsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
  }

  export type UserUpsertWithoutAuditTrailsInput = {
    update: XOR<UserUpdateWithoutAuditTrailsInput, UserUncheckedUpdateWithoutAuditTrailsInput>
    create: XOR<UserCreateWithoutAuditTrailsInput, UserUncheckedCreateWithoutAuditTrailsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditTrailsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditTrailsInput, UserUncheckedUpdateWithoutAuditTrailsInput>
  }

  export type UserUpdateWithoutAuditTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditTrailsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserCreateWithoutNotificationTemplatesCreatedInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutNotificationTemplatesCreatedInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutNotificationTemplatesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationTemplatesCreatedInput, UserUncheckedCreateWithoutNotificationTemplatesCreatedInput>
  }

  export type NotificationRuleCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutNotificationRulesCreatedInput
    notifications?: NotificationCreateNestedManyWithoutRuleInput
  }

  export type NotificationRuleUncheckedCreateWithoutTemplateInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    createdBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutRuleInput
  }

  export type NotificationRuleCreateOrConnectWithoutTemplateInput = {
    where: NotificationRuleWhereUniqueInput
    create: XOR<NotificationRuleCreateWithoutTemplateInput, NotificationRuleUncheckedCreateWithoutTemplateInput>
  }

  export type NotificationRuleCreateManyTemplateInputEnvelope = {
    data: NotificationRuleCreateManyTemplateInput | NotificationRuleCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutTemplateInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
    rule?: NotificationRuleCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutTemplateInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    recipientId: string
    ruleId?: string | null
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutTemplateInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput>
  }

  export type NotificationCreateManyTemplateInputEnvelope = {
    data: NotificationCreateManyTemplateInput | NotificationCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutNotificationTemplatesCreatedInput = {
    update: XOR<UserUpdateWithoutNotificationTemplatesCreatedInput, UserUncheckedUpdateWithoutNotificationTemplatesCreatedInput>
    create: XOR<UserCreateWithoutNotificationTemplatesCreatedInput, UserUncheckedCreateWithoutNotificationTemplatesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationTemplatesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationTemplatesCreatedInput, UserUncheckedUpdateWithoutNotificationTemplatesCreatedInput>
  }

  export type UserUpdateWithoutNotificationTemplatesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationTemplatesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type NotificationRuleUpsertWithWhereUniqueWithoutTemplateInput = {
    where: NotificationRuleWhereUniqueInput
    update: XOR<NotificationRuleUpdateWithoutTemplateInput, NotificationRuleUncheckedUpdateWithoutTemplateInput>
    create: XOR<NotificationRuleCreateWithoutTemplateInput, NotificationRuleUncheckedCreateWithoutTemplateInput>
  }

  export type NotificationRuleUpdateWithWhereUniqueWithoutTemplateInput = {
    where: NotificationRuleWhereUniqueInput
    data: XOR<NotificationRuleUpdateWithoutTemplateInput, NotificationRuleUncheckedUpdateWithoutTemplateInput>
  }

  export type NotificationRuleUpdateManyWithWhereWithoutTemplateInput = {
    where: NotificationRuleScalarWhereInput
    data: XOR<NotificationRuleUpdateManyMutationInput, NotificationRuleUncheckedUpdateManyWithoutTemplateInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutTemplateInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutTemplateInput, NotificationUncheckedUpdateWithoutTemplateInput>
    create: XOR<NotificationCreateWithoutTemplateInput, NotificationUncheckedCreateWithoutTemplateInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutTemplateInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutTemplateInput, NotificationUncheckedUpdateWithoutTemplateInput>
  }

  export type NotificationUpdateManyWithWhereWithoutTemplateInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutTemplateInput>
  }

  export type NotificationTemplateCreateWithoutRulesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    subject?: string | null
    content: string
    variables?: NotificationTemplateCreatevariablesInput | string[]
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutNotificationTemplatesCreatedInput
    notifications?: NotificationCreateNestedManyWithoutTemplateInput
  }

  export type NotificationTemplateUncheckedCreateWithoutRulesInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    subject?: string | null
    content: string
    variables?: NotificationTemplateCreatevariablesInput | string[]
    isActive?: boolean
    createdBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notifications?: NotificationUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type NotificationTemplateCreateOrConnectWithoutRulesInput = {
    where: NotificationTemplateWhereUniqueInput
    create: XOR<NotificationTemplateCreateWithoutRulesInput, NotificationTemplateUncheckedCreateWithoutRulesInput>
  }

  export type UserCreateWithoutNotificationRulesCreatedInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutNotificationRulesCreatedInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutNotificationRulesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationRulesCreatedInput, UserUncheckedCreateWithoutNotificationRulesCreatedInput>
  }

  export type NotificationCreateWithoutRuleInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    recipient: UserCreateNestedOneWithoutNotificationsInput
    template?: NotificationTemplateCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateWithoutRuleInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    recipientId: string
    templateId?: string | null
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRuleInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRuleInput, NotificationUncheckedCreateWithoutRuleInput>
  }

  export type NotificationCreateManyRuleInputEnvelope = {
    data: NotificationCreateManyRuleInput | NotificationCreateManyRuleInput[]
    skipDuplicates?: boolean
  }

  export type NotificationTemplateUpsertWithoutRulesInput = {
    update: XOR<NotificationTemplateUpdateWithoutRulesInput, NotificationTemplateUncheckedUpdateWithoutRulesInput>
    create: XOR<NotificationTemplateCreateWithoutRulesInput, NotificationTemplateUncheckedCreateWithoutRulesInput>
    where?: NotificationTemplateWhereInput
  }

  export type NotificationTemplateUpdateToOneWithWhereWithoutRulesInput = {
    where?: NotificationTemplateWhereInput
    data: XOR<NotificationTemplateUpdateWithoutRulesInput, NotificationTemplateUncheckedUpdateWithoutRulesInput>
  }

  export type NotificationTemplateUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutNotificationTemplatesCreatedNestedInput
    notifications?: NotificationUpdateManyWithoutTemplateNestedInput
  }

  export type NotificationTemplateUncheckedUpdateWithoutRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type UserUpsertWithoutNotificationRulesCreatedInput = {
    update: XOR<UserUpdateWithoutNotificationRulesCreatedInput, UserUncheckedUpdateWithoutNotificationRulesCreatedInput>
    create: XOR<UserCreateWithoutNotificationRulesCreatedInput, UserUncheckedCreateWithoutNotificationRulesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationRulesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationRulesCreatedInput, UserUncheckedUpdateWithoutNotificationRulesCreatedInput>
  }

  export type UserUpdateWithoutNotificationRulesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationRulesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type NotificationUpsertWithWhereUniqueWithoutRuleInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutRuleInput, NotificationUncheckedUpdateWithoutRuleInput>
    create: XOR<NotificationCreateWithoutRuleInput, NotificationUncheckedCreateWithoutRuleInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutRuleInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutRuleInput, NotificationUncheckedUpdateWithoutRuleInput>
  }

  export type NotificationUpdateManyWithWhereWithoutRuleInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutRuleInput>
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type NotificationTemplateCreateWithoutNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    subject?: string | null
    content: string
    variables?: NotificationTemplateCreatevariablesInput | string[]
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator: UserCreateNestedOneWithoutNotificationTemplatesCreatedInput
    rules?: NotificationRuleCreateNestedManyWithoutTemplateInput
  }

  export type NotificationTemplateUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    subject?: string | null
    content: string
    variables?: NotificationTemplateCreatevariablesInput | string[]
    isActive?: boolean
    createdBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    rules?: NotificationRuleUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type NotificationTemplateCreateOrConnectWithoutNotificationsInput = {
    where: NotificationTemplateWhereUniqueInput
    create: XOR<NotificationTemplateCreateWithoutNotificationsInput, NotificationTemplateUncheckedCreateWithoutNotificationsInput>
  }

  export type NotificationRuleCreateWithoutNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    template: NotificationTemplateCreateNestedOneWithoutRulesInput
    creator: UserCreateNestedOneWithoutNotificationRulesCreatedInput
  }

  export type NotificationRuleUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    templateId: string
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    createdBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationRuleCreateOrConnectWithoutNotificationsInput = {
    where: NotificationRuleWhereUniqueInput
    create: XOR<NotificationRuleCreateWithoutNotificationsInput, NotificationRuleUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type NotificationTemplateUpsertWithoutNotificationsInput = {
    update: XOR<NotificationTemplateUpdateWithoutNotificationsInput, NotificationTemplateUncheckedUpdateWithoutNotificationsInput>
    create: XOR<NotificationTemplateCreateWithoutNotificationsInput, NotificationTemplateUncheckedCreateWithoutNotificationsInput>
    where?: NotificationTemplateWhereInput
  }

  export type NotificationTemplateUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: NotificationTemplateWhereInput
    data: XOR<NotificationTemplateUpdateWithoutNotificationsInput, NotificationTemplateUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationTemplateUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutNotificationTemplatesCreatedNestedInput
    rules?: NotificationRuleUpdateManyWithoutTemplateNestedInput
  }

  export type NotificationTemplateUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: NotificationRuleUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type NotificationRuleUpsertWithoutNotificationsInput = {
    update: XOR<NotificationRuleUpdateWithoutNotificationsInput, NotificationRuleUncheckedUpdateWithoutNotificationsInput>
    create: XOR<NotificationRuleCreateWithoutNotificationsInput, NotificationRuleUncheckedCreateWithoutNotificationsInput>
    where?: NotificationRuleWhereInput
  }

  export type NotificationRuleUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: NotificationRuleWhereInput
    data: XOR<NotificationRuleUpdateWithoutNotificationsInput, NotificationRuleUncheckedUpdateWithoutNotificationsInput>
  }

  export type NotificationRuleUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: NotificationTemplateUpdateOneRequiredWithoutRulesNestedInput
    creator?: UserUpdateOneRequiredWithoutNotificationRulesCreatedNestedInput
  }

  export type NotificationRuleUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutPayrollsApprovedInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutPayrollsApprovedInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutPayrollsApprovedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPayrollsApprovedInput, UserUncheckedCreateWithoutPayrollsApprovedInput>
  }

  export type UserCreateWithoutPayrollsProcessedInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutPayrollsProcessedInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutPayrollsProcessedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPayrollsProcessedInput, UserUncheckedCreateWithoutPayrollsProcessedInput>
  }

  export type PayrollEntryCreateWithoutPayrollInput = {
    id?: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hoursWorked?: Decimal | DecimalJsLike | number | string | null
    overtimeHours?: Decimal | DecimalJsLike | number | string | null
    bonusAmount?: Decimal | DecimalJsLike | number | string | null
    allowances?: Decimal | DecimalJsLike | number | string | null
    grossPay: Decimal | DecimalJsLike | number | string
    taxDeductions: Decimal | DecimalJsLike | number | string
    socialSecurity: Decimal | DecimalJsLike | number | string
    otherDeductions?: Decimal | DecimalJsLike | number | string | null
    netPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: UserCreateNestedOneWithoutPayrollEntriesInput
  }

  export type PayrollEntryUncheckedCreateWithoutPayrollInput = {
    id?: string
    employeeId: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hoursWorked?: Decimal | DecimalJsLike | number | string | null
    overtimeHours?: Decimal | DecimalJsLike | number | string | null
    bonusAmount?: Decimal | DecimalJsLike | number | string | null
    allowances?: Decimal | DecimalJsLike | number | string | null
    grossPay: Decimal | DecimalJsLike | number | string
    taxDeductions: Decimal | DecimalJsLike | number | string
    socialSecurity: Decimal | DecimalJsLike | number | string
    otherDeductions?: Decimal | DecimalJsLike | number | string | null
    netPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryCreateOrConnectWithoutPayrollInput = {
    where: PayrollEntryWhereUniqueInput
    create: XOR<PayrollEntryCreateWithoutPayrollInput, PayrollEntryUncheckedCreateWithoutPayrollInput>
  }

  export type PayrollEntryCreateManyPayrollInputEnvelope = {
    data: PayrollEntryCreateManyPayrollInput | PayrollEntryCreateManyPayrollInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutPayrollInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: BankAccountCreateNestedOneWithoutTransactionsInput
    category?: TransactionCategoryCreateNestedOneWithoutTransactionsInput
    creator?: UserCreateNestedOneWithoutTransactionsInput
    expenseReimbursement?: EmployeeExpenseCreateNestedOneWithoutReimbursementTransactionInput
  }

  export type TransactionUncheckedCreateWithoutPayrollInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    accountId: string
    categoryId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    expenseReimbursement?: EmployeeExpenseUncheckedCreateNestedOneWithoutReimbursementTransactionInput
  }

  export type TransactionCreateOrConnectWithoutPayrollInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutPayrollInput, TransactionUncheckedCreateWithoutPayrollInput>
  }

  export type TransactionCreateManyPayrollInputEnvelope = {
    data: TransactionCreateManyPayrollInput | TransactionCreateManyPayrollInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPayrollsApprovedInput = {
    update: XOR<UserUpdateWithoutPayrollsApprovedInput, UserUncheckedUpdateWithoutPayrollsApprovedInput>
    create: XOR<UserCreateWithoutPayrollsApprovedInput, UserUncheckedCreateWithoutPayrollsApprovedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPayrollsApprovedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPayrollsApprovedInput, UserUncheckedUpdateWithoutPayrollsApprovedInput>
  }

  export type UserUpdateWithoutPayrollsApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutPayrollsApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutPayrollsProcessedInput = {
    update: XOR<UserUpdateWithoutPayrollsProcessedInput, UserUncheckedUpdateWithoutPayrollsProcessedInput>
    create: XOR<UserCreateWithoutPayrollsProcessedInput, UserUncheckedCreateWithoutPayrollsProcessedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPayrollsProcessedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPayrollsProcessedInput, UserUncheckedUpdateWithoutPayrollsProcessedInput>
  }

  export type UserUpdateWithoutPayrollsProcessedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutPayrollsProcessedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type PayrollEntryUpsertWithWhereUniqueWithoutPayrollInput = {
    where: PayrollEntryWhereUniqueInput
    update: XOR<PayrollEntryUpdateWithoutPayrollInput, PayrollEntryUncheckedUpdateWithoutPayrollInput>
    create: XOR<PayrollEntryCreateWithoutPayrollInput, PayrollEntryUncheckedCreateWithoutPayrollInput>
  }

  export type PayrollEntryUpdateWithWhereUniqueWithoutPayrollInput = {
    where: PayrollEntryWhereUniqueInput
    data: XOR<PayrollEntryUpdateWithoutPayrollInput, PayrollEntryUncheckedUpdateWithoutPayrollInput>
  }

  export type PayrollEntryUpdateManyWithWhereWithoutPayrollInput = {
    where: PayrollEntryScalarWhereInput
    data: XOR<PayrollEntryUpdateManyMutationInput, PayrollEntryUncheckedUpdateManyWithoutPayrollInput>
  }

  export type TransactionUpsertWithWhereUniqueWithoutPayrollInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutPayrollInput, TransactionUncheckedUpdateWithoutPayrollInput>
    create: XOR<TransactionCreateWithoutPayrollInput, TransactionUncheckedCreateWithoutPayrollInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutPayrollInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutPayrollInput, TransactionUncheckedUpdateWithoutPayrollInput>
  }

  export type TransactionUpdateManyWithWhereWithoutPayrollInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutPayrollInput>
  }

  export type PayrollCreateWithoutPayrollEntriesInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedAt?: Date | string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    approver?: UserCreateNestedOneWithoutPayrollsApprovedInput
    processor?: UserCreateNestedOneWithoutPayrollsProcessedInput
    transactions?: TransactionCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUncheckedCreateWithoutPayrollEntriesInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: TransactionUncheckedCreateNestedManyWithoutPayrollInput
  }

  export type PayrollCreateOrConnectWithoutPayrollEntriesInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutPayrollEntriesInput, PayrollUncheckedCreateWithoutPayrollEntriesInput>
  }

  export type UserCreateWithoutPayrollEntriesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutPayrollEntriesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutPayrollEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPayrollEntriesInput, UserUncheckedCreateWithoutPayrollEntriesInput>
  }

  export type PayrollUpsertWithoutPayrollEntriesInput = {
    update: XOR<PayrollUpdateWithoutPayrollEntriesInput, PayrollUncheckedUpdateWithoutPayrollEntriesInput>
    create: XOR<PayrollCreateWithoutPayrollEntriesInput, PayrollUncheckedCreateWithoutPayrollEntriesInput>
    where?: PayrollWhereInput
  }

  export type PayrollUpdateToOneWithWhereWithoutPayrollEntriesInput = {
    where?: PayrollWhereInput
    data: XOR<PayrollUpdateWithoutPayrollEntriesInput, PayrollUncheckedUpdateWithoutPayrollEntriesInput>
  }

  export type PayrollUpdateWithoutPayrollEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutPayrollsApprovedNestedInput
    processor?: UserUpdateOneWithoutPayrollsProcessedNestedInput
    transactions?: TransactionUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateWithoutPayrollEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: TransactionUncheckedUpdateManyWithoutPayrollNestedInput
  }

  export type UserUpsertWithoutPayrollEntriesInput = {
    update: XOR<UserUpdateWithoutPayrollEntriesInput, UserUncheckedUpdateWithoutPayrollEntriesInput>
    create: XOR<UserCreateWithoutPayrollEntriesInput, UserUncheckedCreateWithoutPayrollEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPayrollEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPayrollEntriesInput, UserUncheckedUpdateWithoutPayrollEntriesInput>
  }

  export type UserUpdateWithoutPayrollEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutPayrollEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserCreateWithoutSalaryAdjustmentsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutSalaryAdjustmentsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutSalaryAdjustmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalaryAdjustmentsInput, UserUncheckedCreateWithoutSalaryAdjustmentsInput>
  }

  export type UserCreateWithoutSalaryAdjustmentsApprovedInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutSalaryAdjustmentsApprovedInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutSalaryAdjustmentsApprovedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSalaryAdjustmentsApprovedInput, UserUncheckedCreateWithoutSalaryAdjustmentsApprovedInput>
  }

  export type UserUpsertWithoutSalaryAdjustmentsInput = {
    update: XOR<UserUpdateWithoutSalaryAdjustmentsInput, UserUncheckedUpdateWithoutSalaryAdjustmentsInput>
    create: XOR<UserCreateWithoutSalaryAdjustmentsInput, UserUncheckedCreateWithoutSalaryAdjustmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalaryAdjustmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalaryAdjustmentsInput, UserUncheckedUpdateWithoutSalaryAdjustmentsInput>
  }

  export type UserUpdateWithoutSalaryAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutSalaryAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutSalaryAdjustmentsApprovedInput = {
    update: XOR<UserUpdateWithoutSalaryAdjustmentsApprovedInput, UserUncheckedUpdateWithoutSalaryAdjustmentsApprovedInput>
    create: XOR<UserCreateWithoutSalaryAdjustmentsApprovedInput, UserUncheckedCreateWithoutSalaryAdjustmentsApprovedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSalaryAdjustmentsApprovedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSalaryAdjustmentsApprovedInput, UserUncheckedUpdateWithoutSalaryAdjustmentsApprovedInput>
  }

  export type UserUpdateWithoutSalaryAdjustmentsApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutSalaryAdjustmentsApprovedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserCreateWithoutEmployeeExpensesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutEmployeeExpensesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutEmployeeExpensesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeExpensesInput, UserUncheckedCreateWithoutEmployeeExpensesInput>
  }

  export type UserCreateWithoutExpenseReviewsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutExpenseReviewsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutExpenseReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutExpenseReviewsInput, UserUncheckedCreateWithoutExpenseReviewsInput>
  }

  export type TransactionCreateWithoutExpenseReimbursementInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: BankAccountCreateNestedOneWithoutTransactionsInput
    category?: TransactionCategoryCreateNestedOneWithoutTransactionsInput
    creator?: UserCreateNestedOneWithoutTransactionsInput
    payroll?: PayrollCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateWithoutExpenseReimbursementInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    accountId: string
    categoryId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollId?: string | null
  }

  export type TransactionCreateOrConnectWithoutExpenseReimbursementInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutExpenseReimbursementInput, TransactionUncheckedCreateWithoutExpenseReimbursementInput>
  }

  export type UserUpsertWithoutEmployeeExpensesInput = {
    update: XOR<UserUpdateWithoutEmployeeExpensesInput, UserUncheckedUpdateWithoutEmployeeExpensesInput>
    create: XOR<UserCreateWithoutEmployeeExpensesInput, UserUncheckedCreateWithoutEmployeeExpensesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeExpensesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeExpensesInput, UserUncheckedUpdateWithoutEmployeeExpensesInput>
  }

  export type UserUpdateWithoutEmployeeExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeExpensesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutExpenseReviewsInput = {
    update: XOR<UserUpdateWithoutExpenseReviewsInput, UserUncheckedUpdateWithoutExpenseReviewsInput>
    create: XOR<UserCreateWithoutExpenseReviewsInput, UserUncheckedCreateWithoutExpenseReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutExpenseReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutExpenseReviewsInput, UserUncheckedUpdateWithoutExpenseReviewsInput>
  }

  export type UserUpdateWithoutExpenseReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutExpenseReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type TransactionUpsertWithoutExpenseReimbursementInput = {
    update: XOR<TransactionUpdateWithoutExpenseReimbursementInput, TransactionUncheckedUpdateWithoutExpenseReimbursementInput>
    create: XOR<TransactionCreateWithoutExpenseReimbursementInput, TransactionUncheckedCreateWithoutExpenseReimbursementInput>
    where?: TransactionWhereInput
  }

  export type TransactionUpdateToOneWithWhereWithoutExpenseReimbursementInput = {
    where?: TransactionWhereInput
    data: XOR<TransactionUpdateWithoutExpenseReimbursementInput, TransactionUncheckedUpdateWithoutExpenseReimbursementInput>
  }

  export type TransactionUpdateWithoutExpenseReimbursementInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: BankAccountUpdateOneRequiredWithoutTransactionsNestedInput
    category?: TransactionCategoryUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneWithoutTransactionsNestedInput
    payroll?: PayrollUpdateOneWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateWithoutExpenseReimbursementInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserCreateWithoutPtoRequestsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutPtoRequestsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutPtoRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPtoRequestsInput, UserUncheckedCreateWithoutPtoRequestsInput>
  }

  export type UserCreateWithoutPtoApprovalsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoBalances?: PTOBalanceCreateNestedManyWithoutEmployeeInput
  }

  export type UserUncheckedCreateWithoutPtoApprovalsInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoBalances?: PTOBalanceUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type UserCreateOrConnectWithoutPtoApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPtoApprovalsInput, UserUncheckedCreateWithoutPtoApprovalsInput>
  }

  export type UserUpsertWithoutPtoRequestsInput = {
    update: XOR<UserUpdateWithoutPtoRequestsInput, UserUncheckedUpdateWithoutPtoRequestsInput>
    create: XOR<UserCreateWithoutPtoRequestsInput, UserUncheckedCreateWithoutPtoRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPtoRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPtoRequestsInput, UserUncheckedUpdateWithoutPtoRequestsInput>
  }

  export type UserUpdateWithoutPtoRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutPtoRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutPtoApprovalsInput = {
    update: XOR<UserUpdateWithoutPtoApprovalsInput, UserUncheckedUpdateWithoutPtoApprovalsInput>
    create: XOR<UserCreateWithoutPtoApprovalsInput, UserUncheckedCreateWithoutPtoApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPtoApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPtoApprovalsInput, UserUncheckedUpdateWithoutPtoApprovalsInput>
  }

  export type UserUpdateWithoutPtoApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutPtoApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserCreateWithoutPtoBalancesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    role: RoleCreateNestedOneWithoutUsersInput
    tasks?: TaskCreateNestedManyWithoutAssigneeInput
    documents?: DocumentCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionCreateNestedManyWithoutAuthorInput
    sales?: SaleCreateNestedManyWithoutSellerInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleCreateNestedManyWithoutCreatorInput
    notifications?: NotificationCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestCreateNestedManyWithoutApproverInput
  }

  export type UserUncheckedCreateWithoutPtoBalancesInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    roleId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: TaskUncheckedCreateNestedManyWithoutAssigneeInput
    documents?: DocumentUncheckedCreateNestedManyWithoutAuthorInput
    documentRevisions?: DocumentRevisionUncheckedCreateNestedManyWithoutAuthorInput
    sales?: SaleUncheckedCreateNestedManyWithoutSellerInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    auditTrails?: AuditTrailUncheckedCreateNestedManyWithoutUserInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedCreateNestedManyWithoutCreatorInput
    notificationRulesCreated?: NotificationRuleUncheckedCreateNestedManyWithoutCreatorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutRecipientInput
    magicTokens?: MagicTokenUncheckedCreateNestedManyWithoutUserInput
    payrollsApproved?: PayrollUncheckedCreateNestedManyWithoutApproverInput
    payrollsProcessed?: PayrollUncheckedCreateNestedManyWithoutProcessorInput
    payrollEntries?: PayrollEntryUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustments?: SalaryAdjustmentUncheckedCreateNestedManyWithoutEmployeeInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedCreateNestedManyWithoutApproverInput
    employeeExpenses?: EmployeeExpenseUncheckedCreateNestedManyWithoutEmployeeInput
    expenseReviews?: EmployeeExpenseUncheckedCreateNestedManyWithoutReviewerInput
    ptoRequests?: PTORequestUncheckedCreateNestedManyWithoutEmployeeInput
    ptoApprovals?: PTORequestUncheckedCreateNestedManyWithoutApproverInput
  }

  export type UserCreateOrConnectWithoutPtoBalancesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPtoBalancesInput, UserUncheckedCreateWithoutPtoBalancesInput>
  }

  export type UserUpsertWithoutPtoBalancesInput = {
    update: XOR<UserUpdateWithoutPtoBalancesInput, UserUncheckedUpdateWithoutPtoBalancesInput>
    create: XOR<UserCreateWithoutPtoBalancesInput, UserUncheckedCreateWithoutPtoBalancesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPtoBalancesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPtoBalancesInput, UserUncheckedUpdateWithoutPtoBalancesInput>
  }

  export type UserUpdateWithoutPtoBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: RoleUpdateOneRequiredWithoutUsersNestedInput
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
  }

  export type UserUncheckedUpdateWithoutPtoBalancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    roleId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
  }

  export type UserCreateManyRoleInput = {
    id?: string
    email: string
    username: string
    firstName: string
    lastName: string
    password: string
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUpdateManyWithoutAuthorNestedInput
    sales?: SaleUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: TaskUncheckedUpdateManyWithoutAssigneeNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutAuthorNestedInput
    documentRevisions?: DocumentRevisionUncheckedUpdateManyWithoutAuthorNestedInput
    sales?: SaleUncheckedUpdateManyWithoutSellerNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    auditTrails?: AuditTrailUncheckedUpdateManyWithoutUserNestedInput
    notificationTemplatesCreated?: NotificationTemplateUncheckedUpdateManyWithoutCreatorNestedInput
    notificationRulesCreated?: NotificationRuleUncheckedUpdateManyWithoutCreatorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutRecipientNestedInput
    magicTokens?: MagicTokenUncheckedUpdateManyWithoutUserNestedInput
    payrollsApproved?: PayrollUncheckedUpdateManyWithoutApproverNestedInput
    payrollsProcessed?: PayrollUncheckedUpdateManyWithoutProcessorNestedInput
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustments?: SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeNestedInput
    salaryAdjustmentsApproved?: SalaryAdjustmentUncheckedUpdateManyWithoutApproverNestedInput
    employeeExpenses?: EmployeeExpenseUncheckedUpdateManyWithoutEmployeeNestedInput
    expenseReviews?: EmployeeExpenseUncheckedUpdateManyWithoutReviewerNestedInput
    ptoRequests?: PTORequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ptoApprovals?: PTORequestUncheckedUpdateManyWithoutApproverNestedInput
    ptoBalances?: PTOBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUncheckedUpdateManyWithoutRoleInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskCreateManyProjectInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    assigneeId?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    assigneeId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateManyParentInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    authorId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
  }

  export type DocumentRevisionCreateManyDocumentInput = {
    id?: string
    version: number
    title: string
    content: string
    summary?: string | null
    changeLog?: string | null
    authorId: string
    tenantId?: string | null
    createdAt?: Date | string
  }

  export type DocumentUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: DocumentUpdateManyWithoutParentNestedInput
    author?: UserUpdateOneRequiredWithoutDocumentsNestedInput
    revisions?: DocumentRevisionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: DocumentUncheckedUpdateManyWithoutParentNestedInput
    revisions?: DocumentRevisionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    authorId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentRevisionUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutDocumentRevisionsNestedInput
  }

  export type DocumentRevisionUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRevisionUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    authorId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleCreateManyProductInput = {
    id?: string
    quantity: number
    total: number
    soldBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type SaleUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    seller?: UserUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    soldBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    soldBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyAccountInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    categoryId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollId?: string | null
  }

  export type BankBalanceCreateManyAccountInput = {
    id?: string
    balanceDate: Date | string
    openingBalance?: number
    closingBalance?: number
    totalIncome?: number
    totalExpenses?: number
    transactionCount?: number
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: TransactionCategoryUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneWithoutTransactionsNestedInput
    payroll?: PayrollUpdateOneWithoutTransactionsNestedInput
    expenseReimbursement?: EmployeeExpenseUpdateOneWithoutReimbursementTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseReimbursement?: EmployeeExpenseUncheckedUpdateOneWithoutReimbursementTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BankBalanceUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    balanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: FloatFieldUpdateOperationsInput | number
    closingBalance?: FloatFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankBalanceUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    balanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: FloatFieldUpdateOperationsInput | number
    closingBalance?: FloatFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankBalanceUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    balanceDate?: DateTimeFieldUpdateOperationsInput | Date | string
    openingBalance?: FloatFieldUpdateOperationsInput | number
    closingBalance?: FloatFieldUpdateOperationsInput | number
    totalIncome?: FloatFieldUpdateOperationsInput | number
    totalExpenses?: FloatFieldUpdateOperationsInput | number
    transactionCount?: IntFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyCategoryInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    accountId: string
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollId?: string | null
  }

  export type TransactionUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: BankAccountUpdateOneRequiredWithoutTransactionsNestedInput
    creator?: UserUpdateOneWithoutTransactionsNestedInput
    payroll?: PayrollUpdateOneWithoutTransactionsNestedInput
    expenseReimbursement?: EmployeeExpenseUpdateOneWithoutReimbursementTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseReimbursement?: EmployeeExpenseUncheckedUpdateOneWithoutReimbursementTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TaskCreateManyAssigneeInput = {
    id?: string
    title: string
    description?: string | null
    status?: $Enums.TaskStatus
    projectId: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyAuthorInput = {
    id?: string
    title: string
    content: string
    slug: string
    summary?: string | null
    type: $Enums.DocumentType
    status?: $Enums.DocumentStatus
    tags?: DocumentCreatetagsInput | string[]
    parentId?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    publishedAt?: Date | string | null
    viewCount?: number
    lastViewedAt?: Date | string | null
  }

  export type DocumentRevisionCreateManyAuthorInput = {
    id?: string
    documentId: string
    version: number
    title: string
    content: string
    summary?: string | null
    changeLog?: string | null
    tenantId?: string | null
    createdAt?: Date | string
  }

  export type SaleCreateManySellerInput = {
    id?: string
    productId: string
    quantity: number
    total: number
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type TransactionCreateManyCreatorInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    accountId: string
    categoryId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payrollId?: string | null
  }

  export type AuditTrailCreateManyUserInput = {
    id?: string
    tableName: string
    recordId: string
    operation: $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: string | null
    timestamp?: Date | string
    ipAddress?: string | null
    userAgent?: string | null
  }

  export type NotificationTemplateCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    type: $Enums.NotificationType
    subject?: string | null
    content: string
    variables?: NotificationTemplateCreatevariablesInput | string[]
    isActive?: boolean
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationRuleCreateManyCreatorInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    templateId: string
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyRecipientInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    templateId?: string | null
    ruleId?: string | null
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MagicTokenCreateManyUserInput = {
    id?: string
    purpose: string
    tokenHash: string
    expiresAt: Date | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateManyApproverInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedAt?: Date | string | null
    processedBy?: string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollCreateManyProcessorInput = {
    id?: string
    runDate: Date | string
    payPeriodStart: Date | string
    payPeriodEnd: Date | string
    status?: $Enums.PayrollStatus
    totalGrossPay: Decimal | DecimalJsLike | number | string
    totalDeductions: Decimal | DecimalJsLike | number | string
    totalNetPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    processedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryCreateManyEmployeeInput = {
    id?: string
    payrollId: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hoursWorked?: Decimal | DecimalJsLike | number | string | null
    overtimeHours?: Decimal | DecimalJsLike | number | string | null
    bonusAmount?: Decimal | DecimalJsLike | number | string | null
    allowances?: Decimal | DecimalJsLike | number | string | null
    grossPay: Decimal | DecimalJsLike | number | string
    taxDeductions: Decimal | DecimalJsLike | number | string
    socialSecurity: Decimal | DecimalJsLike | number | string
    otherDeductions?: Decimal | DecimalJsLike | number | string | null
    netPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryAdjustmentCreateManyEmployeeInput = {
    id?: string
    adjustmentType: $Enums.SalaryAdjustmentType
    previousAmount: Decimal | DecimalJsLike | number | string
    newAmount: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    reason: string
    notes?: string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SalaryAdjustmentCreateManyApproverInput = {
    id?: string
    employeeId: string
    adjustmentType: $Enums.SalaryAdjustmentType
    previousAmount: Decimal | DecimalJsLike | number | string
    newAmount: Decimal | DecimalJsLike | number | string
    effectiveDate: Date | string
    reason: string
    notes?: string | null
    approvedAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeExpenseCreateManyEmployeeInput = {
    id?: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedBy?: string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    reimbursementTransactionId?: string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeExpenseCreateManyReviewerInput = {
    id?: string
    employeeId: string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    category: string
    expenseDate: Date | string
    receiptUrl?: string | null
    status?: $Enums.ExpenseStatus
    submittedAt?: Date | string | null
    reviewedAt?: Date | string | null
    reimbursedAt?: Date | string | null
    reimbursementTransactionId?: string | null
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTORequestCreateManyEmployeeInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    status?: $Enums.PTOStatus
    reason?: string | null
    submittedAt?: Date | string | null
    approvedBy?: string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    cancelledAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTORequestCreateManyApproverInput = {
    id?: string
    employeeId: string
    startDate: Date | string
    endDate: Date | string
    totalDays: Decimal | DecimalJsLike | number | string
    status?: $Enums.PTOStatus
    reason?: string | null
    submittedAt?: Date | string | null
    approvedAt?: Date | string | null
    rejectedAt?: Date | string | null
    cancelledAt?: Date | string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PTOBalanceCreateManyEmployeeInput = {
    id?: string
    year: number
    totalDays: Decimal | DecimalJsLike | number | string
    usedDays?: Decimal | DecimalJsLike | number | string
    carryOverDays?: Decimal | DecimalJsLike | number | string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TaskUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutTasksNestedInput
  }

  export type TaskUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    projectId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TaskUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    projectId?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    parent?: DocumentUpdateOneWithoutChildrenNestedInput
    children?: DocumentUpdateManyWithoutParentNestedInput
    revisions?: DocumentRevisionUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    children?: DocumentUncheckedUpdateManyWithoutParentNestedInput
    revisions?: DocumentRevisionUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumDocumentTypeFieldUpdateOperationsInput | $Enums.DocumentType
    status?: EnumDocumentStatusFieldUpdateOperationsInput | $Enums.DocumentStatus
    tags?: DocumentUpdatetagsInput | string[]
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    viewCount?: IntFieldUpdateOperationsInput | number
    lastViewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentRevisionUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutRevisionsNestedInput
  }

  export type DocumentRevisionUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentRevisionUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    summary?: NullableStringFieldUpdateOperationsInput | string | null
    changeLog?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutSalesNestedInput
  }

  export type SaleUncheckedUpdateWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SaleUncheckedUpdateManyWithoutSellerInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    quantity?: IntFieldUpdateOperationsInput | number
    total?: FloatFieldUpdateOperationsInput | number
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: BankAccountUpdateOneRequiredWithoutTransactionsNestedInput
    category?: TransactionCategoryUpdateOneWithoutTransactionsNestedInput
    payroll?: PayrollUpdateOneWithoutTransactionsNestedInput
    expenseReimbursement?: EmployeeExpenseUpdateOneWithoutReimbursementTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollId?: NullableStringFieldUpdateOperationsInput | string | null
    expenseReimbursement?: EmployeeExpenseUncheckedUpdateOneWithoutReimbursementTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditTrailUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumAuditOperationFieldUpdateOperationsInput | $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditTrailUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumAuditOperationFieldUpdateOperationsInput | $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AuditTrailUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableName?: StringFieldUpdateOperationsInput | string
    recordId?: StringFieldUpdateOperationsInput | string
    operation?: EnumAuditOperationFieldUpdateOperationsInput | $Enums.AuditOperation
    beforeData?: NullableJsonNullValueInput | InputJsonValue
    afterData?: NullableJsonNullValueInput | InputJsonValue
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type NotificationTemplateUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: NotificationRuleUpdateManyWithoutTemplateNestedInput
    notifications?: NotificationUpdateManyWithoutTemplateNestedInput
  }

  export type NotificationTemplateUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rules?: NotificationRuleUncheckedUpdateManyWithoutTemplateNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type NotificationTemplateUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    variables?: NotificationTemplateUpdatevariablesInput | string[]
    isActive?: BoolFieldUpdateOperationsInput | boolean
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRuleUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: NotificationTemplateUpdateOneRequiredWithoutRulesNestedInput
    notifications?: NotificationUpdateManyWithoutRuleNestedInput
  }

  export type NotificationRuleUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type NotificationRuleUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    templateId?: StringFieldUpdateOperationsInput | string
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: NotificationTemplateUpdateOneWithoutNotificationsNestedInput
    rule?: NotificationRuleUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicTokenUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicTokenUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MagicTokenUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    purpose?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    processor?: UserUpdateOneWithoutPayrollsProcessedNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutPayrollNestedInput
    transactions?: TransactionUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutPayrollNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedBy?: NullableStringFieldUpdateOperationsInput | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUpdateWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutPayrollsApprovedNestedInput
    payrollEntries?: PayrollEntryUpdateManyWithoutPayrollNestedInput
    transactions?: TransactionUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payrollEntries?: PayrollEntryUncheckedUpdateManyWithoutPayrollNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateManyWithoutProcessorInput = {
    id?: StringFieldUpdateOperationsInput | string
    runDate?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    payPeriodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumPayrollStatusFieldUpdateOperationsInput | $Enums.PayrollStatus
    totalGrossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    totalNetPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hoursWorked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allowances?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payroll?: PayrollUpdateOneRequiredWithoutPayrollEntriesNestedInput
  }

  export type PayrollEntryUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    payrollId?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hoursWorked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allowances?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    payrollId?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hoursWorked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allowances?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryAdjustmentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumSalaryAdjustmentTypeFieldUpdateOperationsInput | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutSalaryAdjustmentsApprovedNestedInput
  }

  export type SalaryAdjustmentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumSalaryAdjustmentTypeFieldUpdateOperationsInput | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryAdjustmentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumSalaryAdjustmentTypeFieldUpdateOperationsInput | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryAdjustmentUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumSalaryAdjustmentTypeFieldUpdateOperationsInput | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutSalaryAdjustmentsNestedInput
  }

  export type SalaryAdjustmentUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumSalaryAdjustmentTypeFieldUpdateOperationsInput | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SalaryAdjustmentUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumSalaryAdjustmentTypeFieldUpdateOperationsInput | $Enums.SalaryAdjustmentType
    previousAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    newAmount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    effectiveDate?: DateTimeFieldUpdateOperationsInput | Date | string
    reason?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeExpenseUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviewer?: UserUpdateOneWithoutExpenseReviewsNestedInput
    reimbursementTransaction?: TransactionUpdateOneWithoutExpenseReimbursementNestedInput
  }

  export type EmployeeExpenseUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeExpenseUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedBy?: NullableStringFieldUpdateOperationsInput | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeExpenseUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutEmployeeExpensesNestedInput
    reimbursementTransaction?: TransactionUpdateOneWithoutExpenseReimbursementNestedInput
  }

  export type EmployeeExpenseUncheckedUpdateWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeExpenseUncheckedUpdateManyWithoutReviewerInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    category?: StringFieldUpdateOperationsInput | string
    expenseDate?: DateTimeFieldUpdateOperationsInput | Date | string
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumExpenseStatusFieldUpdateOperationsInput | $Enums.ExpenseStatus
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reviewedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reimbursementTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTORequestUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFieldUpdateOperationsInput | $Enums.PTOStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    approver?: UserUpdateOneWithoutPtoApprovalsNestedInput
  }

  export type PTORequestUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFieldUpdateOperationsInput | $Enums.PTOStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTORequestUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFieldUpdateOperationsInput | $Enums.PTOStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTORequestUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFieldUpdateOperationsInput | $Enums.PTOStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutPtoRequestsNestedInput
  }

  export type PTORequestUncheckedUpdateWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFieldUpdateOperationsInput | $Enums.PTOStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTORequestUncheckedUpdateManyWithoutApproverInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPTOStatusFieldUpdateOperationsInput | $Enums.PTOStatus
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTOBalanceUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTOBalanceUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PTOBalanceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    usedDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    carryOverDays?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRuleCreateManyTemplateInput = {
    id?: string
    name: string
    description?: string | null
    trigger: $Enums.RuleTrigger
    conditions: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    recipients: JsonNullValueInput | InputJsonValue
    delay?: number | null
    createdBy: string
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyTemplateInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    recipientId: string
    ruleId?: string | null
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationRuleUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutNotificationRulesCreatedNestedInput
    notifications?: NotificationUpdateManyWithoutRuleNestedInput
  }

  export type NotificationRuleUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notifications?: NotificationUncheckedUpdateManyWithoutRuleNestedInput
  }

  export type NotificationRuleUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    trigger?: EnumRuleTriggerFieldUpdateOperationsInput | $Enums.RuleTrigger
    conditions?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    recipients?: JsonNullValueInput | InputJsonValue
    delay?: NullableIntFieldUpdateOperationsInput | number | null
    createdBy?: StringFieldUpdateOperationsInput | string
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    rule?: NotificationRuleUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    ruleId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyRuleInput = {
    id?: string
    type: $Enums.NotificationType
    status?: $Enums.NotificationStatus
    subject?: string | null
    content: string
    recipientId: string
    templateId?: string | null
    entityType?: string | null
    entityId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: Date | string | null
    sentAt?: Date | string | null
    failedAt?: Date | string | null
    errorMessage?: string | null
    readAt?: Date | string | null
    tenantId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipient?: UserUpdateOneRequiredWithoutNotificationsNestedInput
    template?: NotificationTemplateUpdateOneWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutRuleInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    status?: EnumNotificationStatusFieldUpdateOperationsInput | $Enums.NotificationStatus
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    content?: StringFieldUpdateOperationsInput | string
    recipientId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    entityType?: NullableStringFieldUpdateOperationsInput | string | null
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    scheduledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryCreateManyPayrollInput = {
    id?: string
    employeeId: string
    baseSalary: Decimal | DecimalJsLike | number | string
    hoursWorked?: Decimal | DecimalJsLike | number | string | null
    overtimeHours?: Decimal | DecimalJsLike | number | string | null
    bonusAmount?: Decimal | DecimalJsLike | number | string | null
    allowances?: Decimal | DecimalJsLike | number | string | null
    grossPay: Decimal | DecimalJsLike | number | string
    taxDeductions: Decimal | DecimalJsLike | number | string
    socialSecurity: Decimal | DecimalJsLike | number | string
    otherDeductions?: Decimal | DecimalJsLike | number | string | null
    netPay: Decimal | DecimalJsLike | number | string
    notes?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionCreateManyPayrollInput = {
    id?: string
    description: string
    amount: number
    type: $Enums.TransactionType
    status?: $Enums.TransactionStatus
    paymentMethod?: $Enums.PaymentMethod
    reference?: string | null
    externalId?: string | null
    accountId: string
    categoryId?: string | null
    customerName?: string | null
    supplierName?: string | null
    employeeName?: string | null
    projectName?: string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: string | null
    receiptUrl?: string | null
    mpPaymentId?: string | null
    mpStatus?: string | null
    mpPaymentType?: string | null
    tenantId?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    deletedBy?: string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollEntryUpdateWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hoursWorked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allowances?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: UserUpdateOneRequiredWithoutPayrollEntriesNestedInput
  }

  export type PayrollEntryUncheckedUpdateWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hoursWorked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allowances?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollEntryUncheckedUpdateManyWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    baseSalary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    hoursWorked?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    overtimeHours?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    bonusAmount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    allowances?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    grossPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    taxDeductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    socialSecurity?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    otherDeductions?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    netPay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: BankAccountUpdateOneRequiredWithoutTransactionsNestedInput
    category?: TransactionCategoryUpdateOneWithoutTransactionsNestedInput
    creator?: UserUpdateOneWithoutTransactionsNestedInput
    expenseReimbursement?: EmployeeExpenseUpdateOneWithoutReimbursementTransactionNestedInput
  }

  export type TransactionUncheckedUpdateWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expenseReimbursement?: EmployeeExpenseUncheckedUpdateOneWithoutReimbursementTransactionNestedInput
  }

  export type TransactionUncheckedUpdateManyWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    accountId?: StringFieldUpdateOperationsInput | string
    categoryId?: NullableStringFieldUpdateOperationsInput | string | null
    customerName?: NullableStringFieldUpdateOperationsInput | string | null
    supplierName?: NullableStringFieldUpdateOperationsInput | string | null
    employeeName?: NullableStringFieldUpdateOperationsInput | string | null
    projectName?: NullableStringFieldUpdateOperationsInput | string | null
    items?: NullableJsonNullValueInput | InputJsonValue
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    receiptUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentId?: NullableStringFieldUpdateOperationsInput | string | null
    mpStatus?: NullableStringFieldUpdateOperationsInput | string | null
    mpPaymentType?: NullableStringFieldUpdateOperationsInput | string | null
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}