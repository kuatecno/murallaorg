import { AbilityOptions, AbilityTuple, PureAbility, RawRuleFrom } from '@casl/ability';
import type { WhereInputPerModel, ModelName, PrismaQuery } from './prismaClientBoundTypes';
export type { PrismaQuery, WhereInput } from './prismaClientBoundTypes';
export type { Model, Subjects } from './runtime';
export { prismaQuery, ParsingQueryError } from './runtime';
declare const createPrismaAbility: {
    <T extends PureAbility<any, PrismaQuery>>(rules?: (import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]> extends infer T_1 ? T_1 extends import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]> ? T_1 extends import("@casl/ability/dist/types/types").AbilityTupleType ? import("@casl/ability").SubjectRawRule<T_1[0], T_1[1], T[typeof import("@casl/ability/dist/types/RuleIndex").ɵconditions]> : import("@casl/ability").ClaimRawRule<Extract<import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]>, string>> : never : never)[] | undefined, options?: import("@casl/ability").AbilityOptionsOf<T> | undefined): T;
    <A extends AbilityTuple = [string, import("@prisma/client").Prisma.ModelName], C extends PrismaQuery = PrismaQuery>(rules?: (import("@casl/ability/dist/types/types").ToAbilityTypes<A> extends infer T ? T extends import("@casl/ability/dist/types/types").ToAbilityTypes<A> ? T extends import("@casl/ability/dist/types/types").AbilityTupleType ? import("@casl/ability").SubjectRawRule<T[0], T[1], C> : import("@casl/ability").ClaimRawRule<Extract<import("@casl/ability/dist/types/types").ToAbilityTypes<A>, string>> : never : never)[] | undefined, options?: AbilityOptions<A, C> | undefined): PureAbility<A, C>;
};
declare const accessibleBy: (ability: PureAbility<any, PrismaQuery>, action?: string) => WhereInputPerModel;
export { createPrismaAbility, accessibleBy, };
/**
 * Uses conditional type to support union distribution
 */
type ExtendedAbilityTuple<T extends AbilityTuple> = T extends AbilityTuple ? [T[0], 'all' | T[1]] : never;
/**
 * @deprecated use createPrismaAbility instead
 */
export declare class PrismaAbility<A extends AbilityTuple = [string, ModelName], C extends PrismaQuery = PrismaQuery> extends PureAbility<ExtendedAbilityTuple<A>, C> {
    constructor(rules?: RawRuleFrom<ExtendedAbilityTuple<A>, C>[], options?: AbilityOptions<ExtendedAbilityTuple<A>, C>);
}
